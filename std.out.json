{"bufio":{"bufio.brg":"use io;\n\nfn NewReadWriter(r: &Reader, w: &Writer) -> &ReadWriter {\n    EXT\n}\n\nfn NewReader(rd: io::Reader) -> &Reader {\n    EXT\n}\n\nfn NewReaderSize(rd: io::Reader, size: int) -> &Reader {\n    EXT\n}\n\nfn NewScanner(r: io::Reader) -> &Scanner {\n    EXT\n}\n\nfn NewWriter(w: io::Writer) -> &Writer {\n    EXT\n}\n\nfn NewWriterSize(w: io::Writer, size: int) -> &Writer {\n    EXT\n}\n\nfn ScanBytes(data: [byte], atEOF: bool) -> (int, [byte], error) {\n    EXT\n}\n\nfn ScanLines(data: [byte], atEOF: bool) -> (int, [byte], error) {\n    EXT\n}\n\nfn ScanRunes(data: [byte], atEOF: bool) -> (int, [byte], error) {\n    EXT\n}\n\nfn ScanWords(data: [byte], atEOF: bool) -> (int, [byte], error) {\n    EXT\n}\n\nimpl Reader {\n    fn Buffered(&self) -> int {\n        EXT\n    }\n\n    fn Discard(&self, n: int) -> Result<int> {\n        EXT\n    }\n\n    fn Peek(&self, n: int) -> Result<[byte]> {\n        EXT\n    }\n\n    fn Read(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn ReadByte(&self) -> Result<byte> {\n        EXT\n    }\n\n    fn ReadBytes(&self, delim: byte) -> Result<[byte]> {\n        EXT\n    }\n\n    fn ReadLine(&self) -> ([byte], bool, error) {\n        EXT\n    }\n\n    fn ReadRune(&self) -> (rune, int, error) {\n        EXT\n    }\n\n    fn ReadSlice(&self, delim: byte) -> Result<[byte]> {\n        EXT\n    }\n\n    fn ReadString(&self, delim: byte) -> Result<string> {\n        EXT\n    }\n\n    fn Reset(&self, r: io::Reader) -> () {\n        EXT\n    }\n\n    fn Size(&self) -> int {\n        EXT\n    }\n\n    fn UnreadByte(&self) -> error {\n        EXT\n    }\n\n    fn UnreadRune(&self) -> error {\n        EXT\n    }\n\n    fn WriteTo(&self, w: io::Writer) -> Result<int64> {\n        EXT\n    }\n}\n\nimpl Scanner {\n    fn Buffer(&self, buf: [byte], max: int) -> () {\n        EXT\n    }\n\n    fn Bytes(&self) -> [byte] {\n        EXT\n    }\n\n    fn Err(&self) -> error {\n        EXT\n    }\n\n    fn Scan(&self) -> bool {\n        EXT\n    }\n\n    fn Split(&self, split: SplitFunc) -> () {\n        EXT\n    }\n\n    fn Text(&self) -> string {\n        EXT\n    }\n}\n\nimpl Writer {\n    fn Available(&self) -> int {\n        EXT\n    }\n\n    fn AvailableBuffer(&self) -> [byte] {\n        EXT\n    }\n\n    fn Buffered(&self) -> int {\n        EXT\n    }\n\n    fn Flush(&self) -> error {\n        EXT\n    }\n\n    fn ReadFrom(&self, r: io::Reader) -> Result<int64> {\n        EXT\n    }\n\n    fn Reset(&self, w: io::Writer) -> () {\n        EXT\n    }\n\n    fn Size(&self) -> int {\n        EXT\n    }\n\n    fn Write(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn WriteByte(&self, c: byte) -> error {\n        EXT\n    }\n\n    fn WriteRune(&self, r: rune) -> Result<int> {\n        EXT\n    }\n\n    fn WriteString(&self, s: string) -> Result<int> {\n        EXT\n    }\n}\n\ntype SplitFunc = fn(data: [byte], atEOF: bool) -> (int, [byte], error);\n\nstruct ReadWriter {\n    // skipping embedded field &Reader,\n    // skipping embedded field &Writer\n}\n\nstruct Reader {}\n\nstruct Scanner {}\n\nstruct Writer {}\n"},"strconv":{"strconv.brg":"fn AppendBool(dst: [byte], b: bool) -> [byte] {\n    EXT\n}\n\nfn AppendFloat(dst: [byte], f: float64, fmt: byte, prec: int, bitSize: int) -> [byte] {\n    EXT\n}\n\nfn AppendInt(dst: [byte], i: int64, base: int) -> [byte] {\n    EXT\n}\n\nfn AppendQuote(dst: [byte], s: string) -> [byte] {\n    EXT\n}\n\nfn AppendQuoteRune(dst: [byte], r: rune) -> [byte] {\n    EXT\n}\n\nfn AppendQuoteRuneToASCII(dst: [byte], r: rune) -> [byte] {\n    EXT\n}\n\nfn AppendQuoteRuneToGraphic(dst: [byte], r: rune) -> [byte] {\n    EXT\n}\n\nfn AppendQuoteToASCII(dst: [byte], s: string) -> [byte] {\n    EXT\n}\n\nfn AppendQuoteToGraphic(dst: [byte], s: string) -> [byte] {\n    EXT\n}\n\nfn AppendUint(dst: [byte], i: uint64, base: int) -> [byte] {\n    EXT\n}\n\nfn Atoi(s: string) -> Result<int> {\n    EXT\n}\n\nfn CanBackquote(s: string) -> bool {\n    EXT\n}\n\nfn FormatBool(b: bool) -> string {\n    EXT\n}\n\nfn FormatComplex(c: complex128, fmt: byte, prec: int, bitSize: int) -> string {\n    EXT\n}\n\nfn FormatFloat(f: float64, fmt: byte, prec: int, bitSize: int) -> string {\n    EXT\n}\n\nfn FormatInt(i: int64, base: int) -> string {\n    EXT\n}\n\nfn FormatUint(i: uint64, base: int) -> string {\n    EXT\n}\n\nfn IsGraphic(r: rune) -> bool {\n    EXT\n}\n\nfn IsPrint(r: rune) -> bool {\n    EXT\n}\n\nfn Itoa(i: int) -> string {\n    EXT\n}\n\nfn ParseBool(str: string) -> Result<bool> {\n    EXT\n}\n\nfn ParseComplex(s: string, bitSize: int) -> Result<complex128> {\n    EXT\n}\n\nfn ParseFloat(s: string, bitSize: int) -> Result<float64> {\n    EXT\n}\n\nfn ParseInt(s: string, base: int, bitSize: int) -> Result<int64> {\n    EXT\n}\n\nfn ParseUint(s: string, base: int, bitSize: int) -> Result<uint64> {\n    EXT\n}\n\nfn Quote(s: string) -> string {\n    EXT\n}\n\nfn QuoteRune(r: rune) -> string {\n    EXT\n}\n\nfn QuoteRuneToASCII(r: rune) -> string {\n    EXT\n}\n\nfn QuoteRuneToGraphic(r: rune) -> string {\n    EXT\n}\n\nfn QuoteToASCII(s: string) -> string {\n    EXT\n}\n\nfn QuoteToGraphic(s: string) -> string {\n    EXT\n}\n\nfn QuotedPrefix(s: string) -> Result<string> {\n    EXT\n}\n\nfn Unquote(s: string) -> Result<string> {\n    EXT\n}\n\nfn UnquoteChar(s: string, quote: byte) -> (rune, bool, string, error) {\n    EXT\n}\n\nimpl NumError {\n    fn Error(&self) -> string {\n        EXT\n    }\n\n    fn Unwrap(&self) -> error {\n        EXT\n    }\n}\n\nstruct NumError {\n    Func: string,\n    Num: string,\n    Err: error,\n}\n"},"strings":{"strings.brg":"use io;\nuse unicode;\n\nfn NewReader(s: string) -> &Reader {\n    EXT\n}\n\nfn NewReplacer(oldnew: VarArgs<string>) -> &Replacer {\n    EXT\n}\n\nfn Clone(s: string) -> string {\n    EXT\n}\n\nfn Compare(a: string, b: string) -> int {\n    EXT\n}\n\nfn Contains(s: string, substr: string) -> bool {\n    EXT\n}\n\nfn ContainsAny(s: string, chars: string) -> bool {\n    EXT\n}\n\nfn ContainsRune(s: string, r: rune) -> bool {\n    EXT\n}\n\nfn Count(s: string, substr: string) -> int {\n    EXT\n}\n\nfn Cut(s: string, sep: string) -> Option<string> {\n    EXT\n}\n\nfn EqualFold(s: string, t: string) -> bool {\n    EXT\n}\n\nfn Fields(s: string) -> [string] {\n    EXT\n}\n\nfn FieldsFunc(s: string, f: fn(param0: rune) -> bool) -> [string] {\n    EXT\n}\n\nfn HasPrefix(s: string, prefix: string) -> bool {\n    EXT\n}\n\nfn HasSuffix(s: string, suffix: string) -> bool {\n    EXT\n}\n\nfn Index(s: string, substr: string) -> int {\n    EXT\n}\n\nfn IndexAny(s: string, chars: string) -> int {\n    EXT\n}\n\nfn IndexByte(s: string, c: byte) -> int {\n    EXT\n}\n\nfn IndexFunc(s: string, f: fn(param0: rune) -> bool) -> int {\n    EXT\n}\n\nfn IndexRune(s: string, r: rune) -> int {\n    EXT\n}\n\nfn Join(elems: [string], sep: string) -> string {\n    EXT\n}\n\nfn LastIndex(s: string, substr: string) -> int {\n    EXT\n}\n\nfn LastIndexAny(s: string, chars: string) -> int {\n    EXT\n}\n\nfn LastIndexByte(s: string, c: byte) -> int {\n    EXT\n}\n\nfn LastIndexFunc(s: string, f: fn(param0: rune) -> bool) -> int {\n    EXT\n}\n\nfn Map(mapping: fn(param0: rune) -> rune, s: string) -> string {\n    EXT\n}\n\nfn Repeat(s: string, count: int) -> string {\n    EXT\n}\n\nfn Replace(s: string, old: string, new: string, n: int) -> string {\n    EXT\n}\n\nfn ReplaceAll(s: string, old: string, new: string) -> string {\n    EXT\n}\n\nfn Split(s: string, sep: string) -> [string] {\n    EXT\n}\n\nfn SplitAfter(s: string, sep: string) -> [string] {\n    EXT\n}\n\nfn SplitAfterN(s: string, sep: string, n: int) -> [string] {\n    EXT\n}\n\nfn SplitN(s: string, sep: string, n: int) -> [string] {\n    EXT\n}\n\nfn Title(s: string) -> string {\n    EXT\n}\n\nfn ToLower(s: string) -> string {\n    EXT\n}\n\nfn ToLowerSpecial(c: unicode::SpecialCase, s: string) -> string {\n    EXT\n}\n\nfn ToTitle(s: string) -> string {\n    EXT\n}\n\nfn ToTitleSpecial(c: unicode::SpecialCase, s: string) -> string {\n    EXT\n}\n\nfn ToUpper(s: string) -> string {\n    EXT\n}\n\nfn ToUpperSpecial(c: unicode::SpecialCase, s: string) -> string {\n    EXT\n}\n\nfn ToValidUTF8(s: string, replacement: string) -> string {\n    EXT\n}\n\nfn Trim(s: string, cutset: string) -> string {\n    EXT\n}\n\nfn TrimFunc(s: string, f: fn(param0: rune) -> bool) -> string {\n    EXT\n}\n\nfn TrimLeft(s: string, cutset: string) -> string {\n    EXT\n}\n\nfn TrimLeftFunc(s: string, f: fn(param0: rune) -> bool) -> string {\n    EXT\n}\n\nfn TrimPrefix(s: string, prefix: string) -> string {\n    EXT\n}\n\nfn TrimRight(s: string, cutset: string) -> string {\n    EXT\n}\n\nfn TrimRightFunc(s: string, f: fn(param0: rune) -> bool) -> string {\n    EXT\n}\n\nfn TrimSpace(s: string) -> string {\n    EXT\n}\n\nfn TrimSuffix(s: string, suffix: string) -> string {\n    EXT\n}\n\nimpl Builder {\n    fn Cap(&self) -> int {\n        EXT\n    }\n\n    fn Grow(&self, n: int) -> () {\n        EXT\n    }\n\n    fn Len(&self) -> int {\n        EXT\n    }\n\n    fn Reset(&self) -> () {\n        EXT\n    }\n\n    fn String(&self) -> string {\n        EXT\n    }\n\n    fn Write(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn WriteByte(&self, c: byte) -> error {\n        EXT\n    }\n\n    fn WriteRune(&self, r: rune) -> Result<int> {\n        EXT\n    }\n\n    fn WriteString(&self, s: string) -> Result<int> {\n        EXT\n    }\n}\n\nimpl Reader {\n    fn Len(&self) -> int {\n        EXT\n    }\n\n    fn Read(&self, b: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn ReadAt(&self, b: [byte], off: int64) -> Result<int> {\n        EXT\n    }\n\n    fn ReadByte(&self) -> Result<byte> {\n        EXT\n    }\n\n    fn ReadRune(&self) -> (rune, int, error) {\n        EXT\n    }\n\n    fn Reset(&self, s: string) -> () {\n        EXT\n    }\n\n    fn Seek(&self, offset: int64, whence: int) -> Result<int64> {\n        EXT\n    }\n\n    fn Size(&self) -> int64 {\n        EXT\n    }\n\n    fn UnreadByte(&self) -> error {\n        EXT\n    }\n\n    fn UnreadRune(&self) -> error {\n        EXT\n    }\n\n    fn WriteTo(&self, w: io::Writer) -> Result<int64> {\n        EXT\n    }\n}\n\nimpl Replacer {\n    fn Replace(&self, s: string) -> string {\n        EXT\n    }\n\n    fn WriteString(&self, w: io::Writer, s: string) -> Result<int> {\n        EXT\n    }\n}\n\nstruct Builder {}\n\nstruct Reader {}\n\nstruct Replacer {}\n"},"net/http":{"http.brg":"struct Request {}\n\ntrait ResponseWriter {\n    fn Write(bytes: [byte]) -> Result<int>;\n}\n\ntrait Handler {\n    fn ServeHTTP(w: ResponseWriter, r: &Request);\n}\n\nfn Handle(pattern: string, handler: Handler) {\n    EXT\n}\nfn ListenAndServe(addr: string, handler: Handler) {\n    EXT\n}\n"},"regexp":{"regexp.brg":"use io;\n\nfn Compile(expr: string) -> Result<&Regexp> {\n    EXT\n}\n\nfn CompilePOSIX(expr: string) -> Result<&Regexp> {\n    EXT\n}\n\nfn MustCompile(str: string) -> &Regexp {\n    EXT\n}\n\nfn MustCompilePOSIX(str: string) -> &Regexp {\n    EXT\n}\n\nfn Match(pattern: string, b: [byte]) -> Result<bool> {\n    EXT\n}\n\nfn MatchReader(pattern: string, r: io::RuneReader) -> Result<bool> {\n    EXT\n}\n\nfn MatchString(pattern: string, s: string) -> Result<bool> {\n    EXT\n}\n\nfn QuoteMeta(s: string) -> string {\n    EXT\n}\n\nimpl Regexp {\n    fn Copy(&self) -> &Regexp {\n        EXT\n    }\n\n    fn Expand(&self, dst: [byte], template: [byte], src: [byte], match_: [int]) -> [byte] {\n        EXT\n    }\n\n    fn ExpandString(&self, dst: [byte], template: string, src: string, match_: [int]) -> [byte] {\n        EXT\n    }\n\n    fn Find(&self, b: [byte]) -> [byte] {\n        EXT\n    }\n\n    fn FindAll(&self, b: [byte], n: int) -> [[byte]] {\n        EXT\n    }\n\n    fn FindAllIndex(&self, b: [byte], n: int) -> [[int]] {\n        EXT\n    }\n\n    fn FindAllString(&self, s: string, n: int) -> [string] {\n        EXT\n    }\n\n    fn FindAllStringIndex(&self, s: string, n: int) -> [[int]] {\n        EXT\n    }\n\n    fn FindAllStringSubmatch(&self, s: string, n: int) -> [[string]] {\n        EXT\n    }\n\n    fn FindAllStringSubmatchIndex(&self, s: string, n: int) -> [[int]] {\n        EXT\n    }\n\n    fn FindAllSubmatch(&self, b: [byte], n: int) -> [[[byte]]] {\n        EXT\n    }\n\n    fn FindAllSubmatchIndex(&self, b: [byte], n: int) -> [[int]] {\n        EXT\n    }\n\n    fn FindIndex(&self, b: [byte]) -> [int] {\n        EXT\n    }\n\n    fn FindReaderIndex(&self, r: io::RuneReader) -> [int] {\n        EXT\n    }\n\n    fn FindReaderSubmatchIndex(&self, r: io::RuneReader) -> [int] {\n        EXT\n    }\n\n    fn FindString(&self, s: string) -> string {\n        EXT\n    }\n\n    fn FindStringIndex(&self, s: string) -> [int] {\n        EXT\n    }\n\n    fn FindStringSubmatch(&self, s: string) -> [string] {\n        EXT\n    }\n\n    fn FindStringSubmatchIndex(&self, s: string) -> [int] {\n        EXT\n    }\n\n    fn FindSubmatch(&self, b: [byte]) -> [[byte]] {\n        EXT\n    }\n\n    fn FindSubmatchIndex(&self, b: [byte]) -> [int] {\n        EXT\n    }\n\n    fn LiteralPrefix(&self) -> Option<string> {\n        EXT\n    }\n\n    fn Longest(&self) -> () {\n        EXT\n    }\n\n    fn Match(&self, b: [byte]) -> bool {\n        EXT\n    }\n\n    fn MatchReader(&self, r: io::RuneReader) -> bool {\n        EXT\n    }\n\n    fn MatchString(&self, s: string) -> bool {\n        EXT\n    }\n\n    fn NumSubexp(&self) -> int {\n        EXT\n    }\n\n    fn ReplaceAll(&self, src: [byte], repl: [byte]) -> [byte] {\n        EXT\n    }\n\n    fn ReplaceAllFunc(&self, src: [byte], repl: fn(param0: [byte]) -> [byte]) -> [byte] {\n        EXT\n    }\n\n    fn ReplaceAllLiteral(&self, src: [byte], repl: [byte]) -> [byte] {\n        EXT\n    }\n\n    fn ReplaceAllLiteralString(&self, src: string, repl: string) -> string {\n        EXT\n    }\n\n    fn ReplaceAllString(&self, src: string, repl: string) -> string {\n        EXT\n    }\n\n    fn ReplaceAllStringFunc(&self, src: string, repl: fn(param0: string) -> string) -> string {\n        EXT\n    }\n\n    fn Split(&self, s: string, n: int) -> [string] {\n        EXT\n    }\n\n    fn String(&self) -> string {\n        EXT\n    }\n\n    fn SubexpIndex(&self, name: string) -> int {\n        EXT\n    }\n\n    fn SubexpNames(&self) -> [string] {\n        EXT\n    }\n}\n\nstruct Regexp {}\n"},"core":{"core.brg":"// TODO asdf move this to builtin.brg\ntrait ComplexType {}\ntrait FloatType {}\ntrait IntegerType {}\ntrait any {}\ntype bool = EXT;\ntype byte = EXT;\ntrait comparable {}\ntype complex128 = EXT;\ntype complex64 = EXT;\ntrait error {\n    fn Error() -> string;\n}\ntype float32 = EXT;\ntype float64 = EXT;\ntype int = EXT;\ntype int16 = EXT;\ntype int32 = EXT;\ntype int64 = EXT;\ntype int8 = EXT;\ntype rune = EXT;\ntype string = EXT;\ntype uint = EXT;\ntype uint16 = EXT;\ntype uint32 = EXT;\ntype uint64 = EXT;\ntype uint8 = EXT;\ntype uintptr = EXT;\n\nfn string(a: any) -> string {\n    EXT\n}\n\n/// ---------------------------------------------------------------\n\ntype Map<K, V> = EXT;\n\ntype EnumerateSlice<T> = EXT;\n\ntype VarArgs<T> = EXT;\n\ntype Channel<T> = EXT;\ntype Sender<T> = EXT;\ntype Receiver<T> = EXT;\n\ntype Unit = EXT;\ntype Slice<T> = EXT;\ntype never = EXT;\ntype Ref<T> = EXT;\ntype RefMut<T> = EXT;\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nimpl<T, E> Result<T, E> {\n    fn IsOk(self) -> bool {\n        match self {\n            Ok(_) => true,\n            Err(_) => false,\n        }\n    }\n\n    fn unwrap(self) -> T {\n        rawgo!(\n            \"\n      if self.tag == Result_Err {\n        inspect(self.Err)\n        panic(\\\"Unwrapped Err value\\\")\n      }\n\n      return self.Ok\n    \"\n        )\n    }\n}\n\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nimpl<T> Option<T> {\n    fn IsSome(self) -> bool {\n        match self {\n            Some(_) => true,\n            None => false,\n        }\n    }\n\n    fn IsNone(self) -> bool {\n        !self.IsSome()\n    }\n\n    fn unwrap_or(self, def: T) -> T {\n        match self {\n            Some(x) => x,\n            None => def,\n        }\n    }\n\n    fn unwrap_or_else(self, f: fn() -> T) -> T {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n\n    fn unwrap(self) -> T {\n        rawgo!(\n            \"\n        if self.tag == Option_None {\n          panic(\\\"Unwrapped None value\\\")\n        }\n\n        return self.Some\n      \"\n        )\n    }\n\n    fn ToOption(value: T, check: bool) -> Option<T> {\n        if check {\n            Some(value)\n        } else {\n            None\n        }\n    }\n}\n\nstruct Tuple2<T, Y> {\n    first: T,\n    second: Y,\n}\n\nstruct Tuple3<T, Y, Z> {\n    first: T,\n    second: Y,\n    third: Z,\n}\n\nstruct Tuple4<T, X, Y, Z> {\n    first: T,\n    second: X,\n    third: Y,\n    fourth: Z,\n}\n\nfn zero_value<T>() -> T {\n    rawgo!(\n        \"\n    var m T\n    return m\n  \"\n    )\n}\n\nfn assert_eq<T>(a: T, b: T) {\n    rawgo!(\n        \"\n    if !reflect.DeepEqual(a, b) {\n        inspect(a);\n        inspect(b);\n        panic(\\\"something wrong\\\")\n    }\n    \"\n    )\n}\n\nfn inspect<T>(a: T) -> T {\n    rawgo!(\n        \"\n    fmt.Printf(\\\"%+v\\\\n\\\", a);\n    return a\n  \"\n    )\n}\n\nfn Debug_unreachable<T>() -> T {\n    rawgo!(\"panic(\\\"unreachable code\\\")\")\n}\n\nfn to_result(e: error) -> Result<()> {\n    rawgo!(\n        \"if e != nil {\n    return struct{}{}, e\n  }\n  return struct{}{}, nil\n  \"\n    )\n}\n\nimpl<T> [T] {\n    fn len(self) -> int {\n        rawgo!(\"return len(self)\")\n    }\n\n    fn enumerate(self) -> EnumerateSlice<T> {\n        rawgo!(\"return self\")\n    }\n\n    fn set(&mut self, index: int, item: T) {\n        rawgo!(\"self[index] = item\")\n    }\n\n    fn append(&mut self, item: T) -> [T] {\n        rawgo!(\"return append(self, item)\")\n    }\n\n    fn get(self, i: int) -> Option<T> {\n        rawgo!(\n            \"\n            if i < 0 || i >= len(self) {\n              return *new(T), false\n            }\n\n      return self[i], true\n    \"\n        )\n    }\n}\n\nimpl<K: comparable, V> Map<K, V> {\n    fn new() -> Map<K, V> {\n        rawgo!(\"return map[K]V{}\")\n    }\n\n    fn len(self) -> int {\n        rawgo!(\"return len(self)\")\n    }\n\n    fn insert(self, k: K, v: V) {\n        rawgo!(\"self[k] = v\")\n    }\n\n    fn get(self, k: K) -> Option<V> {\n        rawgo!(\n            \"\n        v, ok := self[k]\n        return v, ok\n        \"\n        )\n    }\n}\n\nimpl<T> Channel<T> {\n    fn new() -> (Sender<T>, Receiver<T>) {\n        rawgo!(\n            \"\n    ch := make(chan T)\n    return Tuple2[chan<- T, <-chan T]{ first: ch, second: ch }\n    \"\n        )\n    }\n}\n\nimpl<T> Sender<T> {\n    fn send(&mut self, value: T) {\n        rawgo!(\"self <- value\")\n    }\n\n    fn close(&mut self) {\n        rawgo!(\"close(self)\")\n    }\n}\n\nimpl<T> Receiver<T> {\n    fn recv(&self) -> T {\n        rawgo!(\"return <- self\")\n    }\n}\n\nimpl string {\n    fn enumerate(self) -> EnumerateSlice<rune> {\n        rawgo!(\"return []rune(self)\")\n    }\n}\n"},"unicode":{"unicode.brg":"fn In(r: rune, ranges: VarArgs<&RangeTable>) -> bool {\n    EXT\n}\n\nfn Is(rangeTab: &RangeTable, r: rune) -> bool {\n    EXT\n}\n\nfn IsControl(r: rune) -> bool {\n    EXT\n}\n\nfn IsDigit(r: rune) -> bool {\n    EXT\n}\n\nfn IsGraphic(r: rune) -> bool {\n    EXT\n}\n\nfn IsLetter(r: rune) -> bool {\n    EXT\n}\n\nfn IsLower(r: rune) -> bool {\n    EXT\n}\n\nfn IsMark(r: rune) -> bool {\n    EXT\n}\n\nfn IsNumber(r: rune) -> bool {\n    EXT\n}\n\nfn IsOneOf(ranges: [&RangeTable], r: rune) -> bool {\n    EXT\n}\n\nfn IsPrint(r: rune) -> bool {\n    EXT\n}\n\nfn IsPunct(r: rune) -> bool {\n    EXT\n}\n\nfn IsSpace(r: rune) -> bool {\n    EXT\n}\n\nfn IsSymbol(r: rune) -> bool {\n    EXT\n}\n\nfn IsTitle(r: rune) -> bool {\n    EXT\n}\n\nfn IsUpper(r: rune) -> bool {\n    EXT\n}\n\nfn SimpleFold(r: rune) -> rune {\n    EXT\n}\n\nfn To(_case: int, r: rune) -> rune {\n    EXT\n}\n\nfn ToLower(r: rune) -> rune {\n    EXT\n}\n\nfn ToTitle(r: rune) -> rune {\n    EXT\n}\n\nfn ToUpper(r: rune) -> rune {\n    EXT\n}\n\nimpl SpecialCase {\n    fn ToLower(self, r: rune) -> rune {\n        EXT\n    }\n\n    fn ToTitle(self, r: rune) -> rune {\n        EXT\n    }\n\n    fn ToUpper(self, r: rune) -> rune {\n        EXT\n    }\n}\n\ntype SpecialCase = [CaseRange];\n\nstruct CaseRange {\n    Lo: uint32,\n    Hi: uint32,\n    // Delta: d // TODO d is not exported so... why is it public?\n}\n\nstruct Range16 {\n    Lo: uint16,\n    Hi: uint16,\n    Stride: uint16,\n}\n\nstruct Range32 {\n    Lo: uint32,\n    Hi: uint32,\n    Stride: uint32,\n}\n\nstruct RangeTable {\n    R16: [Range16],\n    R32: [Range32],\n    LatinOffset: int,\n}\n"},"fmt":{"fmt.brg":"use io;\n\nfn Append(b: [byte], a: VarArgs<any>) -> [byte] {\n    EXT\n}\n\nfn Appendf(b: [byte], format: string, a: VarArgs<any>) -> [byte] {\n    EXT\n}\n\nfn Appendln(b: [byte], a: VarArgs<any>) -> [byte] {\n    EXT\n}\n\nfn Errorf(format: string, a: VarArgs<any>) -> error {\n    EXT\n}\n\nfn Fprint(w: io::Writer, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Fprintf(w: io::Writer, format: string, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Fprintln(w: io::Writer, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Fscan(r: io::Reader, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Fscanf(r: io::Reader, format: string, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Fscanln(r: io::Reader, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Print(a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Printf(format: string, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Println(a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Scan(a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Scanf(format: string, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Scanln(a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Sprint(a: VarArgs<any>) -> string {\n    EXT\n}\n\nfn Sprintf(format: string, a: VarArgs<any>) -> string {\n    EXT\n}\n\nfn Sprintln(a: VarArgs<any>) -> string {\n    EXT\n}\n\nfn Sscan(str: string, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Sscanf(str: string, format: string, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\nfn Sscanln(str: string, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\n\ntrait Formatter {\n    fn Format(f: State, verb: rune) -> ();\n}\n\ntrait GoStringer {\n    fn GoString() -> string;\n}\n\ntrait ScanState {\n    fn ReadRune() -> (rune, int, error);\n    fn UnreadRune() -> error;\n    fn SkipSpace() -> ();\n    fn Token(skipSpace: bool, f: fn(param0: rune) -> bool) -> Result<[byte]>;\n    fn Width() -> Option<int>;\n    fn Read(buf: [byte]) -> Result<int>;\n}\n\ntrait Scanner {\n    fn Scan(state: ScanState, verb: rune) -> error;\n}\n\ntrait State {\n    fn Write(b: [byte]) -> Result<int>;\n    fn Width() -> Option<int>;\n    fn Precision() -> Option<int>;\n    fn Flag(c: int) -> bool;\n}\n\ntrait Stringer {\n    fn String() -> string;\n}\n"},"reflect":{"reflect.brg":"// use unsafe; TODO unsafe is reserved :/\n\nfn VisibleFields(t: Type) -> [StructField] {\n    EXT\n}\n\nfn ArrayOf(length: int, elem: Type) -> Type {\n    EXT\n}\n\nfn ChanOf(dir: ChanDir, t: Type) -> Type {\n    EXT\n}\n\nfn FuncOf(in_: [Type], out: [Type], variadic: bool) -> Type {\n    EXT\n}\n\nfn MapOf(key: Type, elem: Type) -> Type {\n    EXT\n}\n\nfn PointerTo(t: Type) -> Type {\n    EXT\n}\n\nfn PtrTo(t: Type) -> Type {\n    EXT\n}\n\nfn SliceOf(t: Type) -> Type {\n    EXT\n}\n\nfn StructOf(fields: [StructField]) -> Type {\n    EXT\n}\n\nfn TypeOf(i: any) -> Type {\n    EXT\n}\n\nfn Append(s: Value, x: VarArgs<Value>) -> Value {\n    EXT\n}\n\nfn AppendSlice(s: Value, t: Value) -> Value {\n    EXT\n}\n\nfn Indirect(v: Value) -> Value {\n    EXT\n}\n\nfn MakeChan(typ: Type, buffer: int) -> Value {\n    EXT\n}\n\nfn MakeFunc(typ: Type, fn_: fn(args: [Value]) -> [Value]) -> Value {\n    EXT\n}\n\nfn MakeMap(typ: Type) -> Value {\n    EXT\n}\n\nfn MakeMapWithSize(typ: Type, n: int) -> Value {\n    EXT\n}\n\nfn MakeSlice(typ: Type, len_: int, cap: int) -> Value {\n    EXT\n}\n\nfn New(typ: Type) -> Value {\n    EXT\n}\n\n// fn NewAt  (typ: Type, p: unsafe::Pointer) -> Value { EXT }\n\nfn Select(cases: [SelectCase]) -> (int, Value, bool) {\n    EXT\n}\n\nfn ValueOf(i: any) -> Value {\n    EXT\n}\n\nfn Zero(typ: Type) -> Value {\n    EXT\n}\n\nfn Copy(dst: Value, src: Value) -> int {\n    EXT\n}\n\nfn DeepEqual(x: any, y: any) -> bool {\n    EXT\n}\n\nfn Swapper(slice: any) -> fn(i: int, j: int) -> () {\n    EXT\n}\n\nimpl ChanDir {\n    fn String(self) -> string {\n        EXT\n    }\n}\n\nimpl Kind {\n    fn String(self) -> string {\n        EXT\n    }\n}\n\nimpl MapIter {\n    fn Key(&self) -> Value {\n        EXT\n    }\n\n    fn Next(&self) -> bool {\n        EXT\n    }\n\n    fn Reset(&self, v: Value) -> () {\n        EXT\n    }\n\n    fn Value(&self) -> Value {\n        EXT\n    }\n}\n\nimpl Method {\n    fn IsExported(self) -> bool {\n        EXT\n    }\n}\n\nimpl StructField {\n    fn IsExported(self) -> bool {\n        EXT\n    }\n}\n\nimpl StructTag {\n    fn Get(self, key: string) -> string {\n        EXT\n    }\n\n    fn Lookup(self, key: string) -> Option<string> {\n        EXT\n    }\n}\n\nimpl Value {\n    fn Addr(self) -> Value {\n        EXT\n    }\n\n    fn Bool(self) -> bool {\n        EXT\n    }\n\n    fn Bytes(self) -> [byte] {\n        EXT\n    }\n\n    fn Call(self, in_: [Value]) -> [Value] {\n        EXT\n    }\n\n    fn CallSlice(self, in_: [Value]) -> [Value] {\n        EXT\n    }\n\n    fn CanAddr(self) -> bool {\n        EXT\n    }\n\n    fn CanComplex(self) -> bool {\n        EXT\n    }\n\n    fn CanConvert(self, t: Type) -> bool {\n        EXT\n    }\n\n    fn CanFloat(self) -> bool {\n        EXT\n    }\n\n    fn CanInt(self) -> bool {\n        EXT\n    }\n\n    fn CanInterface(self) -> bool {\n        EXT\n    }\n\n    fn CanSet(self) -> bool {\n        EXT\n    }\n\n    fn CanUint(self) -> bool {\n        EXT\n    }\n\n    fn Cap(self) -> int {\n        EXT\n    }\n\n    fn Close(self) -> () {\n        EXT\n    }\n\n    fn Complex(self) -> complex128 {\n        EXT\n    }\n\n    fn Convert(self, t: Type) -> Value {\n        EXT\n    }\n\n    fn Elem(self) -> Value {\n        EXT\n    }\n\n    fn Field(self, i: int) -> Value {\n        EXT\n    }\n\n    fn FieldByIndex(self, index: [int]) -> Value {\n        EXT\n    }\n\n    fn FieldByIndexErr(self, index: [int]) -> Result<Value> {\n        EXT\n    }\n\n    fn FieldByName(self, name: string) -> Value {\n        EXT\n    }\n\n    fn FieldByNameFunc(self, match_: fn(param0: string) -> bool) -> Value {\n        EXT\n    }\n\n    fn Float(self) -> float64 {\n        EXT\n    }\n\n    fn Index(self, i: int) -> Value {\n        EXT\n    }\n\n    fn Int(self) -> int64 {\n        EXT\n    }\n\n    fn Interface(self) -> any {\n        EXT\n    }\n\n    fn InterfaceData(self) -> [uintptr] {\n        EXT\n    }\n\n    fn IsNil(self) -> bool {\n        EXT\n    }\n\n    fn IsValid(self) -> bool {\n        EXT\n    }\n\n    fn IsZero(self) -> bool {\n        EXT\n    }\n\n    fn Kind(self) -> Kind {\n        EXT\n    }\n\n    fn Len(self) -> int {\n        EXT\n    }\n\n    fn MapIndex(self, key: Value) -> Value {\n        EXT\n    }\n\n    fn MapKeys(self) -> [Value] {\n        EXT\n    }\n\n    fn MapRange(self) -> &MapIter {\n        EXT\n    }\n\n    fn Method(self, i: int) -> Value {\n        EXT\n    }\n\n    fn MethodByName(self, name: string) -> Value {\n        EXT\n    }\n\n    fn NumField(self) -> int {\n        EXT\n    }\n\n    fn NumMethod(self) -> int {\n        EXT\n    }\n\n    fn OverflowComplex(self, x: complex128) -> bool {\n        EXT\n    }\n\n    fn OverflowFloat(self, x: float64) -> bool {\n        EXT\n    }\n\n    fn OverflowInt(self, x: int64) -> bool {\n        EXT\n    }\n\n    fn OverflowUint(self, x: uint64) -> bool {\n        EXT\n    }\n\n    fn Pointer(self) -> uintptr {\n        EXT\n    }\n\n    fn Recv(self) -> Option<Value> {\n        EXT\n    }\n\n    fn Send(self, x: Value) -> () {\n        EXT\n    }\n\n    fn Set(self, x: Value) -> () {\n        EXT\n    }\n\n    fn SetBool(self, x: bool) -> () {\n        EXT\n    }\n\n    fn SetBytes(self, x: [byte]) -> () {\n        EXT\n    }\n\n    fn SetCap(self, n: int) -> () {\n        EXT\n    }\n\n    fn SetComplex(self, x: complex128) -> () {\n        EXT\n    }\n\n    fn SetFloat(self, x: float64) -> () {\n        EXT\n    }\n\n    fn SetInt(self, x: int64) -> () {\n        EXT\n    }\n\n    fn SetIterKey(self, iter: &MapIter) -> () {\n        EXT\n    }\n\n    fn SetIterValue(self, iter: &MapIter) -> () {\n        EXT\n    }\n\n    fn SetLen(self, n: int) -> () {\n        EXT\n    }\n\n    fn SetMapIndex(self, key: Value, elem: Value) -> () {\n        EXT\n    }\n\n    // fn SetPointer  (self, x: unsafe::Pointer) -> () { EXT }\n\n    fn SetString(self, x: string) -> () {\n        EXT\n    }\n\n    fn SetUint(self, x: uint64) -> () {\n        EXT\n    }\n\n    fn Slice(self, i: int, j: int) -> Value {\n        EXT\n    }\n\n    fn Slice3(self, i: int, j: int, k: int) -> Value {\n        EXT\n    }\n\n    fn String(self) -> string {\n        EXT\n    }\n\n    fn TryRecv(self) -> Option<Value> {\n        EXT\n    }\n\n    fn TrySend(self, x: Value) -> bool {\n        EXT\n    }\n\n    fn Type(self) -> Type {\n        EXT\n    }\n\n    fn Uint(self) -> uint64 {\n        EXT\n    }\n\n    fn UnsafeAddr(self) -> uintptr {\n        EXT\n    }\n\n    // fn UnsafePointer  (self, ) -> unsafe::Pointer { EXT }\n}\n\nimpl ValueError {\n    fn Error(&self) -> string {\n        EXT\n    }\n}\n\nstruct ChanDir(int);\n\nstruct Kind(uint);\n\nstruct SelectDir(int);\n\nstruct StructTag(string);\n\nstruct MapIter {}\n\nstruct Method {\n    Name: string,\n    PkgPath: string,\n    Type: Type,\n    Func: Value,\n    Index: int,\n}\n\nstruct SelectCase {\n    Dir: SelectDir,\n    Chan: Value,\n    Send: Value,\n}\n\nstruct SliceHeader {\n    Data: uintptr,\n    Len: int,\n    Cap: int,\n}\n\nstruct StringHeader {\n    Data: uintptr,\n    Len: int,\n}\n\nstruct StructField {\n    Name: string,\n    PkgPath: string,\n    Type: Type,\n    Tag: StructTag,\n    Offset: uintptr,\n    Index: [int],\n    Anonymous: bool,\n}\n\ntrait Type {\n    fn Align() -> int;\n    fn FieldAlign() -> int;\n    fn Method(param0: int) -> Method;\n    fn MethodByName(param0: string) -> Option<Method>;\n    fn NumMethod() -> int;\n    fn Name() -> string;\n    fn PkgPath() -> string;\n    fn Size() -> uintptr;\n    fn String() -> string;\n    fn Kind() -> Kind;\n    fn Implements(u: Type) -> bool;\n    fn AssignableTo(u: Type) -> bool;\n    fn ConvertibleTo(u: Type) -> bool;\n    fn Comparable() -> bool;\n    fn Bits() -> int;\n    fn ChanDir() -> ChanDir;\n    fn IsVariadic() -> bool;\n    fn Elem() -> Type;\n    fn Field(i: int) -> StructField;\n    fn FieldByIndex(index: [int]) -> StructField;\n    fn FieldByName(name: string) -> Option<StructField>;\n    fn FieldByNameFunc(match_: fn(param0: string) -> bool) -> Option<StructField>;\n    fn In(i: int) -> Type;\n    fn Key() -> Type;\n    fn Len() -> int;\n    fn NumField() -> int;\n    fn NumIn() -> int;\n    fn NumOut() -> int;\n    fn Out(i: int) -> Type;\n}\n\nstruct Value {}\n\nstruct ValueError {\n    Method: string,\n    Kind: Kind,\n}\n"},"io":{"io.brg":"fn NopCloser(r: Reader) -> ReadCloser {\n    EXT\n}\n\nfn LimitReader(r: Reader, n: int64) -> Reader {\n    EXT\n}\n\nfn MultiReader(readers: VarArgs<Reader>) -> Reader {\n    EXT\n}\n\nfn TeeReader(r: Reader, w: Writer) -> Reader {\n    EXT\n}\n\nfn NewSectionReader(r: ReaderAt, off: int64, n: int64) -> &SectionReader {\n    EXT\n}\n\nfn MultiWriter(writers: VarArgs<Writer>) -> Writer {\n    EXT\n}\n\nfn Copy(dst: Writer, src: Reader) -> Result<int64> {\n    EXT\n}\n\nfn CopyBuffer(dst: Writer, src: Reader, buf: [byte]) -> Result<int64> {\n    EXT\n}\n\nfn CopyN(dst: Writer, src: Reader, n: int64) -> Result<int64> {\n    EXT\n}\n\nfn Pipe() -> (&PipeReader, &PipeWriter) {\n    EXT\n}\n\nfn ReadAll(r: Reader) -> Result<[byte]> {\n    EXT\n}\n\nfn ReadAtLeast(r: Reader, buf: [byte], min: int) -> Result<int> {\n    EXT\n}\n\nfn ReadFull(r: Reader, buf: [byte]) -> Result<int> {\n    EXT\n}\n\nfn WriteString(w: Writer, s: string) -> Result<int> {\n    EXT\n}\n\nimpl PipeWriter {\n    fn Close(&self) -> error {\n        EXT\n    }\n\n    fn CloseWithError(&self, err: error) -> error {\n        EXT\n    }\n\n    fn Write(&self, data: [byte]) -> Result<int> {\n        EXT\n    }\n}\n\nimpl SectionReader {\n    fn Read(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn ReadAt(&self, p: [byte], off: int64) -> Result<int> {\n        EXT\n    }\n\n    fn Seek(&self, offset: int64, whence: int) -> Result<int64> {\n        EXT\n    }\n\n    fn Size(&self) -> int64 {\n        EXT\n    }\n}\n\nimpl LimitedReader {\n    fn Read(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n}\n\nimpl PipeReader {\n    fn Close(&self) -> error {\n        EXT\n    }\n\n    fn CloseWithError(&self, err: error) -> error {\n        EXT\n    }\n\n    fn Read(&self, data: [byte]) -> Result<int> {\n        EXT\n    }\n}\n\ntrait ByteReader {\n    fn ReadByte() -> Result<byte>;\n}\n\ntrait ByteScanner: ByteReader {\n    fn UnreadByte() -> error;\n}\n\ntrait ByteWriter {\n    fn WriteByte(c: byte) -> error;\n}\n\ntrait Closer {\n    fn Close() -> error;\n}\n\nstruct LimitedReader {\n    R: Reader,\n    N: int64,\n}\n\nstruct PipeReader {}\n\nstruct PipeWriter {}\n\ntrait ReadCloser: Reader + Closer {}\n\ntrait ReadSeekCloser: Reader + Seeker + Closer {}\n\ntrait ReadSeeker: Reader + Seeker {}\n\ntrait ReadWriteCloser: Reader + Writer + Closer {}\n\ntrait ReadWriteSeeker: Reader + Writer + Seeker {}\n\ntrait ReadWriter: Reader + Writer {}\n\ntrait Reader {\n    fn Read(p: [byte]) -> Result<int>;\n}\n\ntrait ReaderAt {\n    fn ReadAt(p: [byte], off: int64) -> Result<int>;\n}\n\ntrait ReaderFrom {\n    fn ReadFrom(r: Reader) -> Result<int64>;\n}\n\ntrait RuneReader {\n    fn ReadRune() -> (rune, int, error);\n}\n\ntrait RuneScanner: RuneReader {\n    fn UnreadRune() -> error;\n}\n\nstruct SectionReader {}\n\ntrait Seeker {\n    fn Seek(offset: int64, whence: int) -> Result<int64>;\n}\n\ntrait StringWriter {\n    fn WriteString(s: string) -> Result<int>;\n}\n\ntrait WriteCloser: Writer + Closer {}\n\ntrait WriteSeeker: Writer + Seeker {}\n\ntrait Writer {\n    fn Write(p: [byte]) -> Result<int>;\n}\n\ntrait WriterAt {\n    fn WriteAt(p: [byte], off: int64) -> Result<int>;\n}\n\ntrait WriterTo {\n    fn WriteTo(w: Writer) -> Result<int64>;\n}\n"},"io/fs":{"fs.brg":"use time;\n\nfn FileInfoToDirEntry(info: FileInfo) -> DirEntry {\n    EXT\n}\n\nfn ReadDir(fsys: FS, name: string) -> Result<[DirEntry]> {\n    EXT\n}\n\nfn Sub(fsys: FS, dir: string) -> Result<FS> {\n    EXT\n}\n\nfn Stat(fsys: FS, name: string) -> Result<FileInfo> {\n    EXT\n}\n\nfn Glob(fsys: FS, pattern: string) -> Result<[string]> {\n    EXT\n}\n\nfn ReadFile(fsys: FS, name: string) -> Result<[byte]> {\n    EXT\n}\n\nfn ValidPath(name: string) -> bool {\n    EXT\n}\n\nfn WalkDir(fsys: FS, root: string, fn_: WalkDirFunc) -> error {\n    EXT\n}\n\nimpl PathError {\n    fn Error(&self) -> string {\n        EXT\n    }\n\n    fn Timeout(&self) -> bool {\n        EXT\n    }\n\n    fn Unwrap(&self) -> error {\n        EXT\n    }\n}\n\nimpl FileMode {\n    fn IsDir(self) -> bool {\n        EXT\n    }\n\n    fn IsRegular(self) -> bool {\n        EXT\n    }\n\n    fn Perm(self) -> FileMode {\n        EXT\n    }\n\n    fn String(self) -> string {\n        EXT\n    }\n\n    fn Type(self) -> FileMode {\n        EXT\n    }\n}\n\ntype WalkDirFunc = fn(path: string, d: DirEntry, err: error) -> error;\n\nstruct FileMode(uint32);\n\ntrait DirEntry {\n    fn Name() -> string;\n    fn IsDir() -> bool;\n    fn Type() -> FileMode;\n    fn Info() -> Result<FileInfo>;\n}\n\ntrait FS {\n    fn Open(name: string) -> Result<File>;\n}\n\ntrait File {\n    fn Stat() -> Result<FileInfo>;\n    fn Read(param0: [byte]) -> Result<int>;\n    fn Close() -> error;\n}\n\ntrait FileInfo {\n    fn Name() -> string;\n    fn Size() -> int64;\n    fn Mode() -> FileMode;\n    fn ModTime() -> time::Time;\n    fn IsDir() -> bool;\n    fn Sys() -> any;\n}\n\ntrait GlobFS: FS {\n    fn Glob(pattern: string) -> Result<[string]>;\n}\n\nstruct PathError {\n    Op: string,\n    Path: string,\n    Err: error,\n}\n\ntrait ReadDirFS: FS {\n    fn ReadDir(name: string) -> Result<[DirEntry]>;\n}\n\ntrait ReadDirFile: File {\n    fn ReadDir(n: int) -> Result<[DirEntry]>;\n}\n\ntrait ReadFileFS: FS {\n    fn ReadFile(name: string) -> Result<[byte]>;\n}\n\ntrait StatFS: FS {\n    fn Stat(name: string) -> Result<FileInfo>;\n}\n\ntrait SubFS: FS {\n    fn Sub(dir: string) -> Result<FS>;\n}\n"},"math":{"consts.brg":"// These are imported manually...\n\nconst E: float64 = EXT;\nconst Pi: float64 = EXT;\nconst Phi: float64 = EXT;\nconst Sqrt2: float64 = EXT;\nconst SqrtE: float64 = EXT;\nconst SqrtPi: float64 = EXT;\nconst SqrtPhi: float64 = EXT;\nconst Ln2: float64 = EXT;\nconst Log2E: float64 = EXT;\nconst Ln10: float64 = EXT;\nconst Log10E: float64 = EXT;\n","math.brg":"fn Abs(x: float64) -> float64 {\n    EXT\n}\n\nfn Acos(x: float64) -> float64 {\n    EXT\n}\n\nfn Acosh(x: float64) -> float64 {\n    EXT\n}\n\nfn Asin(x: float64) -> float64 {\n    EXT\n}\n\nfn Asinh(x: float64) -> float64 {\n    EXT\n}\n\nfn Atan(x: float64) -> float64 {\n    EXT\n}\n\nfn Atan2(y: float64, x: float64) -> float64 {\n    EXT\n}\n\nfn Atanh(x: float64) -> float64 {\n    EXT\n}\n\nfn Cbrt(x: float64) -> float64 {\n    EXT\n}\n\nfn Ceil(x: float64) -> float64 {\n    EXT\n}\n\nfn Copysign(f: float64, sign: float64) -> float64 {\n    EXT\n}\n\nfn Cos(x: float64) -> float64 {\n    EXT\n}\n\nfn Cosh(x: float64) -> float64 {\n    EXT\n}\n\nfn Dim(x: float64, y: float64) -> float64 {\n    EXT\n}\n\nfn Erf(x: float64) -> float64 {\n    EXT\n}\n\nfn Erfc(x: float64) -> float64 {\n    EXT\n}\n\nfn Erfcinv(x: float64) -> float64 {\n    EXT\n}\n\nfn Erfinv(x: float64) -> float64 {\n    EXT\n}\n\nfn Exp(x: float64) -> float64 {\n    EXT\n}\n\nfn Exp2(x: float64) -> float64 {\n    EXT\n}\n\nfn Expm1(x: float64) -> float64 {\n    EXT\n}\n\nfn FMA(x: float64, y: float64, z: float64) -> float64 {\n    EXT\n}\n\nfn Float32bits(f: float32) -> uint32 {\n    EXT\n}\n\nfn Float32frombits(b: uint32) -> float32 {\n    EXT\n}\n\nfn Float64bits(f: float64) -> uint64 {\n    EXT\n}\n\nfn Float64frombits(b: uint64) -> float64 {\n    EXT\n}\n\nfn Floor(x: float64) -> float64 {\n    EXT\n}\n\nfn Frexp(f: float64) -> (float64, int) {\n    EXT\n}\n\nfn Gamma(x: float64) -> float64 {\n    EXT\n}\n\nfn Hypot(p: float64, q: float64) -> float64 {\n    EXT\n}\n\nfn Ilogb(x: float64) -> int {\n    EXT\n}\n\nfn Inf(sign: int) -> float64 {\n    EXT\n}\n\nfn IsInf(f: float64, sign: int) -> bool {\n    EXT\n}\n\nfn IsNaN(f: float64) -> bool {\n    EXT\n}\n\nfn J0(x: float64) -> float64 {\n    EXT\n}\n\nfn J1(x: float64) -> float64 {\n    EXT\n}\n\nfn Jn(n: int, x: float64) -> float64 {\n    EXT\n}\n\nfn Ldexp(frac: float64, exp: int) -> float64 {\n    EXT\n}\n\nfn Lgamma(x: float64) -> (float64, int) {\n    EXT\n}\n\nfn Log(x: float64) -> float64 {\n    EXT\n}\n\nfn Log10(x: float64) -> float64 {\n    EXT\n}\n\nfn Log1p(x: float64) -> float64 {\n    EXT\n}\n\nfn Log2(x: float64) -> float64 {\n    EXT\n}\n\nfn Logb(x: float64) -> float64 {\n    EXT\n}\n\nfn Max(x: float64, y: float64) -> float64 {\n    EXT\n}\n\nfn Min(x: float64, y: float64) -> float64 {\n    EXT\n}\n\nfn Mod(x: float64, y: float64) -> float64 {\n    EXT\n}\n\nfn Modf(f: float64) -> (float64, float64) {\n    EXT\n}\n\nfn NaN() -> float64 {\n    EXT\n}\n\nfn Nextafter(x: float64, y: float64) -> float64 {\n    EXT\n}\n\nfn Nextafter32(x: float32, y: float32) -> float32 {\n    EXT\n}\n\nfn Pow(x: float64, y: float64) -> float64 {\n    EXT\n}\n\nfn Pow10(n: int) -> float64 {\n    EXT\n}\n\nfn Remainder(x: float64, y: float64) -> float64 {\n    EXT\n}\n\nfn Round(x: float64) -> float64 {\n    EXT\n}\n\nfn RoundToEven(x: float64) -> float64 {\n    EXT\n}\n\nfn Signbit(x: float64) -> bool {\n    EXT\n}\n\nfn Sin(x: float64) -> float64 {\n    EXT\n}\n\nfn Sincos(x: float64) -> float64 {\n    EXT\n}\n\nfn Sinh(x: float64) -> float64 {\n    EXT\n}\n\nfn Sqrt(x: float64) -> float64 {\n    EXT\n}\n\nfn Tan(x: float64) -> float64 {\n    EXT\n}\n\nfn Tanh(x: float64) -> float64 {\n    EXT\n}\n\nfn Trunc(x: float64) -> float64 {\n    EXT\n}\n\nfn Y0(x: float64) -> float64 {\n    EXT\n}\n\nfn Y1(x: float64) -> float64 {\n    EXT\n}\n\nfn Yn(n: int, x: float64) -> float64 {\n    EXT\n}\n"},"math/rand":{"rand.brg":"fn New(src: Source) -> &Rand {\n    EXT\n}\n\nfn NewSource(seed: int64) -> Source {\n    EXT\n}\n\nfn NewZipf(r: &Rand, s: float64, v: float64, imax: uint64) -> &Zipf {\n    EXT\n}\n\nfn ExpFloat64() -> float64 {\n    EXT\n}\n\nfn Float32() -> float32 {\n    EXT\n}\n\nfn Float64() -> float64 {\n    EXT\n}\n\nfn Int() -> int {\n    EXT\n}\n\nfn Int31() -> int32 {\n    EXT\n}\n\nfn Int31n(n: int32) -> int32 {\n    EXT\n}\n\nfn Int63() -> int64 {\n    EXT\n}\n\nfn Int63n(n: int64) -> int64 {\n    EXT\n}\n\nfn Intn(n: int) -> int {\n    EXT\n}\n\nfn NormFloat64() -> float64 {\n    EXT\n}\n\nfn Perm(n: int) -> [int] {\n    EXT\n}\n\nfn Read(p: [byte]) -> Result<int> {\n    EXT\n}\n\nfn Seed(seed: int64) -> () {\n    EXT\n}\n\nfn Shuffle(n: int, swap: fn(i: int, j: int) -> ()) -> () {\n    EXT\n}\n\nfn Uint32() -> uint32 {\n    EXT\n}\n\nfn Uint64() -> uint64 {\n    EXT\n}\n\nimpl Rand {\n    fn ExpFloat64(&self) -> float64 {\n        EXT\n    }\n\n    fn Float32(&self) -> float32 {\n        EXT\n    }\n\n    fn Float64(&self) -> float64 {\n        EXT\n    }\n\n    fn Int(&self) -> int {\n        EXT\n    }\n\n    fn Int31(&self) -> int32 {\n        EXT\n    }\n\n    fn Int31n(&self, n: int32) -> int32 {\n        EXT\n    }\n\n    fn Int63(&self) -> int64 {\n        EXT\n    }\n\n    fn Int63n(&self, n: int64) -> int64 {\n        EXT\n    }\n\n    fn Intn(&self, n: int) -> int {\n        EXT\n    }\n\n    fn NormFloat64(&self) -> float64 {\n        EXT\n    }\n\n    fn Perm(&self, n: int) -> [int] {\n        EXT\n    }\n\n    fn Read(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn Seed(&self, seed: int64) -> () {\n        EXT\n    }\n\n    fn Shuffle(&self, n: int, swap: fn(i: int, j: int) -> ()) -> () {\n        EXT\n    }\n\n    fn Uint32(&self) -> uint32 {\n        EXT\n    }\n\n    fn Uint64(&self) -> uint64 {\n        EXT\n    }\n}\n\nimpl Zipf {\n    fn Uint64(&self) -> uint64 {\n        EXT\n    }\n}\n\nstruct Rand {}\n\ntrait Source {\n    fn Int63() -> int64;\n    fn Seed(seed: int64) -> ();\n}\n\ntrait Source64: Source {\n    fn Uint64() -> uint64;\n}\n\nstruct Zipf {}\n"},"time":{"time.brg":"fn ParseDuration(s: string) -> Result<Duration> {\n    EXT\n}\n\nfn Since(t: Time) -> Duration {\n    EXT\n}\n\nfn Until(t: Time) -> Duration {\n    EXT\n}\n\nfn FixedZone(name: string, offset: int) -> &Location {\n    EXT\n}\n\nfn LoadLocation(name: string) -> Result<&Location> {\n    EXT\n}\n\nfn LoadLocationFromTZData(name: string, data: [byte]) -> Result<&Location> {\n    EXT\n}\n\nfn NewTicker(d: Duration) -> &Ticker {\n    EXT\n}\n\nfn Date(\n    year: int,\n    month: Month,\n    day: int,\n    hour: int,\n    min: int,\n    sec: int,\n    nsec: int,\n    loc: &Location,\n) -> Time {\n    EXT\n}\n\nfn Now() -> Time {\n    EXT\n}\n\nfn Parse(layout: string, value: string) -> Result<Time> {\n    EXT\n}\n\nfn ParseInLocation(layout: string, value: string, loc: &Location) -> Result<Time> {\n    EXT\n}\n\nfn Unix(sec: int64, nsec: int64) -> Time {\n    EXT\n}\n\nfn UnixMicro(usec: int64) -> Time {\n    EXT\n}\n\nfn UnixMilli(msec: int64) -> Time {\n    EXT\n}\n\nfn AfterFunc(d: Duration, f: fn() -> ()) -> &Timer {\n    EXT\n}\n\nfn NewTimer(d: Duration) -> &Timer {\n    EXT\n}\n\nfn After(d: Duration) -> Receiver<Time> {\n    EXT\n}\n\nfn Sleep(d: Duration) -> () {\n    EXT\n}\n\nfn Tick(d: Duration) -> Receiver<Time> {\n    EXT\n}\n\nimpl Ticker {\n    fn Reset(&self, d: Duration) -> () {\n        EXT\n    }\n\n    fn Stop(&self) -> () {\n        EXT\n    }\n}\n\nimpl Time {\n    fn Add(self, d: Duration) -> Time {\n        EXT\n    }\n\n    fn AddDate(self, years: int, months: int, days: int) -> Time {\n        EXT\n    }\n\n    fn After(self, u: Time) -> bool {\n        EXT\n    }\n\n    fn AppendFormat(self, b: [byte], layout: string) -> [byte] {\n        EXT\n    }\n\n    fn Before(self, u: Time) -> bool {\n        EXT\n    }\n\n    fn Clock(self) -> int {\n        EXT\n    }\n\n    fn Date(self) -> (int, Month, int) {\n        EXT\n    }\n\n    fn Day(self) -> int {\n        EXT\n    }\n\n    fn Equal(self, u: Time) -> bool {\n        EXT\n    }\n\n    fn Format(self, layout: string) -> string {\n        EXT\n    }\n\n    fn GoString(self) -> string {\n        EXT\n    }\n\n    fn GobDecode(&self, data: [byte]) -> error {\n        EXT\n    }\n\n    fn GobEncode(self) -> Result<[byte]> {\n        EXT\n    }\n\n    fn Hour(self) -> int {\n        EXT\n    }\n\n    fn ISOWeek(self) -> int {\n        EXT\n    }\n\n    fn In(self, loc: &Location) -> Time {\n        EXT\n    }\n\n    fn IsDST(self) -> bool {\n        EXT\n    }\n\n    fn IsZero(self) -> bool {\n        EXT\n    }\n\n    fn Local(self) -> Time {\n        EXT\n    }\n\n    fn Location(self) -> &Location {\n        EXT\n    }\n\n    fn MarshalBinary(self) -> Result<[byte]> {\n        EXT\n    }\n\n    fn MarshalJSON(self) -> Result<[byte]> {\n        EXT\n    }\n\n    fn MarshalText(self) -> Result<[byte]> {\n        EXT\n    }\n\n    fn Minute(self) -> int {\n        EXT\n    }\n\n    fn Month(self) -> Month {\n        EXT\n    }\n\n    fn Nanosecond(self) -> int {\n        EXT\n    }\n\n    fn Round(self, d: Duration) -> Time {\n        EXT\n    }\n\n    fn Second(self) -> int {\n        EXT\n    }\n\n    fn String(self) -> string {\n        EXT\n    }\n\n    fn Sub(self, u: Time) -> Duration {\n        EXT\n    }\n\n    fn Truncate(self, d: Duration) -> Time {\n        EXT\n    }\n\n    fn UTC(self) -> Time {\n        EXT\n    }\n\n    fn Unix(self) -> int64 {\n        EXT\n    }\n\n    fn UnixMicro(self) -> int64 {\n        EXT\n    }\n\n    fn UnixMilli(self) -> int64 {\n        EXT\n    }\n\n    fn UnixNano(self) -> int64 {\n        EXT\n    }\n\n    fn UnmarshalBinary(&self, data: [byte]) -> error {\n        EXT\n    }\n\n    fn UnmarshalJSON(&self, data: [byte]) -> error {\n        EXT\n    }\n\n    fn UnmarshalText(&self, data: [byte]) -> error {\n        EXT\n    }\n\n    fn Weekday(self) -> Weekday {\n        EXT\n    }\n\n    fn Year(self) -> int {\n        EXT\n    }\n\n    fn YearDay(self) -> int {\n        EXT\n    }\n\n    fn Zone(self) -> (string, int) {\n        EXT\n    }\n\n    fn ZoneBounds(self) -> Time {\n        EXT\n    }\n}\n\nimpl Timer {\n    fn Reset(&self, d: Duration) -> bool {\n        EXT\n    }\n\n    fn Stop(&self) -> bool {\n        EXT\n    }\n}\n\nimpl Weekday {\n    fn String(self) -> string {\n        EXT\n    }\n}\n\nimpl Duration {\n    fn Abs(self) -> Duration {\n        EXT\n    }\n\n    fn Hours(self) -> float64 {\n        EXT\n    }\n\n    fn Microseconds(self) -> int64 {\n        EXT\n    }\n\n    fn Milliseconds(self) -> int64 {\n        EXT\n    }\n\n    fn Minutes(self) -> float64 {\n        EXT\n    }\n\n    fn Nanoseconds(self) -> int64 {\n        EXT\n    }\n\n    fn Round(self, m: Duration) -> Duration {\n        EXT\n    }\n\n    fn Seconds(self) -> float64 {\n        EXT\n    }\n\n    fn String(self) -> string {\n        EXT\n    }\n\n    fn Truncate(self, m: Duration) -> Duration {\n        EXT\n    }\n}\n\nimpl Location {\n    fn String(&self) -> string {\n        EXT\n    }\n}\n\nimpl Month {\n    fn String(self) -> string {\n        EXT\n    }\n}\n\nimpl ParseError {\n    fn Error(&self) -> string {\n        EXT\n    }\n}\n\nstruct Duration(int64);\n\nstruct Month(int);\n\nstruct Weekday(int);\n\nstruct Location {}\n\nstruct ParseError {\n    Layout: string,\n    Value: string,\n    LayoutElem: string,\n    ValueElem: string,\n    Message: string,\n}\n\nstruct Ticker {\n    C: Receiver<Time>,\n}\n\nstruct Time {}\n\nstruct Timer {\n    C: Receiver<Time>,\n}\n"},"log":{"log.brg":"use io;\n\nfn Default() -> &Logger {\n    EXT\n}\n\nfn New(out: io::Writer, prefix: string, flag: int) -> &Logger {\n    EXT\n}\n\nfn Fatal(v: VarArgs<any>) -> () {\n    EXT\n}\n\nfn Fatalf(format: string, v: VarArgs<any>) -> () {\n    EXT\n}\n\nfn Fatalln(v: VarArgs<any>) -> () {\n    EXT\n}\n\nfn Flags() -> int {\n    EXT\n}\n\nfn Output(calldepth: int, s: string) -> error {\n    EXT\n}\n\nfn Panic(v: VarArgs<any>) -> () {\n    EXT\n}\n\nfn Panicf(format: string, v: VarArgs<any>) -> () {\n    EXT\n}\n\nfn Panicln(v: VarArgs<any>) -> () {\n    EXT\n}\n\nfn Prefix() -> string {\n    EXT\n}\n\nfn Print(v: VarArgs<any>) -> () {\n    EXT\n}\n\nfn Printf(format: string, v: VarArgs<any>) -> () {\n    EXT\n}\n\nfn Println(v: VarArgs<any>) -> () {\n    EXT\n}\n\nfn SetFlags(flag: int) -> () {\n    EXT\n}\n\nfn SetOutput(w: io::Writer) -> () {\n    EXT\n}\n\nfn SetPrefix(prefix: string) -> () {\n    EXT\n}\n\nfn Writer() -> io::Writer {\n    EXT\n}\n\nimpl Logger {\n    fn Fatal(&self, v: VarArgs<any>) -> () {\n        EXT\n    }\n\n    fn Fatalf(&self, format: string, v: VarArgs<any>) -> () {\n        EXT\n    }\n\n    fn Fatalln(&self, v: VarArgs<any>) -> () {\n        EXT\n    }\n\n    fn Flags(&self) -> int {\n        EXT\n    }\n\n    fn Output(&self, calldepth: int, s: string) -> error {\n        EXT\n    }\n\n    fn Panic(&self, v: VarArgs<any>) -> () {\n        EXT\n    }\n\n    fn Panicf(&self, format: string, v: VarArgs<any>) -> () {\n        EXT\n    }\n\n    fn Panicln(&self, v: VarArgs<any>) -> () {\n        EXT\n    }\n\n    fn Prefix(&self) -> string {\n        EXT\n    }\n\n    fn Print(&self, v: VarArgs<any>) -> () {\n        EXT\n    }\n\n    fn Printf(&self, format: string, v: VarArgs<any>) -> () {\n        EXT\n    }\n\n    fn Println(&self, v: VarArgs<any>) -> () {\n        EXT\n    }\n\n    fn SetFlags(&self, flag: int) -> () {\n        EXT\n    }\n\n    fn SetOutput(&self, w: io::Writer) -> () {\n        EXT\n    }\n\n    fn SetPrefix(&self, prefix: string) -> () {\n        EXT\n    }\n\n    fn Writer(&self) -> io::Writer {\n        EXT\n    }\n}\n\nstruct Logger {}\n"},"os":{"os.brg":"use io;\nuse time;\n// use syscall; TODO too slow\nuse io::fs;\n\nfn ReadDir(name: string) -> Result<[DirEntry]> {\n    EXT\n}\n\nfn Create(name: string) -> Result<&File> {\n    EXT\n}\n\nfn CreateTemp(dir: string, pattern: string) -> Result<&File> {\n    EXT\n}\n\nfn NewFile(fd: uintptr, name: string) -> &File {\n    EXT\n}\n\nfn Open(name: string) -> Result<&File> {\n    EXT\n}\n\nfn OpenFile(name: string, flag: int, perm: FileMode) -> Result<&File> {\n    EXT\n}\n\nfn Lstat(name: string) -> Result<FileInfo> {\n    EXT\n}\n\nfn Stat(name: string) -> Result<FileInfo> {\n    EXT\n}\n\nfn FindProcess(pid: int) -> Result<&Process> {\n    EXT\n}\n\nfn StartProcess(name: string, argv: [string], attr: &ProcAttr) -> Result<&Process> {\n    EXT\n}\n\nfn Chdir(dir: string) -> error {\n    EXT\n}\n\nfn Chmod(name: string, mode: FileMode) -> error {\n    EXT\n}\n\nfn Chown(name: string, uid: int, gid: int) -> error {\n    EXT\n}\n\nfn Chtimes(name: string, atime: time::Time, mtime: time::Time) -> error {\n    EXT\n}\n\nfn Clearenv() -> () {\n    EXT\n}\n\nfn DirFS(dir: string) -> fs::FS {\n    EXT\n}\n\nfn Environ() -> [string] {\n    EXT\n}\n\nfn Executable() -> Result<string> {\n    EXT\n}\n\nfn Exit(code: int) -> () {\n    EXT\n}\n\nfn Expand(s: string, mapping: fn(param0: string) -> string) -> string {\n    EXT\n}\n\nfn ExpandEnv(s: string) -> string {\n    EXT\n}\n\nfn Getegid() -> int {\n    EXT\n}\n\nfn Getenv(key: string) -> string {\n    EXT\n}\n\nfn Geteuid() -> int {\n    EXT\n}\n\nfn Getgid() -> int {\n    EXT\n}\n\nfn Getgroups() -> Result<[int]> {\n    EXT\n}\n\nfn Getpagesize() -> int {\n    EXT\n}\n\nfn Getpid() -> int {\n    EXT\n}\n\nfn Getppid() -> int {\n    EXT\n}\n\nfn Getuid() -> int {\n    EXT\n}\n\nfn Getwd() -> Result<string> {\n    EXT\n}\n\nfn Hostname() -> Result<string> {\n    EXT\n}\n\nfn IsExist(err: error) -> bool {\n    EXT\n}\n\nfn IsNotExist(err: error) -> bool {\n    EXT\n}\n\nfn IsPathSeparator(c: uint8) -> bool {\n    EXT\n}\n\nfn IsPermission(err: error) -> bool {\n    EXT\n}\n\nfn IsTimeout(err: error) -> bool {\n    EXT\n}\n\nfn Lchown(name: string, uid: int, gid: int) -> error {\n    EXT\n}\n\nfn Link(oldname: string, newname: string) -> error {\n    EXT\n}\n\nfn LookupEnv(key: string) -> Option<string> {\n    EXT\n}\n\nfn Mkdir(name: string, perm: FileMode) -> error {\n    EXT\n}\n\nfn MkdirAll(path: string, perm: FileMode) -> error {\n    EXT\n}\n\nfn MkdirTemp(dir: string, pattern: string) -> Result<string> {\n    EXT\n}\n\nfn NewSyscallError(syscall: string, err: error) -> error {\n    EXT\n}\n\nfn Pipe() -> (&File, &File, error) {\n    EXT\n}\n\nfn ReadFile(name: string) -> Result<[byte]> {\n    EXT\n}\n\nfn Readlink(name: string) -> Result<string> {\n    EXT\n}\n\nfn Remove(name: string) -> error {\n    EXT\n}\n\nfn RemoveAll(path: string) -> error {\n    EXT\n}\n\nfn Rename(oldpath: string, newpath: string) -> error {\n    EXT\n}\n\nfn SameFile(fi1: FileInfo, fi2: FileInfo) -> bool {\n    EXT\n}\n\nfn Setenv(key: string, value: string) -> error {\n    EXT\n}\n\nfn Symlink(oldname: string, newname: string) -> error {\n    EXT\n}\n\nfn TempDir() -> string {\n    EXT\n}\n\nfn Truncate(name: string, size: int64) -> error {\n    EXT\n}\n\nfn Unsetenv(key: string) -> error {\n    EXT\n}\n\nfn UserCacheDir() -> Result<string> {\n    EXT\n}\n\nfn UserConfigDir() -> Result<string> {\n    EXT\n}\n\nfn UserHomeDir() -> Result<string> {\n    EXT\n}\n\nfn WriteFile(name: string, data: [byte], perm: FileMode) -> error {\n    EXT\n}\n\nimpl Process {\n    fn Kill(&self) -> error {\n        EXT\n    }\n\n    fn Release(&self) -> error {\n        EXT\n    }\n\n    fn Signal(&self, sig: Signal) -> error {\n        EXT\n    }\n\n    fn Wait(&self) -> Result<&ProcessState> {\n        EXT\n    }\n}\n\nimpl ProcessState {\n    fn ExitCode(&self) -> int {\n        EXT\n    }\n\n    fn Exited(&self) -> bool {\n        EXT\n    }\n\n    fn Pid(&self) -> int {\n        EXT\n    }\n\n    fn String(&self) -> string {\n        EXT\n    }\n\n    fn Success(&self) -> bool {\n        EXT\n    }\n\n    fn Sys(&self) -> any {\n        EXT\n    }\n\n    fn SysUsage(&self) -> any {\n        EXT\n    }\n\n    fn SystemTime(&self) -> time::Duration {\n        EXT\n    }\n\n    fn UserTime(&self) -> time::Duration {\n        EXT\n    }\n}\n\nimpl SyscallError {\n    fn Error(&self) -> string {\n        EXT\n    }\n\n    fn Timeout(&self) -> bool {\n        EXT\n    }\n\n    fn Unwrap(&self) -> error {\n        EXT\n    }\n}\n\nimpl File {\n    fn Chdir(&self) -> error {\n        EXT\n    }\n\n    fn Chmod(&self, mode: FileMode) -> error {\n        EXT\n    }\n\n    fn Chown(&self, uid: int, gid: int) -> error {\n        EXT\n    }\n\n    fn Close(&self) -> error {\n        EXT\n    }\n\n    fn Fd(&self) -> uintptr {\n        EXT\n    }\n\n    fn Name(&self) -> string {\n        EXT\n    }\n\n    fn Read(&self, b: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn ReadAt(&self, b: [byte], off: int64) -> Result<int> {\n        EXT\n    }\n\n    fn ReadDir(&self, n: int) -> Result<[DirEntry]> {\n        EXT\n    }\n\n    fn ReadFrom(&self, r: io::Reader) -> Result<int64> {\n        EXT\n    }\n\n    fn Readdir(&self, n: int) -> Result<[FileInfo]> {\n        EXT\n    }\n\n    fn Readdirnames(&self, n: int) -> Result<[string]> {\n        EXT\n    }\n\n    fn Seek(&self, offset: int64, whence: int) -> Result<int64> {\n        EXT\n    }\n\n    fn SetDeadline(&self, t: time::Time) -> error {\n        EXT\n    }\n\n    fn SetReadDeadline(&self, t: time::Time) -> error {\n        EXT\n    }\n\n    fn SetWriteDeadline(&self, t: time::Time) -> error {\n        EXT\n    }\n\n    fn Stat(&self) -> Result<FileInfo> {\n        EXT\n    }\n\n    fn Sync(&self) -> error {\n        EXT\n    }\n\n    // fn SyscallConn  (&self, ) -> Result<syscall::RawConn> { EXT }\n\n    fn Truncate(&self, size: int64) -> error {\n        EXT\n    }\n\n    fn Write(&self, b: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn WriteAt(&self, b: [byte], off: int64) -> Result<int> {\n        EXT\n    }\n\n    fn WriteString(&self, s: string) -> Result<int> {\n        EXT\n    }\n}\n\nimpl LinkError {\n    fn Error(&self) -> string {\n        EXT\n    }\n\n    fn Unwrap(&self) -> error {\n        EXT\n    }\n}\n\ntype DirEntry = fs::DirEntry;\n\ntype FileInfo = fs::FileInfo;\n\ntype FileMode = fs::FileMode;\n\ntype PathError = fs::PathError;\n\nstruct File {}\n\nstruct LinkError {\n    Op: string,\n    Old: string,\n    New: string,\n    Err: error,\n}\n\nstruct ProcAttr {\n    Dir: string,\n    Env: [string],\n    Files: [&File],\n    // Sys: &syscall::SysProcAttr\n}\n\nstruct Process {\n    Pid: int,\n}\n\nstruct ProcessState {}\n\ntrait Signal {\n    fn String() -> string;\n    fn Signal() -> ();\n}\n\nstruct SyscallError {\n    Syscall: string,\n    Err: error,\n}\n"},"errors":{"errors.brg":"fn As(err: error, target: any) -> bool {\n    EXT\n}\n\nfn Is(err: error, target: error) -> bool {\n    EXT\n}\n\nfn New(text: string) -> error {\n    EXT\n}\n\nfn Unwrap(err: error) -> error {\n    EXT\n}\n"},"sync":{"sync.brg":"fn NewCond(l: Locker) -> &Cond {\n    EXT\n}\n\nimpl Pool {\n    fn Get(&self) -> any {\n        EXT\n    }\n\n    fn Put(&self, x: any) -> () {\n        EXT\n    }\n}\n\nimpl RWMutex {\n    fn Lock(&self) -> () {\n        EXT\n    }\n\n    fn RLock(&self) -> () {\n        EXT\n    }\n\n    fn RLocker(&self) -> Locker {\n        EXT\n    }\n\n    fn RUnlock(&self) -> () {\n        EXT\n    }\n\n    fn TryLock(&self) -> bool {\n        EXT\n    }\n\n    fn TryRLock(&self) -> bool {\n        EXT\n    }\n\n    fn Unlock(&self) -> () {\n        EXT\n    }\n}\n\nimpl WaitGroup {\n    fn Add(&self, delta: int) -> () {\n        EXT\n    }\n\n    fn Done(&self) -> () {\n        EXT\n    }\n\n    fn Wait(&self) -> () {\n        EXT\n    }\n}\n\nimpl Cond {\n    fn Broadcast(&self) -> () {\n        EXT\n    }\n\n    fn Signal(&self) -> () {\n        EXT\n    }\n\n    fn Wait(&self) -> () {\n        EXT\n    }\n}\n\nimpl Map {\n    fn Delete(&self, key: any) -> () {\n        EXT\n    }\n\n    fn Load(&self, key: any) -> Option<any> {\n        EXT\n    }\n\n    fn LoadAndDelete(&self, key: any) -> Option<any> {\n        EXT\n    }\n\n    fn LoadOrStore(&self, key: any, value: any) -> Option<any> {\n        EXT\n    }\n\n    fn Range(&self, f: fn(key: any, value: any) -> bool) -> () {\n        EXT\n    }\n\n    fn Store(&self, key: any, value: any) -> () {\n        EXT\n    }\n}\n\nimpl Mutex {\n    fn Lock(&self) -> () {\n        EXT\n    }\n\n    fn TryLock(&self) -> bool {\n        EXT\n    }\n\n    fn Unlock(&self) -> () {\n        EXT\n    }\n}\n\nimpl Once {\n    fn Do(&self, f: fn() -> ()) -> () {\n        EXT\n    }\n}\n\nstruct Cond {\n    L: Locker,\n}\n\ntrait Locker {\n    fn Lock() -> ();\n    fn Unlock() -> ();\n}\n\nstruct Map {}\n\nstruct Mutex {}\n\nstruct Once {}\n\nstruct Pool {\n    New: fn() -> any,\n}\n\nstruct RWMutex {}\n\nstruct WaitGroup {}\n"}}