{"bufio":{"bufio.brg":"use io;\n\n\nfn NewReadWriter  (r: &Reader, w: &Writer) -> &ReadWriter { EXT }\n\nfn NewReader  (rd: io::Reader) -> &Reader { EXT }\n\nfn NewReaderSize  (rd: io::Reader, size: int) -> &Reader { EXT }\n\nfn NewScanner  (r: io::Reader) -> &Scanner { EXT }\n\nfn NewWriter  (w: io::Writer) -> &Writer { EXT }\n\nfn NewWriterSize  (w: io::Writer, size: int) -> &Writer { EXT }\n\nfn ScanBytes  (data: [byte], atEOF: bool) -> (int, [byte], error) { EXT }\n\nfn ScanLines  (data: [byte], atEOF: bool) -> (int, [byte], error) { EXT }\n\nfn ScanRunes  (data: [byte], atEOF: bool) -> (int, [byte], error) { EXT }\n\nfn ScanWords  (data: [byte], atEOF: bool) -> (int, [byte], error) { EXT }\n\nimpl Scanner {\n\nfn Buffer  (&self, buf: [byte], max: int) -> () { EXT }\n\nfn Bytes  (&self, ) -> [byte] { EXT }\n\nfn Err  (&self, ) -> error { EXT }\n\nfn Scan  (&self, ) -> bool { EXT }\n\nfn Split  (&self, split: SplitFunc) -> () { EXT }\n\nfn Text  (&self, ) -> string { EXT }\n\n}\n\nimpl Writer {\n\nfn Available  (&self, ) -> int { EXT }\n\nfn AvailableBuffer  (&self, ) -> [byte] { EXT }\n\nfn Buffered  (&self, ) -> int { EXT }\n\nfn Flush  (&self, ) -> error { EXT }\n\nfn ReadFrom  (&self, r: io::Reader) -> Result<int64> { EXT }\n\nfn Reset  (&self, w: io::Writer) -> () { EXT }\n\nfn Size  (&self, ) -> int { EXT }\n\nfn Write  (&self, p: [byte]) -> Result<int> { EXT }\n\nfn WriteByte  (&self, c: byte) -> error { EXT }\n\nfn WriteRune  (&self, r: rune) -> Result<int> { EXT }\n\nfn WriteString  (&self, s: string) -> Result<int> { EXT }\n\n}\n\nimpl Reader {\n\nfn Buffered  (&self, ) -> int { EXT }\n\nfn Discard  (&self, n: int) -> Result<int> { EXT }\n\nfn Peek  (&self, n: int) -> Result<[byte]> { EXT }\n\nfn Read  (&self, p: [byte]) -> Result<int> { EXT }\n\nfn ReadByte  (&self, ) -> Result<byte> { EXT }\n\nfn ReadBytes  (&self, delim: byte) -> Result<[byte]> { EXT }\n\nfn ReadLine  (&self, ) -> ([byte], bool, error) { EXT }\n\nfn ReadRune  (&self, ) -> (rune, int, error) { EXT }\n\nfn ReadSlice  (&self, delim: byte) -> Result<[byte]> { EXT }\n\nfn ReadString  (&self, delim: byte) -> Result<string> { EXT }\n\nfn Reset  (&self, r: io::Reader) -> () { EXT }\n\nfn Size  (&self, ) -> int { EXT }\n\nfn UnreadByte  (&self, ) -> error { EXT }\n\nfn UnreadRune  (&self, ) -> error { EXT }\n\nfn WriteTo  (&self, w: io::Writer) -> Result<int64> { EXT }\n\n}\n\ntype SplitFunc = fn (data: [byte], atEOF: bool) -> (int, [byte], error);\n\nstruct ReadWriter{\n// : &Reader,\n// : &Writer\n}\n\nstruct Reader{\n\n}\n\nstruct Scanner{\n\n}\n\nstruct Writer{\n\n}\n\n\n"},"strconv":{"strconv.brg":"\n\nfn AppendBool  (dst: [byte], b: bool) -> [byte] { EXT }\n\nfn AppendFloat  (dst: [byte], f: float64, fmt: byte, prec: int) -> [byte] { EXT }\n\nfn AppendInt  (dst: [byte], i: int64, base: int) -> [byte] { EXT }\n\nfn AppendQuote  (dst: [byte], s: string) -> [byte] { EXT }\n\nfn AppendQuoteRune  (dst: [byte], r: rune) -> [byte] { EXT }\n\nfn AppendQuoteRuneToASCII  (dst: [byte], r: rune) -> [byte] { EXT }\n\nfn AppendQuoteRuneToGraphic  (dst: [byte], r: rune) -> [byte] { EXT }\n\nfn AppendQuoteToASCII  (dst: [byte], s: string) -> [byte] { EXT }\n\nfn AppendQuoteToGraphic  (dst: [byte], s: string) -> [byte] { EXT }\n\nfn AppendUint  (dst: [byte], i: uint64, base: int) -> [byte] { EXT }\n\nfn Atoi  (s: string) -> Result<int> { EXT }\n\nfn CanBackquote  (s: string) -> bool { EXT }\n\nfn FormatBool  (b: bool) -> string { EXT }\n\nfn FormatComplex  (c: complex128, fmt: byte, prec: int) -> string { EXT }\n\nfn FormatFloat  (f: float64, fmt: byte, prec: int) -> string { EXT }\n\nfn FormatInt  (i: int64, base: int) -> string { EXT }\n\nfn FormatUint  (i: uint64, base: int) -> string { EXT }\n\nfn IsGraphic  (r: rune) -> bool { EXT }\n\nfn IsPrint  (r: rune) -> bool { EXT }\n\nfn Itoa  (i: int) -> string { EXT }\n\nfn ParseBool  (str: string) -> Result<bool> { EXT }\n\nfn ParseComplex  (s: string, bitSize: int) -> Result<complex128> { EXT }\n\nfn ParseFloat  (s: string, bitSize: int) -> Result<float64> { EXT }\n\nfn ParseInt  (s: string, base: int, bitSize: int) -> Result<int64> { EXT }\n\nfn ParseUint  (s: string, base: int, bitSize: int) -> Result<uint64> { EXT }\n\nfn Quote  (s: string) -> string { EXT }\n\nfn QuoteRune  (r: rune) -> string { EXT }\n\nfn QuoteRuneToASCII  (r: rune) -> string { EXT }\n\nfn QuoteRuneToGraphic  (r: rune) -> string { EXT }\n\nfn QuoteToASCII  (s: string) -> string { EXT }\n\nfn QuoteToGraphic  (s: string) -> string { EXT }\n\nfn QuotedPrefix  (s: string) -> Result<string> { EXT }\n\nfn Unquote  (s: string) -> Result<string> { EXT }\n\nfn UnquoteChar  (s: string, quote: byte) -> (rune, bool, string, error) { EXT }\n\nimpl NumError {\n\nfn Error  (&self, ) -> string { EXT }\n\nfn Unwrap  (&self, ) -> error { EXT }\n\n}\n\nstruct NumError{\nFunc: string,\nNum: string,\nErr: error\n}\n\n\n"},"strings":{"strings.brg":"use io;\nuse unicode;\n\n\nfn NewReader  (s: string) -> &Reader { EXT }\n\nfn NewReplacer  (oldnew: VarArgs<string>) -> &Replacer { EXT }\n\nfn Clone  (s: string) -> string { EXT }\n\nfn Compare  (a: string, b: string) -> int { EXT }\n\nfn Contains  (s: string, substr: string) -> bool { EXT }\n\nfn ContainsAny  (s: string, chars: string) -> bool { EXT }\n\nfn ContainsRune  (s: string, r: rune) -> bool { EXT }\n\nfn Count  (s: string, substr: string) -> int { EXT }\n\nfn Cut  (s: string, sep: string) -> (string, bool) { EXT }\n\nfn EqualFold  (s: string, t: string) -> bool { EXT }\n\nfn Fields  (s: string) -> [string] { EXT }\n\nfn FieldsFunc  (s: string, f: fn (param0: rune) -> bool) -> [string] { EXT }\n\nfn HasPrefix  (s: string, prefix: string) -> bool { EXT }\n\nfn HasSuffix  (s: string, suffix: string) -> bool { EXT }\n\nfn Index  (s: string, substr: string) -> int { EXT }\n\nfn IndexAny  (s: string, chars: string) -> int { EXT }\n\nfn IndexByte  (s: string, c: byte) -> int { EXT }\n\nfn IndexFunc  (s: string, f: fn (param0: rune) -> bool) -> int { EXT }\n\nfn IndexRune  (s: string, r: rune) -> int { EXT }\n\nfn Join  (elems: [string], sep: string) -> string { EXT }\n\nfn LastIndex  (s: string, substr: string) -> int { EXT }\n\nfn LastIndexAny  (s: string, chars: string) -> int { EXT }\n\nfn LastIndexByte  (s: string, c: byte) -> int { EXT }\n\nfn LastIndexFunc  (s: string, f: fn (param0: rune) -> bool) -> int { EXT }\n\nfn Map  (mapping: fn (param0: rune) -> rune, s: string) -> string { EXT }\n\nfn Repeat  (s: string, count: int) -> string { EXT }\n\nfn Replace  (s: string, old: string, new: string, n: int) -> string { EXT }\n\nfn ReplaceAll  (s: string, old: string, new: string) -> string { EXT }\n\nfn Split  (s: string, sep: string) -> [string] { EXT }\n\nfn SplitAfter  (s: string, sep: string) -> [string] { EXT }\n\nfn SplitAfterN  (s: string, sep: string, n: int) -> [string] { EXT }\n\nfn SplitN  (s: string, sep: string, n: int) -> [string] { EXT }\n\nfn Title  (s: string) -> string { EXT }\n\nfn ToLower  (s: string) -> string { EXT }\n\nfn ToLowerSpecial  (c: unicode::SpecialCase, s: string) -> string { EXT }\n\nfn ToTitle  (s: string) -> string { EXT }\n\nfn ToTitleSpecial  (c: unicode::SpecialCase, s: string) -> string { EXT }\n\nfn ToUpper  (s: string) -> string { EXT }\n\nfn ToUpperSpecial  (c: unicode::SpecialCase, s: string) -> string { EXT }\n\nfn ToValidUTF8  (s: string, replacement: string) -> string { EXT }\n\nfn Trim  (s: string, cutset: string) -> string { EXT }\n\nfn TrimFunc  (s: string, f: fn (param0: rune) -> bool) -> string { EXT }\n\nfn TrimLeft  (s: string, cutset: string) -> string { EXT }\n\nfn TrimLeftFunc  (s: string, f: fn (param0: rune) -> bool) -> string { EXT }\n\nfn TrimPrefix  (s: string, prefix: string) -> string { EXT }\n\nfn TrimRight  (s: string, cutset: string) -> string { EXT }\n\nfn TrimRightFunc  (s: string, f: fn (param0: rune) -> bool) -> string { EXT }\n\nfn TrimSpace  (s: string) -> string { EXT }\n\nfn TrimSuffix  (s: string, suffix: string) -> string { EXT }\n\nimpl Replacer {\n\nfn Replace  (&self, s: string) -> string { EXT }\n\nfn WriteString  (&self, w: io::Writer, s: string) -> Result<int> { EXT }\n\n}\n\nimpl Builder {\n\nfn Cap  (&self, ) -> int { EXT }\n\nfn Grow  (&self, n: int) -> () { EXT }\n\nfn Len  (&self, ) -> int { EXT }\n\nfn Reset  (&self, ) -> () { EXT }\n\nfn String  (&self, ) -> string { EXT }\n\nfn Write  (&self, p: [byte]) -> Result<int> { EXT }\n\nfn WriteByte  (&self, c: byte) -> error { EXT }\n\nfn WriteRune  (&self, r: rune) -> Result<int> { EXT }\n\nfn WriteString  (&self, s: string) -> Result<int> { EXT }\n\n}\n\nimpl Reader {\n\nfn Len  (&self, ) -> int { EXT }\n\nfn Read  (&self, b: [byte]) -> Result<int> { EXT }\n\nfn ReadAt  (&self, b: [byte], off: int64) -> Result<int> { EXT }\n\nfn ReadByte  (&self, ) -> Result<byte> { EXT }\n\nfn ReadRune  (&self, ) -> (rune, int, error) { EXT }\n\nfn Reset  (&self, s: string) -> () { EXT }\n\nfn Seek  (&self, offset: int64, whence: int) -> Result<int64> { EXT }\n\nfn Size  (&self, ) -> int64 { EXT }\n\nfn UnreadByte  (&self, ) -> error { EXT }\n\nfn UnreadRune  (&self, ) -> error { EXT }\n\nfn WriteTo  (&self, w: io::Writer) -> Result<int64> { EXT }\n\n}\n\nstruct Builder{\n\n}\n\nstruct Reader{\n\n}\n\nstruct Replacer{\n\n}\n\n\n"},"net/http":{"http.brg":"\n    struct Request {}\n\n    trait ResponseWriter {\n        fn Write(bytes: [byte]) -> Result<int>;\n    }\n\n    trait Handler {\n        fn ServeHTTP(w: ResponseWriter, r: &Request);\n    }\n\n    fn Handle(pattern: string, handler: Handler) {\n        EXT\n    }\n    fn ListenAndServe(addr: string, handler: Handler) {\n        EXT\n    }\n"},"regexp":{"regexp.brg":"use io;\n\n\nfn Compile  (expr: string) -> Result<&Regexp> { EXT }\n\nfn CompilePOSIX  (expr: string) -> Result<&Regexp> { EXT }\n\nfn MustCompile  (str: string) -> &Regexp { EXT }\n\nfn MustCompilePOSIX  (str: string) -> &Regexp { EXT }\n\nfn Match  (pattern: string, b: [byte]) -> Result<bool> { EXT }\n\nfn MatchReader  (pattern: string, r: io::RuneReader) -> Result<bool> { EXT }\n\nfn MatchString  (pattern: string, s: string) -> Result<bool> { EXT }\n\nfn QuoteMeta  (s: string) -> string { EXT }\n\nimpl Regexp {\n\nfn Copy  (&self, ) -> &Regexp { EXT }\n\nfn Expand  (&self, dst: [byte], template: [byte], src: [byte], match_: [int]) -> [byte] { EXT }\n\nfn ExpandString  (&self, dst: [byte], template: string, src: string, match_: [int]) -> [byte] { EXT }\n\nfn Find  (&self, b: [byte]) -> [byte] { EXT }\n\nfn FindAll  (&self, b: [byte], n: int) -> [[byte]] { EXT }\n\nfn FindAllIndex  (&self, b: [byte], n: int) -> [[int]] { EXT }\n\nfn FindAllString  (&self, s: string, n: int) -> [string] { EXT }\n\nfn FindAllStringIndex  (&self, s: string, n: int) -> [[int]] { EXT }\n\nfn FindAllStringSubmatch  (&self, s: string, n: int) -> [[string]] { EXT }\n\nfn FindAllStringSubmatchIndex  (&self, s: string, n: int) -> [[int]] { EXT }\n\nfn FindAllSubmatch  (&self, b: [byte], n: int) -> [[[byte]]] { EXT }\n\nfn FindAllSubmatchIndex  (&self, b: [byte], n: int) -> [[int]] { EXT }\n\nfn FindIndex  (&self, b: [byte]) -> [int] { EXT }\n\nfn FindReaderIndex  (&self, r: io::RuneReader) -> [int] { EXT }\n\nfn FindReaderSubmatchIndex  (&self, r: io::RuneReader) -> [int] { EXT }\n\nfn FindString  (&self, s: string) -> string { EXT }\n\nfn FindStringIndex  (&self, s: string) -> [int] { EXT }\n\nfn FindStringSubmatch  (&self, s: string) -> [string] { EXT }\n\nfn FindStringSubmatchIndex  (&self, s: string) -> [int] { EXT }\n\nfn FindSubmatch  (&self, b: [byte]) -> [[byte]] { EXT }\n\nfn FindSubmatchIndex  (&self, b: [byte]) -> [int] { EXT }\n\nfn LiteralPrefix  (&self, ) -> (string, bool) { EXT }\n\nfn Longest  (&self, ) -> () { EXT }\n\nfn Match  (&self, b: [byte]) -> bool { EXT }\n\nfn MatchReader  (&self, r: io::RuneReader) -> bool { EXT }\n\nfn MatchString  (&self, s: string) -> bool { EXT }\n\nfn NumSubexp  (&self, ) -> int { EXT }\n\nfn ReplaceAll  (&self, src: [byte], repl: [byte]) -> [byte] { EXT }\n\nfn ReplaceAllFunc  (&self, src: [byte], repl: fn (param0: [byte]) -> [byte]) -> [byte] { EXT }\n\nfn ReplaceAllLiteral  (&self, src: [byte], repl: [byte]) -> [byte] { EXT }\n\nfn ReplaceAllLiteralString  (&self, src: string, repl: string) -> string { EXT }\n\nfn ReplaceAllString  (&self, src: string, repl: string) -> string { EXT }\n\nfn ReplaceAllStringFunc  (&self, src: string, repl: fn (param0: string) -> string) -> string { EXT }\n\nfn Split  (&self, s: string, n: int) -> [string] { EXT }\n\nfn String  (&self, ) -> string { EXT }\n\nfn SubexpIndex  (&self, name: string) -> int { EXT }\n\nfn SubexpNames  (&self, ) -> [string] { EXT }\n\n}\n\nstruct Regexp{\n\n}\n\n\n"},"core":{"core.brg":"\n// TODO asdf move this to builtin.brg\n    trait ComplexType {}\n    trait FloatType {}\n    trait IntegerType {}\n    trait any {}\n    type bool = EXT;\n    type byte = EXT;\n    trait comparable {}\n    type complex128 = EXT;\n    type complex64 = EXT;\n    trait error {\n        fn Error() -> string;\n    }\n    type float32 = EXT;\n    type float64 = EXT;\n    type int = EXT;\n    type int16 = EXT;\n    type int32 = EXT;\n    type int64 = EXT;\n    type int8 = EXT;\n    type rune = EXT;\n    type string = EXT;\n    type uint = EXT;\n    type uint16 = EXT;\n    type uint32 = EXT;\n    type uint64 = EXT;\n    type uint8 = EXT;\n    type uintptr = EXT;\n\n    fn string(a: any) -> string {\n        EXT\n    }\n\n\n    /// ---------------------------------------------------------------\n\ntype Map<K, V> = EXT;\n\ntype EnumerateSlice<T> = EXT;\n\ntype VarArgs<T> = EXT;\n\ntype Channel<T> = EXT;\ntype Sender<T> = EXT;\ntype Receiver<T> = EXT;\n\ntype Unit = EXT;\ntype Slice<T> = EXT;\ntype never = EXT;\ntype Ref<T> = EXT;\ntype RefMut<T> = EXT;\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nimpl<T, E> Result<T, E> {\n    fn IsOk(self) -> bool {\n        match self {\n            Ok(_) => true,\n            Err(_) => false,\n        }\n    }\n\n    fn unwrap(self) -> T {\n        rawgo!(\n            \"\n      if self.tag == Result_Err {\n        inspect(self.Err)\n        panic(\\\"Unwrapped Err value\\\")\n      }\n\n      return self.Ok\n    \"\n        )\n    }\n}\n\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nimpl<T> Option<T> {\n    fn IsSome(self) -> bool {\n        match self {\n            Some(_) => true,\n            None => false,\n        }\n    }\n\n    fn IsNone(self) -> bool {\n        !self.IsSome()\n    }\n\n    fn unwrap_or(self, def: T) -> T {\n        match self {\n            Some(x) => x,\n            None => def,\n        }\n    }\n\n    fn unwrap_or_else(self, f: fn() -> T) -> T {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n\n    fn unwrap(self) -> T {\n        rawgo!(\n            \"\n        if self.tag == Option_None {\n          panic(\\\"Unwrapped None value\\\")\n        }\n\n        return self.Some\n      \"\n        )\n    }\n\n    fn ToOption(value: T, check: bool) -> Option<T> {\n        if check {\n            Some(value)\n        } else {\n            None\n        }\n    }\n}\n\nstruct Tuple2<T, Y> {\n    first: T,\n    second: Y,\n}\n\nstruct Tuple3<T, Y, Z> {\n    first: T,\n    second: Y,\n    third: Z,\n}\n\nstruct Tuple4<T, X, Y, Z> {\n    first: T,\n    second: X,\n    third: Y,\n    fourth: Z,\n}\n\nfn zero_value<T>() -> T {\n    rawgo!(\n        \"\n    var m T\n    return m\n  \"\n    )\n}\n\nfn assert_eq<T>(a: T, b: T) {\n  rawgo!(\"\n    if !reflect.DeepEqual(a, b) {\n        inspect(a);\n        inspect(b);\n        panic(\\\"something wrong\\\")\n    }\n    \")\n}\n\nfn inspect<T>(a: T) -> T {\n  rawgo!(\"\n    fmt.Printf(\\\"%+v\\\\n\\\", a);\n    return a\n  \")\n}\n\nfn Debug_unreachable<T>() -> T {\n    rawgo!(\"panic(\\\"unreachable code\\\")\")\n}\n\nfn to_result(e: error) -> Result<()> {\n    rawgo!(\n        \"if e != nil {\n    return struct{}{}, e\n  }\n  return struct{}{}, nil\n  \"\n    )\n}\n\nimpl<T> [T] {\n    fn len(self) -> int {\n        rawgo!(\"return len(self)\")\n    }\n\n    fn enumerate(self) -> EnumerateSlice<T> {\n        rawgo!(\"return self\")\n    }\n\n    fn set(&mut self, index: int, item: T) {\n        rawgo!(\"self[index] = item\")\n    }\n\n    fn append(&mut self, item: T) -> [T] {\n        rawgo!(\"return append(self, item)\")\n    }\n\n    fn get(self, i: int) -> Option<T> {\n        rawgo!(\n            \"\n            if i < 0 || i >= len(self) {\n              return *new(T), false\n            }\n\n      return self[i], true\n    \"\n        )\n    }\n}\n\nimpl<K: comparable, V> Map<K, V> {\n    fn new() -> Map<K, V> {\n        rawgo!(\"return map[K]V{}\")\n    }\n\n    fn len(self) -> int {\n        rawgo!(\"return len(self)\")\n    }\n\n    fn insert(self, k: K, v: V) {\n        rawgo!(\"self[k] = v\")\n    }\n\n    fn get(self, k: K) -> Option<V> {\n        rawgo!(\n            \"\n        v, ok := self[k]\n        return v, ok\n        \"\n        )\n    }\n}\n\nimpl<T> Channel<T> {\n    fn new() -> (Sender<T>, Receiver<T>) {\n        rawgo!(\n            \"\n    ch := make(chan T)\n    return Tuple2[chan<- T, <-chan T]{ first: ch, second: ch }\n    \"\n        )\n    }\n}\n\nimpl<T> Sender<T> {\n    fn send(&mut self, value: T) {\n        rawgo!(\"self <- value\")\n    }\n\n    fn close(&mut self) {\n        rawgo!(\"close(self)\")\n    }\n}\n\nimpl<T> Receiver<T> {\n    fn recv(&self) -> T {\n        rawgo!(\"return <- self\")\n    }\n}\n\nimpl string {\n    fn enumerate(self) -> EnumerateSlice<rune> {\n        rawgo!(\"return []rune(self)\")\n    }\n}\n"},"unicode":{"unicode.brg":"\n\nfn In  (r: rune, ranges: VarArgs<&RangeTable>) -> bool { EXT }\n\nfn Is  (rangeTab: &RangeTable, r: rune) -> bool { EXT }\n\nfn IsControl  (r: rune) -> bool { EXT }\n\nfn IsDigit  (r: rune) -> bool { EXT }\n\nfn IsGraphic  (r: rune) -> bool { EXT }\n\nfn IsLetter  (r: rune) -> bool { EXT }\n\nfn IsLower  (r: rune) -> bool { EXT }\n\nfn IsMark  (r: rune) -> bool { EXT }\n\nfn IsNumber  (r: rune) -> bool { EXT }\n\nfn IsOneOf  (ranges: [&RangeTable], r: rune) -> bool { EXT }\n\nfn IsPrint  (r: rune) -> bool { EXT }\n\nfn IsPunct  (r: rune) -> bool { EXT }\n\nfn IsSpace  (r: rune) -> bool { EXT }\n\nfn IsSymbol  (r: rune) -> bool { EXT }\n\nfn IsTitle  (r: rune) -> bool { EXT }\n\nfn IsUpper  (r: rune) -> bool { EXT }\n\nfn SimpleFold  (r: rune) -> rune { EXT }\n\nfn To  (_case: int, r: rune) -> rune { EXT }\n\nfn ToLower  (r: rune) -> rune { EXT }\n\nfn ToTitle  (r: rune) -> rune { EXT }\n\nfn ToUpper  (r: rune) -> rune { EXT }\n\nimpl SpecialCase {\n\nfn ToLower  (self, r: rune) -> rune { EXT }\n\nfn ToTitle  (self, r: rune) -> rune { EXT }\n\nfn ToUpper  (self, r: rune) -> rune { EXT }\n\n}\n\ntype SpecialCase = [CaseRange];\n\nstruct CaseRange{\nLo: uint32,\nHi: uint32,\n// Delta: d // TODO d is not exported so... why is it public?\n}\n\nstruct Range16{\nLo: uint16,\nHi: uint16,\nStride: uint16\n}\n\nstruct Range32{\nLo: uint32,\nHi: uint32,\nStride: uint32\n}\n\nstruct RangeTable{\nR16: [Range16],\nR32: [Range32],\nLatinOffset: int\n}\n\n\n"},"fmt":{"fmt.brg":"\n    use io;\n\n    fn Printf(format: string, a: VarArgs<any>) -> Result<int> {\n        EXT\n    }\n    fn Fprintf(w: io::Writer, format: string, a: VarArgs<any>) -> Result<int> {\n        EXT\n    }\n    fn Errorf(format: string, a: VarArgs<any>) -> error {\n        EXT\n    }\n    fn Println(a: VarArgs<any>) {\n        EXT\n    }\n"},"reflect":{"reflect.brg":"\n    fn DeepEqual<T, Y>(a: T, b: Y) -> bool {\n        EXT\n    }\n"},"io":{"io.brg":"\n\nfn NopCloser  (r: Reader) -> ReadCloser { EXT }\n\nfn LimitReader  (r: Reader, n: int64) -> Reader { EXT }\n\nfn MultiReader  (readers: VarArgs<Reader>) -> Reader { EXT }\n\nfn TeeReader  (r: Reader, w: Writer) -> Reader { EXT }\n\nfn NewSectionReader  (r: ReaderAt, off: int64, n: int64) -> &SectionReader { EXT }\n\nfn MultiWriter  (writers: VarArgs<Writer>) -> Writer { EXT }\n\nfn Copy  (dst: Writer, src: Reader) -> Result<int64> { EXT }\n\nfn CopyBuffer  (dst: Writer, src: Reader, buf: [byte]) -> Result<int64> { EXT }\n\nfn CopyN  (dst: Writer, src: Reader, n: int64) -> Result<int64> { EXT }\n\nfn Pipe  () -> (&PipeReader, &PipeWriter) { EXT }\n\nfn ReadAll  (r: Reader) -> Result<[byte]> { EXT }\n\nfn ReadAtLeast  (r: Reader, buf: [byte], min: int) -> Result<int> { EXT }\n\nfn ReadFull  (r: Reader, buf: [byte]) -> Result<int> { EXT }\n\nfn WriteString  (w: Writer, s: string) -> Result<int> { EXT }\n\nimpl SectionReader {\n\nfn Read  (&self, p: [byte]) -> Result<int> { EXT }\n\nfn ReadAt  (&self, p: [byte], off: int64) -> Result<int> { EXT }\n\nfn Seek  (&self, offset: int64, whence: int) -> Result<int64> { EXT }\n\nfn Size  (&self, ) -> int64 { EXT }\n\n}\n\nimpl LimitedReader {\n\nfn Read  (&self, p: [byte]) -> Result<int> { EXT }\n\n}\n\nimpl PipeReader {\n\nfn Close  (&self, ) -> error { EXT }\n\nfn CloseWithError  (&self, err: error) -> error { EXT }\n\nfn Read  (&self, data: [byte]) -> Result<int> { EXT }\n\n}\n\nimpl PipeWriter {\n\nfn Close  (&self, ) -> error { EXT }\n\nfn CloseWithError  (&self, err: error) -> error { EXT }\n\nfn Write  (&self, data: [byte]) -> Result<int> { EXT }\n\n}\n\ntrait ByteReader{\nfn ReadByte () -> Result<byte>;\n}\n\ntrait ByteScanner: ByteReader {\nfn UnreadByte () -> error;\n}\n\ntrait ByteWriter{\nfn WriteByte (c: byte) -> error;\n}\n\ntrait Closer{\nfn Close () -> error;\n}\n\nstruct LimitedReader{\nR: Reader,\nN: int64\n}\n\nstruct PipeReader{\n\n}\n\nstruct PipeWriter{\n\n}\n\ntrait ReadCloser: Reader + Closer {\n\n}\n\ntrait ReadSeekCloser: Reader + Seeker + Closer {\n\n}\n\ntrait ReadSeeker: Reader + Seeker {\n\n}\n\ntrait ReadWriteCloser: Reader + Writer + Closer {\n\n}\n\ntrait ReadWriteSeeker: Reader + Writer + Seeker {\n\n}\n\ntrait ReadWriter: Reader + Writer {\n\n}\n\ntrait Reader{\nfn Read (p: [byte]) -> Result<int>;\n}\n\ntrait ReaderAt{\nfn ReadAt (p: [byte], off: int64) -> Result<int>;\n}\n\ntrait ReaderFrom{\nfn ReadFrom (r: Reader) -> Result<int64>;\n}\n\ntrait RuneReader{\nfn ReadRune () -> (rune, int, error);\n}\n\ntrait RuneScanner: RuneReader {\nfn UnreadRune () -> error;\n}\n\nstruct SectionReader{\n\n}\n\ntrait Seeker{\nfn Seek (offset: int64, whence: int) -> Result<int64>;\n}\n\ntrait StringWriter{\nfn WriteString (s: string) -> Result<int>;\n}\n\ntrait WriteCloser: Writer + Closer {\n\n}\n\ntrait WriteSeeker: Writer + Seeker {\n\n}\n\ntrait Writer{\nfn Write (p: [byte]) -> Result<int>;\n}\n\ntrait WriterAt{\nfn WriteAt (p: [byte], off: int64) -> Result<int>;\n}\n\ntrait WriterTo{\nfn WriteTo (w: Writer) -> Result<int64>;\n}\n\n\n"},"io/fs":{"fs.brg":"\n    struct FileMode {}\n\n    trait FileInfo {\n        fn Name() -> string;\n        fn Size() -> int64;\n        fn Mode() -> FileMode;\n        // fn ModTime() -> time.Time;\n        fn IsDir() -> bool;\n        fn Sys() -> any;\n    }\n\n    impl FileMode {\n        fn IsRegular(&self) -> bool {\n            EXT\n        }\n    }\n"},"math/rand":{"rand.brg":"\n\nfn New  (src: Source) -> &Rand { EXT }\n\nfn NewSource  (seed: int64) -> Source { EXT }\n\nfn NewZipf  (r: &Rand, s: float64, v: float64, imax: uint64) -> &Zipf { EXT }\n\nfn ExpFloat64  () -> float64 { EXT }\n\nfn Float32  () -> float32 { EXT }\n\nfn Float64  () -> float64 { EXT }\n\nfn Int  () -> int { EXT }\n\nfn Int31  () -> int32 { EXT }\n\nfn Int31n  (n: int32) -> int32 { EXT }\n\nfn Int63  () -> int64 { EXT }\n\nfn Int63n  (n: int64) -> int64 { EXT }\n\nfn Intn  (n: int) -> int { EXT }\n\nfn NormFloat64  () -> float64 { EXT }\n\nfn Perm  (n: int) -> [int] { EXT }\n\nfn Read  (p: [byte]) -> Result<int> { EXT }\n\nfn Seed  (seed: int64) -> () { EXT }\n\nfn Shuffle  (n: int, swap: fn (i: int) -> ()) -> () { EXT }\n\nfn Uint32  () -> uint32 { EXT }\n\nfn Uint64  () -> uint64 { EXT }\n\nimpl Rand {\n\nfn ExpFloat64  (&self, ) -> float64 { EXT }\n\nfn Float32  (&self, ) -> float32 { EXT }\n\nfn Float64  (&self, ) -> float64 { EXT }\n\nfn Int  (&self, ) -> int { EXT }\n\nfn Int31  (&self, ) -> int32 { EXT }\n\nfn Int31n  (&self, n: int32) -> int32 { EXT }\n\nfn Int63  (&self, ) -> int64 { EXT }\n\nfn Int63n  (&self, n: int64) -> int64 { EXT }\n\nfn Intn  (&self, n: int) -> int { EXT }\n\nfn NormFloat64  (&self, ) -> float64 { EXT }\n\nfn Perm  (&self, n: int) -> [int] { EXT }\n\nfn Read  (&self, p: [byte]) -> Result<int> { EXT }\n\nfn Seed  (&self, seed: int64) -> () { EXT }\n\nfn Shuffle  (&self, n: int, swap: fn (i: int) -> ()) -> () { EXT }\n\nfn Uint32  (&self, ) -> uint32 { EXT }\n\nfn Uint64  (&self, ) -> uint64 { EXT }\n\n}\n\nimpl Zipf {\n\nfn Uint64  (&self, ) -> uint64 { EXT }\n\n}\n\nstruct Rand{\n\n}\n\ntrait Source{\nfn Int63 () -> int64;\nfn Seed (seed: int64) -> ();\n}\n\ntrait Source64: Source {\nfn Uint64 () -> uint64;\n}\n\nstruct Zipf{\n\n}\n\n\n"},"math":{"math.brg":"\n    const Pi: float64 = EXT;\n"},"time":{"time.brg":"\n\nfn ParseDuration  (s: string) -> Result<Duration> { EXT }\n\nfn Since  (t: Time) -> Duration { EXT }\n\nfn Until  (t: Time) -> Duration { EXT }\n\nfn FixedZone  (name: string, offset: int) -> &Location { EXT }\n\nfn LoadLocation  (name: string) -> Result<&Location> { EXT }\n\nfn LoadLocationFromTZData  (name: string, data: [byte]) -> Result<&Location> { EXT }\n\nfn NewTicker  (d: Duration) -> &Ticker { EXT }\n\nfn Date  (year: int, month: Month, day: int, hour: int, min: int, sec: int, nsec: int, loc: &Location) -> Time { EXT }\n\nfn Now  () -> Time { EXT }\n\nfn Parse  (layout: string, value: string) -> Result<Time> { EXT }\n\nfn ParseInLocation  (layout: string, value: string, loc: &Location) -> Result<Time> { EXT }\n\nfn Unix  (sec: int64, nsec: int64) -> Time { EXT }\n\nfn UnixMicro  (usec: int64) -> Time { EXT }\n\nfn UnixMilli  (msec: int64) -> Time { EXT }\n\nfn AfterFunc  (d: Duration, f: fn () -> ()) -> &Timer { EXT }\n\nfn NewTimer  (d: Duration) -> &Timer { EXT }\n\nfn After  (d: Duration) -> Receiver<Time> { EXT }\n\nfn Sleep  (d: Duration) -> () { EXT }\n\nfn Tick  (d: Duration) -> Receiver<Time> { EXT }\n\nimpl ParseError {\n\nfn Error  (&self, ) -> string { EXT }\n\n}\n\nimpl Ticker {\n\nfn Reset  (&self, d: Duration) -> () { EXT }\n\nfn Stop  (&self, ) -> () { EXT }\n\n}\n\nimpl Time {\n\nfn Add  (self, d: Duration) -> Time { EXT }\n\nfn AddDate  (self, years: int, months: int, days: int) -> Time { EXT }\n\nfn After  (self, u: Time) -> bool { EXT }\n\nfn AppendFormat  (self, b: [byte], layout: string) -> [byte] { EXT }\n\nfn Before  (self, u: Time) -> bool { EXT }\n\nfn Clock  (self, ) -> int { EXT }\n\nfn Date  (self, ) -> (int, Month, int) { EXT }\n\nfn Day  (self, ) -> int { EXT }\n\nfn Equal  (self, u: Time) -> bool { EXT }\n\nfn Format  (self, layout: string) -> string { EXT }\n\nfn GoString  (self, ) -> string { EXT }\n\nfn GobDecode  (&self, data: [byte]) -> error { EXT }\n\nfn GobEncode  (self, ) -> Result<[byte]> { EXT }\n\nfn Hour  (self, ) -> int { EXT }\n\nfn ISOWeek  (self, ) -> int { EXT }\n\nfn In  (self, loc: &Location) -> Time { EXT }\n\nfn IsDST  (self, ) -> bool { EXT }\n\nfn IsZero  (self, ) -> bool { EXT }\n\nfn Local  (self, ) -> Time { EXT }\n\nfn Location  (self, ) -> &Location { EXT }\n\nfn MarshalBinary  (self, ) -> Result<[byte]> { EXT }\n\nfn MarshalJSON  (self, ) -> Result<[byte]> { EXT }\n\nfn MarshalText  (self, ) -> Result<[byte]> { EXT }\n\nfn Minute  (self, ) -> int { EXT }\n\nfn Month  (self, ) -> Month { EXT }\n\nfn Nanosecond  (self, ) -> int { EXT }\n\nfn Round  (self, d: Duration) -> Time { EXT }\n\nfn Second  (self, ) -> int { EXT }\n\nfn String  (self, ) -> string { EXT }\n\nfn Sub  (self, u: Time) -> Duration { EXT }\n\nfn Truncate  (self, d: Duration) -> Time { EXT }\n\nfn UTC  (self, ) -> Time { EXT }\n\nfn Unix  (self, ) -> int64 { EXT }\n\nfn UnixMicro  (self, ) -> int64 { EXT }\n\nfn UnixMilli  (self, ) -> int64 { EXT }\n\nfn UnixNano  (self, ) -> int64 { EXT }\n\nfn UnmarshalBinary  (&self, data: [byte]) -> error { EXT }\n\nfn UnmarshalJSON  (&self, data: [byte]) -> error { EXT }\n\nfn UnmarshalText  (&self, data: [byte]) -> error { EXT }\n\nfn Weekday  (self, ) -> Weekday { EXT }\n\nfn Year  (self, ) -> int { EXT }\n\nfn YearDay  (self, ) -> int { EXT }\n\nfn Zone  (self, ) -> (string, int) { EXT }\n\nfn ZoneBounds  (self, ) -> Time { EXT }\n\n}\n\nimpl Timer {\n\nfn Reset  (&self, d: Duration) -> bool { EXT }\n\nfn Stop  (&self, ) -> bool { EXT }\n\n}\n\nimpl Weekday {\n\nfn String  (self, ) -> string { EXT }\n\n}\n\nimpl Duration {\n\nfn Abs  (self, ) -> Duration { EXT }\n\nfn Hours  (self, ) -> float64 { EXT }\n\nfn Microseconds  (self, ) -> int64 { EXT }\n\nfn Milliseconds  (self, ) -> int64 { EXT }\n\nfn Minutes  (self, ) -> float64 { EXT }\n\nfn Nanoseconds  (self, ) -> int64 { EXT }\n\nfn Round  (self, m: Duration) -> Duration { EXT }\n\nfn Seconds  (self, ) -> float64 { EXT }\n\nfn String  (self, ) -> string { EXT }\n\nfn Truncate  (self, m: Duration) -> Duration { EXT }\n\n}\n\nimpl Location {\n\nfn String  (&self, ) -> string { EXT }\n\n}\n\nimpl Month {\n\nfn String  (self, ) -> string { EXT }\n\n}\n\nstruct Duration(int64);\n\nstruct Month(int);\n\nstruct Weekday(int);\n\nstruct Location{\n\n}\n\nstruct ParseError{\nLayout: string,\nValue: string,\nLayoutElem: string,\nValueElem: string,\nMessage: string\n}\n\nstruct Ticker{\nC: Receiver<Time>\n}\n\nstruct Time{\n\n}\n\nstruct Timer{\nC: Receiver<Time>\n}\n\n\n"},"log":{"log.brg":"\n    fn Fatalf(format: string, a: VarArgs<any>) {\n        EXT\n    }\n"},"os":{"os.brg":"\n\n    use io::fs;\n\nconst Stdin: File = File {};\n\n    // TODO remove this when type aliases across packages work properly\n    // type FileInfo = fs::FileInfo;\n    struct FileInfo {}\n\n    struct File {}\n\n\n    impl File {\n        fn Close(&mut self) -> error {\n            EXT\n        }\n        fn Write(&mut self, b: [byte]) -> Result<int> {\n            EXT\n        }\n        fn Read(&self, b: [byte]) -> Result<int> {\n            EXT\n        }\n    }\n\n    fn Create(name: string) -> Result<&mut File> {\n        EXT\n    }\n    fn LookupEnv(key: string) -> Option<string> {\n        EXT\n    }\n    fn Open(name: string) -> Result<&mut File> {\n        EXT\n    }\n    fn ReadFile(path: string) -> Result<[byte]> {\n        EXT\n    }\n    // TODO change this\n    // fn Stat(name: string) -> Result<FileInfo> {\n    fn Stat(name: string) -> Result<fs::FileInfo> {\n        EXT\n    }\n"},"errors":{"errors.brg":"\n    fn New(text: string) -> error {\n        EXT\n    }\n"},"sync":{"sync.brg":"\n    struct Mutex {}\n    struct WaitGroup {}\n\n    impl Mutex {\n        fn Lock(&mut self) {\n            EXT\n        }\n\n        fn Unlock(&mut self) {\n            EXT\n        }\n    }\n\n    impl WaitGroup {\n        fn Add(&mut self, delta: int) {\n            EXT\n        }\n        fn Done(&mut self) {\n            EXT\n        }\n        fn Wait(&mut self) {\n            EXT\n        }\n    }\n"}}