{"strings":{"strings.brg":"\n    fn HasPrefix(s: string, prefix: string) -> bool {\n        EXT\n    }\n"},"net/http":{"http.brg":"\n    struct Request {}\n\n    trait ResponseWriter {\n        fn Write(bytes: [byte]) -> Result<int>;\n    }\n\n    trait Handler {\n        fn ServeHTTP(w: ResponseWriter, r: &Request);\n    }\n\n    fn Handle(pattern: string, handler: Handler) {\n        EXT\n    }\n    fn ListenAndServe(addr: string, handler: Handler) {\n        EXT\n    }\n"},"core":{"core.brg":"\n// TODO asdf move this to builtin.brg\n    trait ComplexType {}\n    trait FloatType {}\n    trait IntegerType {}\n    trait any {}\n    type bool = EXT;\n    type byte = EXT;\n    trait comparable {}\n    type complex128 = EXT;\n    type complex64 = EXT;\n    trait error {\n        fn Error() -> string;\n    }\n    type float32 = EXT;\n    type float64 = EXT;\n    type int = EXT;\n    type int16 = EXT;\n    type int32 = EXT;\n    type int64 = EXT;\n    type int8 = EXT;\n    type rune = EXT;\n    type string = EXT;\n    type uint = EXT;\n    type uint16 = EXT;\n    type uint32 = EXT;\n    type uint64 = EXT;\n    type uint8 = EXT;\n    type uintptr = EXT;\n\n    fn string(a: any) -> string {\n        EXT\n    }\n\n\n    /// ---------------------------------------------------------------\n\ntype Map<K, V> = EXT;\n\ntype EnumerateSlice<T> = EXT;\n\ntype VarArgs<T> = EXT;\n\ntype Channel<T> = EXT;\ntype Sender<T> = EXT;\ntype Receiver<T> = EXT;\n\ntype Unit = EXT;\ntype Slice<T> = EXT;\ntype never = EXT;\ntype Ref<T> = EXT;\ntype RefMut<T> = EXT;\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nimpl<T, E> Result<T, E> {\n    fn IsOk(self) -> bool {\n        match self {\n            Ok(_) => true,\n            Err(_) => false,\n        }\n    }\n\n    fn unwrap(self) -> T {\n        rawgo!(\n            \"\n      if self.tag == Result_Err {\n        inspect(self.Err)\n        panic(\\\"Unwrapped Err value\\\")\n      }\n\n      return self.Ok\n    \"\n        )\n    }\n}\n\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nimpl<T> Option<T> {\n    fn IsSome(self) -> bool {\n        match self {\n            Some(_) => true,\n            None => false,\n        }\n    }\n\n    fn IsNone(self) -> bool {\n        !self.IsSome()\n    }\n\n    fn unwrap_or(self, def: T) -> T {\n        match self {\n            Some(x) => x,\n            None => def,\n        }\n    }\n\n    fn unwrap_or_else(self, f: fn() -> T) -> T {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n\n    fn unwrap(self) -> T {\n        rawgo!(\n            \"\n        if self.tag == Option_None {\n          panic(\\\"Unwrapped None value\\\")\n        }\n\n        return self.Some\n      \"\n        )\n    }\n\n    fn ToOption(value: T, check: bool) -> Option<T> {\n        if check {\n            Some(value)\n        } else {\n            None\n        }\n    }\n}\n\nstruct Tuple2<T, Y> {\n    first: T,\n    second: Y,\n}\n\nstruct Tuple3<T, Y, Z> {\n    first: T,\n    second: Y,\n    third: Z,\n}\n\nfn zero_value<T>() -> T {\n    rawgo!(\n        \"\n    var m T\n    return m\n  \"\n    )\n}\n\nfn assert_eq<T>(a: T, b: T) {\n  rawgo!(\"\n    if !reflect.DeepEqual(a, b) {\n        inspect(a);\n        inspect(b);\n        panic(\\\"something wrong\\\")\n    }\n    \")\n}\n\nfn inspect<T>(a: T) -> T {\n  rawgo!(\"\n    fmt.Printf(\\\"%+v\\\\n\\\", a);\n    return a\n  \")\n}\n\nfn Debug_unreachable<T>() -> T {\n    rawgo!(\"panic(\\\"unreachable code\\\")\")\n}\n\nfn to_result(e: error) -> Result<()> {\n    rawgo!(\n        \"if e != nil {\n    return struct{}{}, e\n  }\n  return struct{}{}, nil\n  \"\n    )\n}\n\nimpl<T> [T] {\n    fn len(self) -> int {\n        rawgo!(\"return len(self)\")\n    }\n\n    fn enumerate(self) -> EnumerateSlice<T> {\n        rawgo!(\"return self\")\n    }\n\n    fn set(&mut self, index: int, item: T) {\n        rawgo!(\"self[index] = item\")\n    }\n\n    fn append(&mut self, item: T) -> [T] {\n        rawgo!(\"return append(self, item)\")\n    }\n\n    fn get(self, i: int) -> Option<T> {\n        rawgo!(\n            \"\n            if i < 0 || i >= len(self) {\n              return *new(T), false\n            }\n\n      return self[i], true\n    \"\n        )\n    }\n}\n\nimpl<K: comparable, V> Map<K, V> {\n    fn new() -> Map<K, V> {\n        rawgo!(\"return map[K]V{}\")\n    }\n\n    fn len(self) -> int {\n        rawgo!(\"return len(self)\")\n    }\n\n    fn insert(self, k: K, v: V) {\n        rawgo!(\"self[k] = v\")\n    }\n\n    fn get(self, k: K) -> Option<V> {\n        rawgo!(\n            \"\n        v, ok := self[k]\n        return v, ok\n        \"\n        )\n    }\n}\n\nimpl<T> Channel<T> {\n    fn new() -> (Sender<T>, Receiver<T>) {\n        rawgo!(\n            \"\n    ch := make(chan T)\n    return Tuple2[chan<- T, <-chan T]{ first: ch, second: ch }\n    \"\n        )\n    }\n}\n\nimpl<T> Sender<T> {\n    fn send(&mut self, value: T) {\n        rawgo!(\"self <- value\")\n    }\n\n    fn close(&mut self) {\n        rawgo!(\"close(self)\")\n    }\n}\n\nimpl<T> Receiver<T> {\n    fn recv(&self) -> T {\n        rawgo!(\"return <- self\")\n    }\n}\n\nimpl string {\n    fn enumerate(self) -> EnumerateSlice<rune> {\n        rawgo!(\"return []rune(self)\")\n    }\n}\n"},"fmt":{"fmt.brg":"\n    use io;\n\n    fn Printf(format: string, a: VarArgs<any>) -> Result<int> {\n        EXT\n    }\n    fn Fprintf(w: io::Writer, format: string, a: VarArgs<any>) -> Result<int> {\n        EXT\n    }\n    fn Errorf(format: string, a: VarArgs<any>) -> error {\n        EXT\n    }\n    fn Println(a: VarArgs<any>) {\n        EXT\n    }\n"},"reflect":{"reflect.brg":"\n    fn DeepEqual<T, Y>(a: T, b: Y) -> bool {\n        EXT\n    }\n"},"io":{"io.brg":"\n    trait Writer {\n        fn Write(bytes: [byte]) -> Result<int>;\n    }\n    trait Reader {\n        fn Read(p: [byte]) -> Result<int>;\n    }\n\n    trait ReadWriter: Reader + Writer {}\n\n    fn Copy(dst: &mut Writer, src: &Reader) -> Result<int64> {\n        EXT\n    }\n"},"io/fs":{"fs.brg":"\n    struct FileMode {}\n\n    trait FileInfo {\n        fn Name() -> string;\n        fn Size() -> int64;\n        fn Mode() -> FileMode;\n        // fn ModTime() -> time.Time;\n        fn IsDir() -> bool;\n        fn Sys() -> any;\n    }\n\n    impl FileMode {\n        fn IsRegular(&self) -> bool {\n            EXT\n        }\n    }\n"},"math/rand":{"rand.brg":"\n    fn Int() -> int {\n        EXT\n    }\n    fn Float64() -> float64 {\n        EXT\n    }\n"},"math":{"math.brg":"\n    const Pi: float64 = EXT;\n"},"log":{"log.brg":"\n    fn Fatalf(format: string, a: VarArgs<any>) {\n        EXT\n    }\n"},"os":{"os.brg":"\n    use io::fs;\n\n    // TODO remove this when type aliases across packages work properly\n    // type FileInfo = fs::FileInfo;\n    struct FileInfo {}\n\n    struct File {}\n\n\n    impl File {\n        fn Close(&mut self) -> error {\n            EXT\n        }\n        fn Write(&mut self, b: [byte]) -> Result<int> {\n            EXT\n        }\n        fn Read(&self, b: [byte]) -> Result<int> {\n            EXT\n        }\n    }\n\n    fn Create(name: string) -> Result<&mut File> {\n        EXT\n    }\n    fn LookupEnv(key: string) -> Option<string> {\n        EXT\n    }\n    fn Open(name: string) -> Result<&mut File> {\n        EXT\n    }\n    fn ReadFile(path: string) -> Result<[byte]> {\n        EXT\n    }\n    // TODO change this\n    // fn Stat(name: string) -> Result<FileInfo> {\n    fn Stat(name: string) -> Result<fs::FileInfo> {\n        EXT\n    }\n"},"errors":{"errors.brg":"\n    fn New(text: string) -> error {\n        EXT\n    }\n"},"sync":{"sync.brg":"\n    struct Mutex {}\n    struct WaitGroup {}\n\n    impl Mutex {\n        fn Lock(&mut self) {\n            EXT\n        }\n\n        fn Unlock(&mut self) {\n            EXT\n        }\n    }\n\n    impl WaitGroup {\n        fn Add(&mut self, delta: int) {\n            EXT\n        }\n        fn Done(&mut self) {\n            EXT\n        }\n        fn Wait(&mut self) {\n            EXT\n        }\n    }\n"}}