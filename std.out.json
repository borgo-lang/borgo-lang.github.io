{"bufio":{"bufio.brg":"use io;\n\nfn NewReadWriter(r: &Reader, w: &Writer) -> &ReadWriter {\n    EXT\n}\n\nfn NewReader(rd: io::Reader) -> &Reader {\n    EXT\n}\n\nfn NewReaderSize(rd: io::Reader, size: int) -> &Reader {\n    EXT\n}\n\nfn NewScanner(r: io::Reader) -> &Scanner {\n    EXT\n}\n\nfn NewWriter(w: io::Writer) -> &Writer {\n    EXT\n}\n\nfn NewWriterSize(w: io::Writer, size: int) -> &Writer {\n    EXT\n}\n\nfn ScanBytes(data: [byte], atEOF: bool) -> (int, [byte], error) {\n    EXT\n}\n\nfn ScanLines(data: [byte], atEOF: bool) -> (int, [byte], error) {\n    EXT\n}\n\nfn ScanRunes(data: [byte], atEOF: bool) -> (int, [byte], error) {\n    EXT\n}\n\nfn ScanWords(data: [byte], atEOF: bool) -> (int, [byte], error) {\n    EXT\n}\n\nimpl Scanner {\n    fn Buffer(&self, buf: [byte], max: int) -> () {\n        EXT\n    }\n\n    fn Bytes(&self) -> [byte] {\n        EXT\n    }\n\n    fn Err(&self) -> error {\n        EXT\n    }\n\n    fn Scan(&self) -> bool {\n        EXT\n    }\n\n    fn Split(&self, split: SplitFunc) -> () {\n        EXT\n    }\n\n    fn Text(&self) -> string {\n        EXT\n    }\n}\n\nimpl Writer {\n    fn Available(&self) -> int {\n        EXT\n    }\n\n    fn AvailableBuffer(&self) -> [byte] {\n        EXT\n    }\n\n    fn Buffered(&self) -> int {\n        EXT\n    }\n\n    fn Flush(&self) -> error {\n        EXT\n    }\n\n    fn ReadFrom(&self, r: io::Reader) -> Result<int64> {\n        EXT\n    }\n\n    fn Reset(&self, w: io::Writer) -> () {\n        EXT\n    }\n\n    fn Size(&self) -> int {\n        EXT\n    }\n\n    fn Write(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn WriteByte(&self, c: byte) -> error {\n        EXT\n    }\n\n    fn WriteRune(&self, r: rune) -> Result<int> {\n        EXT\n    }\n\n    fn WriteString(&self, s: string) -> Result<int> {\n        EXT\n    }\n}\n\nimpl Reader {\n    fn Buffered(&self) -> int {\n        EXT\n    }\n\n    fn Discard(&self, n: int) -> Result<int> {\n        EXT\n    }\n\n    fn Peek(&self, n: int) -> Result<[byte]> {\n        EXT\n    }\n\n    fn Read(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn ReadByte(&self) -> Result<byte> {\n        EXT\n    }\n\n    fn ReadBytes(&self, delim: byte) -> Result<[byte]> {\n        EXT\n    }\n\n    fn ReadLine(&self) -> ([byte], bool, error) {\n        EXT\n    }\n\n    fn ReadRune(&self) -> (rune, int, error) {\n        EXT\n    }\n\n    fn ReadSlice(&self, delim: byte) -> Result<[byte]> {\n        EXT\n    }\n\n    fn ReadString(&self, delim: byte) -> Result<string> {\n        EXT\n    }\n\n    fn Reset(&self, r: io::Reader) -> () {\n        EXT\n    }\n\n    fn Size(&self) -> int {\n        EXT\n    }\n\n    fn UnreadByte(&self) -> error {\n        EXT\n    }\n\n    fn UnreadRune(&self) -> error {\n        EXT\n    }\n\n    fn WriteTo(&self, w: io::Writer) -> Result<int64> {\n        EXT\n    }\n}\n\ntype SplitFunc = fn(data: [byte], atEOF: bool) -> (int, [byte], error);\n\nstruct ReadWriter {\n    // : &Reader,\n    // : &Writer\n}\n\nstruct Reader {}\n\nstruct Scanner {}\n\nstruct Writer {}\n"},"strconv":{"strconv.brg":"fn AppendBool(dst: [byte], b: bool) -> [byte] {\n    EXT\n}\n\nfn AppendFloat(dst: [byte], f: float64, fmt: byte, prec: int) -> [byte] {\n    EXT\n}\n\nfn AppendInt(dst: [byte], i: int64, base: int) -> [byte] {\n    EXT\n}\n\nfn AppendQuote(dst: [byte], s: string) -> [byte] {\n    EXT\n}\n\nfn AppendQuoteRune(dst: [byte], r: rune) -> [byte] {\n    EXT\n}\n\nfn AppendQuoteRuneToASCII(dst: [byte], r: rune) -> [byte] {\n    EXT\n}\n\nfn AppendQuoteRuneToGraphic(dst: [byte], r: rune) -> [byte] {\n    EXT\n}\n\nfn AppendQuoteToASCII(dst: [byte], s: string) -> [byte] {\n    EXT\n}\n\nfn AppendQuoteToGraphic(dst: [byte], s: string) -> [byte] {\n    EXT\n}\n\nfn AppendUint(dst: [byte], i: uint64, base: int) -> [byte] {\n    EXT\n}\n\nfn Atoi(s: string) -> Result<int> {\n    EXT\n}\n\nfn CanBackquote(s: string) -> bool {\n    EXT\n}\n\nfn FormatBool(b: bool) -> string {\n    EXT\n}\n\nfn FormatComplex(c: complex128, fmt: byte, prec: int) -> string {\n    EXT\n}\n\nfn FormatFloat(f: float64, fmt: byte, prec: int) -> string {\n    EXT\n}\n\nfn FormatInt(i: int64, base: int) -> string {\n    EXT\n}\n\nfn FormatUint(i: uint64, base: int) -> string {\n    EXT\n}\n\nfn IsGraphic(r: rune) -> bool {\n    EXT\n}\n\nfn IsPrint(r: rune) -> bool {\n    EXT\n}\n\nfn Itoa(i: int) -> string {\n    EXT\n}\n\nfn ParseBool(str: string) -> Result<bool> {\n    EXT\n}\n\nfn ParseComplex(s: string, bitSize: int) -> Result<complex128> {\n    EXT\n}\n\nfn ParseFloat(s: string, bitSize: int) -> Result<float64> {\n    EXT\n}\n\nfn ParseInt(s: string, base: int, bitSize: int) -> Result<int64> {\n    EXT\n}\n\nfn ParseUint(s: string, base: int, bitSize: int) -> Result<uint64> {\n    EXT\n}\n\nfn Quote(s: string) -> string {\n    EXT\n}\n\nfn QuoteRune(r: rune) -> string {\n    EXT\n}\n\nfn QuoteRuneToASCII(r: rune) -> string {\n    EXT\n}\n\nfn QuoteRuneToGraphic(r: rune) -> string {\n    EXT\n}\n\nfn QuoteToASCII(s: string) -> string {\n    EXT\n}\n\nfn QuoteToGraphic(s: string) -> string {\n    EXT\n}\n\nfn QuotedPrefix(s: string) -> Result<string> {\n    EXT\n}\n\nfn Unquote(s: string) -> Result<string> {\n    EXT\n}\n\nfn UnquoteChar(s: string, quote: byte) -> (rune, bool, string, error) {\n    EXT\n}\n\nimpl NumError {\n    fn Error(&self) -> string {\n        EXT\n    }\n\n    fn Unwrap(&self) -> error {\n        EXT\n    }\n}\n\nstruct NumError {\n    Func: string,\n    Num: string,\n    Err: error,\n}\n"},"strings":{"strings.brg":"use io;\nuse unicode;\n\nfn NewReader(s: string) -> &Reader {\n    EXT\n}\n\nfn NewReplacer(oldnew: VarArgs<string>) -> &Replacer {\n    EXT\n}\n\nfn Clone(s: string) -> string {\n    EXT\n}\n\nfn Compare(a: string, b: string) -> int {\n    EXT\n}\n\nfn Contains(s: string, substr: string) -> bool {\n    EXT\n}\n\nfn ContainsAny(s: string, chars: string) -> bool {\n    EXT\n}\n\nfn ContainsRune(s: string, r: rune) -> bool {\n    EXT\n}\n\nfn Count(s: string, substr: string) -> int {\n    EXT\n}\n\nfn Cut(s: string, sep: string) -> (string, bool) {\n    EXT\n}\n\nfn EqualFold(s: string, t: string) -> bool {\n    EXT\n}\n\nfn Fields(s: string) -> [string] {\n    EXT\n}\n\nfn FieldsFunc(s: string, f: fn(param0: rune) -> bool) -> [string] {\n    EXT\n}\n\nfn HasPrefix(s: string, prefix: string) -> bool {\n    EXT\n}\n\nfn HasSuffix(s: string, suffix: string) -> bool {\n    EXT\n}\n\nfn Index(s: string, substr: string) -> int {\n    EXT\n}\n\nfn IndexAny(s: string, chars: string) -> int {\n    EXT\n}\n\nfn IndexByte(s: string, c: byte) -> int {\n    EXT\n}\n\nfn IndexFunc(s: string, f: fn(param0: rune) -> bool) -> int {\n    EXT\n}\n\nfn IndexRune(s: string, r: rune) -> int {\n    EXT\n}\n\nfn Join(elems: [string], sep: string) -> string {\n    EXT\n}\n\nfn LastIndex(s: string, substr: string) -> int {\n    EXT\n}\n\nfn LastIndexAny(s: string, chars: string) -> int {\n    EXT\n}\n\nfn LastIndexByte(s: string, c: byte) -> int {\n    EXT\n}\n\nfn LastIndexFunc(s: string, f: fn(param0: rune) -> bool) -> int {\n    EXT\n}\n\nfn Map(mapping: fn(param0: rune) -> rune, s: string) -> string {\n    EXT\n}\n\nfn Repeat(s: string, count: int) -> string {\n    EXT\n}\n\nfn Replace(s: string, old: string, new: string, n: int) -> string {\n    EXT\n}\n\nfn ReplaceAll(s: string, old: string, new: string) -> string {\n    EXT\n}\n\nfn Split(s: string, sep: string) -> [string] {\n    EXT\n}\n\nfn SplitAfter(s: string, sep: string) -> [string] {\n    EXT\n}\n\nfn SplitAfterN(s: string, sep: string, n: int) -> [string] {\n    EXT\n}\n\nfn SplitN(s: string, sep: string, n: int) -> [string] {\n    EXT\n}\n\nfn Title(s: string) -> string {\n    EXT\n}\n\nfn ToLower(s: string) -> string {\n    EXT\n}\n\nfn ToLowerSpecial(c: unicode::SpecialCase, s: string) -> string {\n    EXT\n}\n\nfn ToTitle(s: string) -> string {\n    EXT\n}\n\nfn ToTitleSpecial(c: unicode::SpecialCase, s: string) -> string {\n    EXT\n}\n\nfn ToUpper(s: string) -> string {\n    EXT\n}\n\nfn ToUpperSpecial(c: unicode::SpecialCase, s: string) -> string {\n    EXT\n}\n\nfn ToValidUTF8(s: string, replacement: string) -> string {\n    EXT\n}\n\nfn Trim(s: string, cutset: string) -> string {\n    EXT\n}\n\nfn TrimFunc(s: string, f: fn(param0: rune) -> bool) -> string {\n    EXT\n}\n\nfn TrimLeft(s: string, cutset: string) -> string {\n    EXT\n}\n\nfn TrimLeftFunc(s: string, f: fn(param0: rune) -> bool) -> string {\n    EXT\n}\n\nfn TrimPrefix(s: string, prefix: string) -> string {\n    EXT\n}\n\nfn TrimRight(s: string, cutset: string) -> string {\n    EXT\n}\n\nfn TrimRightFunc(s: string, f: fn(param0: rune) -> bool) -> string {\n    EXT\n}\n\nfn TrimSpace(s: string) -> string {\n    EXT\n}\n\nfn TrimSuffix(s: string, suffix: string) -> string {\n    EXT\n}\n\nimpl Replacer {\n    fn Replace(&self, s: string) -> string {\n        EXT\n    }\n\n    fn WriteString(&self, w: io::Writer, s: string) -> Result<int> {\n        EXT\n    }\n}\n\nimpl Builder {\n    fn Cap(&self) -> int {\n        EXT\n    }\n\n    fn Grow(&self, n: int) -> () {\n        EXT\n    }\n\n    fn Len(&self) -> int {\n        EXT\n    }\n\n    fn Reset(&self) -> () {\n        EXT\n    }\n\n    fn String(&self) -> string {\n        EXT\n    }\n\n    fn Write(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn WriteByte(&self, c: byte) -> error {\n        EXT\n    }\n\n    fn WriteRune(&self, r: rune) -> Result<int> {\n        EXT\n    }\n\n    fn WriteString(&self, s: string) -> Result<int> {\n        EXT\n    }\n}\n\nimpl Reader {\n    fn Len(&self) -> int {\n        EXT\n    }\n\n    fn Read(&self, b: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn ReadAt(&self, b: [byte], off: int64) -> Result<int> {\n        EXT\n    }\n\n    fn ReadByte(&self) -> Result<byte> {\n        EXT\n    }\n\n    fn ReadRune(&self) -> (rune, int, error) {\n        EXT\n    }\n\n    fn Reset(&self, s: string) -> () {\n        EXT\n    }\n\n    fn Seek(&self, offset: int64, whence: int) -> Result<int64> {\n        EXT\n    }\n\n    fn Size(&self) -> int64 {\n        EXT\n    }\n\n    fn UnreadByte(&self) -> error {\n        EXT\n    }\n\n    fn UnreadRune(&self) -> error {\n        EXT\n    }\n\n    fn WriteTo(&self, w: io::Writer) -> Result<int64> {\n        EXT\n    }\n}\n\nstruct Builder {}\n\nstruct Reader {}\n\nstruct Replacer {}\n"},"net/http":{"http.brg":"\nstruct Request {}\n\ntrait ResponseWriter {\n    fn Write(bytes: [byte]) -> Result<int>;\n}\n\ntrait Handler {\n    fn ServeHTTP(w: ResponseWriter, r: &Request);\n}\n\nfn Handle(pattern: string, handler: Handler) {\n    EXT\n}\nfn ListenAndServe(addr: string, handler: Handler) {\n    EXT\n}\n"},"regexp":{"regexp.brg":"use io;\n\nfn Compile(expr: string) -> Result<&Regexp> {\n    EXT\n}\n\nfn CompilePOSIX(expr: string) -> Result<&Regexp> {\n    EXT\n}\n\nfn MustCompile(str: string) -> &Regexp {\n    EXT\n}\n\nfn MustCompilePOSIX(str: string) -> &Regexp {\n    EXT\n}\n\nfn Match(pattern: string, b: [byte]) -> Result<bool> {\n    EXT\n}\n\nfn MatchReader(pattern: string, r: io::RuneReader) -> Result<bool> {\n    EXT\n}\n\nfn MatchString(pattern: string, s: string) -> Result<bool> {\n    EXT\n}\n\nfn QuoteMeta(s: string) -> string {\n    EXT\n}\n\nimpl Regexp {\n    fn Copy(&self) -> &Regexp {\n        EXT\n    }\n\n    fn Expand(&self, dst: [byte], template: [byte], src: [byte], match_: [int]) -> [byte] {\n        EXT\n    }\n\n    fn ExpandString(&self, dst: [byte], template: string, src: string, match_: [int]) -> [byte] {\n        EXT\n    }\n\n    fn Find(&self, b: [byte]) -> [byte] {\n        EXT\n    }\n\n    fn FindAll(&self, b: [byte], n: int) -> [[byte]] {\n        EXT\n    }\n\n    fn FindAllIndex(&self, b: [byte], n: int) -> [[int]] {\n        EXT\n    }\n\n    fn FindAllString(&self, s: string, n: int) -> [string] {\n        EXT\n    }\n\n    fn FindAllStringIndex(&self, s: string, n: int) -> [[int]] {\n        EXT\n    }\n\n    fn FindAllStringSubmatch(&self, s: string, n: int) -> [[string]] {\n        EXT\n    }\n\n    fn FindAllStringSubmatchIndex(&self, s: string, n: int) -> [[int]] {\n        EXT\n    }\n\n    fn FindAllSubmatch(&self, b: [byte], n: int) -> [[[byte]]] {\n        EXT\n    }\n\n    fn FindAllSubmatchIndex(&self, b: [byte], n: int) -> [[int]] {\n        EXT\n    }\n\n    fn FindIndex(&self, b: [byte]) -> [int] {\n        EXT\n    }\n\n    fn FindReaderIndex(&self, r: io::RuneReader) -> [int] {\n        EXT\n    }\n\n    fn FindReaderSubmatchIndex(&self, r: io::RuneReader) -> [int] {\n        EXT\n    }\n\n    fn FindString(&self, s: string) -> string {\n        EXT\n    }\n\n    fn FindStringIndex(&self, s: string) -> [int] {\n        EXT\n    }\n\n    fn FindStringSubmatch(&self, s: string) -> [string] {\n        EXT\n    }\n\n    fn FindStringSubmatchIndex(&self, s: string) -> [int] {\n        EXT\n    }\n\n    fn FindSubmatch(&self, b: [byte]) -> [[byte]] {\n        EXT\n    }\n\n    fn FindSubmatchIndex(&self, b: [byte]) -> [int] {\n        EXT\n    }\n\n    fn LiteralPrefix(&self) -> (string, bool) {\n        EXT\n    }\n\n    fn Longest(&self) -> () {\n        EXT\n    }\n\n    fn Match(&self, b: [byte]) -> bool {\n        EXT\n    }\n\n    fn MatchReader(&self, r: io::RuneReader) -> bool {\n        EXT\n    }\n\n    fn MatchString(&self, s: string) -> bool {\n        EXT\n    }\n\n    fn NumSubexp(&self) -> int {\n        EXT\n    }\n\n    fn ReplaceAll(&self, src: [byte], repl: [byte]) -> [byte] {\n        EXT\n    }\n\n    fn ReplaceAllFunc(&self, src: [byte], repl: fn(param0: [byte]) -> [byte]) -> [byte] {\n        EXT\n    }\n\n    fn ReplaceAllLiteral(&self, src: [byte], repl: [byte]) -> [byte] {\n        EXT\n    }\n\n    fn ReplaceAllLiteralString(&self, src: string, repl: string) -> string {\n        EXT\n    }\n\n    fn ReplaceAllString(&self, src: string, repl: string) -> string {\n        EXT\n    }\n\n    fn ReplaceAllStringFunc(&self, src: string, repl: fn(param0: string) -> string) -> string {\n        EXT\n    }\n\n    fn Split(&self, s: string, n: int) -> [string] {\n        EXT\n    }\n\n    fn String(&self) -> string {\n        EXT\n    }\n\n    fn SubexpIndex(&self, name: string) -> int {\n        EXT\n    }\n\n    fn SubexpNames(&self) -> [string] {\n        EXT\n    }\n}\n\nstruct Regexp {}\n"},"core":{"core.brg":"// TODO asdf move this to builtin.brg\ntrait ComplexType {}\ntrait FloatType {}\ntrait IntegerType {}\ntrait any {}\ntype bool = EXT;\ntype byte = EXT;\ntrait comparable {}\ntype complex128 = EXT;\ntype complex64 = EXT;\ntrait error {\n    fn Error() -> string;\n}\ntype float32 = EXT;\ntype float64 = EXT;\ntype int = EXT;\ntype int16 = EXT;\ntype int32 = EXT;\ntype int64 = EXT;\ntype int8 = EXT;\ntype rune = EXT;\ntype string = EXT;\ntype uint = EXT;\ntype uint16 = EXT;\ntype uint32 = EXT;\ntype uint64 = EXT;\ntype uint8 = EXT;\ntype uintptr = EXT;\n\nfn string(a: any) -> string {\n    EXT\n}\n\n/// ---------------------------------------------------------------\n\ntype Map<K, V> = EXT;\n\ntype EnumerateSlice<T> = EXT;\n\ntype VarArgs<T> = EXT;\n\ntype Channel<T> = EXT;\ntype Sender<T> = EXT;\ntype Receiver<T> = EXT;\n\ntype Unit = EXT;\ntype Slice<T> = EXT;\ntype never = EXT;\ntype Ref<T> = EXT;\ntype RefMut<T> = EXT;\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nimpl<T, E> Result<T, E> {\n    fn IsOk(self) -> bool {\n        match self {\n            Ok(_) => true,\n            Err(_) => false,\n        }\n    }\n\n    fn unwrap(self) -> T {\n        rawgo!(\n            \"\n      if self.tag == Result_Err {\n        inspect(self.Err)\n        panic(\\\"Unwrapped Err value\\\")\n      }\n\n      return self.Ok\n    \"\n        )\n    }\n}\n\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nimpl<T> Option<T> {\n    fn IsSome(self) -> bool {\n        match self {\n            Some(_) => true,\n            None => false,\n        }\n    }\n\n    fn IsNone(self) -> bool {\n        !self.IsSome()\n    }\n\n    fn unwrap_or(self, def: T) -> T {\n        match self {\n            Some(x) => x,\n            None => def,\n        }\n    }\n\n    fn unwrap_or_else(self, f: fn() -> T) -> T {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n\n    fn unwrap(self) -> T {\n        rawgo!(\n            \"\n        if self.tag == Option_None {\n          panic(\\\"Unwrapped None value\\\")\n        }\n\n        return self.Some\n      \"\n        )\n    }\n\n    fn ToOption(value: T, check: bool) -> Option<T> {\n        if check {\n            Some(value)\n        } else {\n            None\n        }\n    }\n}\n\nstruct Tuple2<T, Y> {\n    first: T,\n    second: Y,\n}\n\nstruct Tuple3<T, Y, Z> {\n    first: T,\n    second: Y,\n    third: Z,\n}\n\nstruct Tuple4<T, X, Y, Z> {\n    first: T,\n    second: X,\n    third: Y,\n    fourth: Z,\n}\n\nfn zero_value<T>() -> T {\n    rawgo!(\n        \"\n    var m T\n    return m\n  \"\n    )\n}\n\nfn assert_eq<T>(a: T, b: T) {\n    rawgo!(\n        \"\n    if !reflect.DeepEqual(a, b) {\n        inspect(a);\n        inspect(b);\n        panic(\\\"something wrong\\\")\n    }\n    \"\n    )\n}\n\nfn inspect<T>(a: T) -> T {\n    rawgo!(\n        \"\n    fmt.Printf(\\\"%+v\\\\n\\\", a);\n    return a\n  \"\n    )\n}\n\nfn Debug_unreachable<T>() -> T {\n    rawgo!(\"panic(\\\"unreachable code\\\")\")\n}\n\nfn to_result(e: error) -> Result<()> {\n    rawgo!(\n        \"if e != nil {\n    return struct{}{}, e\n  }\n  return struct{}{}, nil\n  \"\n    )\n}\n\nimpl<T> [T] {\n    fn len(self) -> int {\n        rawgo!(\"return len(self)\")\n    }\n\n    fn enumerate(self) -> EnumerateSlice<T> {\n        rawgo!(\"return self\")\n    }\n\n    fn set(&mut self, index: int, item: T) {\n        rawgo!(\"self[index] = item\")\n    }\n\n    fn append(&mut self, item: T) -> [T] {\n        rawgo!(\"return append(self, item)\")\n    }\n\n    fn get(self, i: int) -> Option<T> {\n        rawgo!(\n            \"\n            if i < 0 || i >= len(self) {\n              return *new(T), false\n            }\n\n      return self[i], true\n    \"\n        )\n    }\n}\n\nimpl<K: comparable, V> Map<K, V> {\n    fn new() -> Map<K, V> {\n        rawgo!(\"return map[K]V{}\")\n    }\n\n    fn len(self) -> int {\n        rawgo!(\"return len(self)\")\n    }\n\n    fn insert(self, k: K, v: V) {\n        rawgo!(\"self[k] = v\")\n    }\n\n    fn get(self, k: K) -> Option<V> {\n        rawgo!(\n            \"\n        v, ok := self[k]\n        return v, ok\n        \"\n        )\n    }\n}\n\nimpl<T> Channel<T> {\n    fn new() -> (Sender<T>, Receiver<T>) {\n        rawgo!(\n            \"\n    ch := make(chan T)\n    return Tuple2[chan<- T, <-chan T]{ first: ch, second: ch }\n    \"\n        )\n    }\n}\n\nimpl<T> Sender<T> {\n    fn send(&mut self, value: T) {\n        rawgo!(\"self <- value\")\n    }\n\n    fn close(&mut self) {\n        rawgo!(\"close(self)\")\n    }\n}\n\nimpl<T> Receiver<T> {\n    fn recv(&self) -> T {\n        rawgo!(\"return <- self\")\n    }\n}\n\nimpl string {\n    fn enumerate(self) -> EnumerateSlice<rune> {\n        rawgo!(\"return []rune(self)\")\n    }\n}\n"},"unicode":{"unicode.brg":"fn In(r: rune, ranges: VarArgs<&RangeTable>) -> bool {\n    EXT\n}\n\nfn Is(rangeTab: &RangeTable, r: rune) -> bool {\n    EXT\n}\n\nfn IsControl(r: rune) -> bool {\n    EXT\n}\n\nfn IsDigit(r: rune) -> bool {\n    EXT\n}\n\nfn IsGraphic(r: rune) -> bool {\n    EXT\n}\n\nfn IsLetter(r: rune) -> bool {\n    EXT\n}\n\nfn IsLower(r: rune) -> bool {\n    EXT\n}\n\nfn IsMark(r: rune) -> bool {\n    EXT\n}\n\nfn IsNumber(r: rune) -> bool {\n    EXT\n}\n\nfn IsOneOf(ranges: [&RangeTable], r: rune) -> bool {\n    EXT\n}\n\nfn IsPrint(r: rune) -> bool {\n    EXT\n}\n\nfn IsPunct(r: rune) -> bool {\n    EXT\n}\n\nfn IsSpace(r: rune) -> bool {\n    EXT\n}\n\nfn IsSymbol(r: rune) -> bool {\n    EXT\n}\n\nfn IsTitle(r: rune) -> bool {\n    EXT\n}\n\nfn IsUpper(r: rune) -> bool {\n    EXT\n}\n\nfn SimpleFold(r: rune) -> rune {\n    EXT\n}\n\nfn To(_case: int, r: rune) -> rune {\n    EXT\n}\n\nfn ToLower(r: rune) -> rune {\n    EXT\n}\n\nfn ToTitle(r: rune) -> rune {\n    EXT\n}\n\nfn ToUpper(r: rune) -> rune {\n    EXT\n}\n\nimpl SpecialCase {\n    fn ToLower(self, r: rune) -> rune {\n        EXT\n    }\n\n    fn ToTitle(self, r: rune) -> rune {\n        EXT\n    }\n\n    fn ToUpper(self, r: rune) -> rune {\n        EXT\n    }\n}\n\ntype SpecialCase = [CaseRange];\n\nstruct CaseRange {\n    Lo: uint32,\n    Hi: uint32,\n    // Delta: d // TODO d is not exported so... why is it public?\n}\n\nstruct Range16 {\n    Lo: uint16,\n    Hi: uint16,\n    Stride: uint16,\n}\n\nstruct Range32 {\n    Lo: uint32,\n    Hi: uint32,\n    Stride: uint32,\n}\n\nstruct RangeTable {\n    R16: [Range16],\n    R32: [Range32],\n    LatinOffset: int,\n}\n"},"fmt":{"fmt.brg":"\nuse io;\n\nfn Printf(format: string, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\nfn Fprintf(w: io::Writer, format: string, a: VarArgs<any>) -> Result<int> {\n    EXT\n}\nfn Errorf(format: string, a: VarArgs<any>) -> error {\n    EXT\n}\nfn Println(a: VarArgs<any>) {\n    EXT\n}\n"},"reflect":{"reflect.brg":"\nfn DeepEqual<T, Y>(a: T, b: Y) -> bool {\n    EXT\n}\n"},"io":{"io.brg":"fn NopCloser(r: Reader) -> ReadCloser {\n    EXT\n}\n\nfn LimitReader(r: Reader, n: int64) -> Reader {\n    EXT\n}\n\nfn MultiReader(readers: VarArgs<Reader>) -> Reader {\n    EXT\n}\n\nfn TeeReader(r: Reader, w: Writer) -> Reader {\n    EXT\n}\n\nfn NewSectionReader(r: ReaderAt, off: int64, n: int64) -> &SectionReader {\n    EXT\n}\n\nfn MultiWriter(writers: VarArgs<Writer>) -> Writer {\n    EXT\n}\n\nfn Copy(dst: Writer, src: Reader) -> Result<int64> {\n    EXT\n}\n\nfn CopyBuffer(dst: Writer, src: Reader, buf: [byte]) -> Result<int64> {\n    EXT\n}\n\nfn CopyN(dst: Writer, src: Reader, n: int64) -> Result<int64> {\n    EXT\n}\n\nfn Pipe() -> (&PipeReader, &PipeWriter) {\n    EXT\n}\n\nfn ReadAll(r: Reader) -> Result<[byte]> {\n    EXT\n}\n\nfn ReadAtLeast(r: Reader, buf: [byte], min: int) -> Result<int> {\n    EXT\n}\n\nfn ReadFull(r: Reader, buf: [byte]) -> Result<int> {\n    EXT\n}\n\nfn WriteString(w: Writer, s: string) -> Result<int> {\n    EXT\n}\n\nimpl SectionReader {\n    fn Read(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn ReadAt(&self, p: [byte], off: int64) -> Result<int> {\n        EXT\n    }\n\n    fn Seek(&self, offset: int64, whence: int) -> Result<int64> {\n        EXT\n    }\n\n    fn Size(&self) -> int64 {\n        EXT\n    }\n}\n\nimpl LimitedReader {\n    fn Read(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n}\n\nimpl PipeReader {\n    fn Close(&self) -> error {\n        EXT\n    }\n\n    fn CloseWithError(&self, err: error) -> error {\n        EXT\n    }\n\n    fn Read(&self, data: [byte]) -> Result<int> {\n        EXT\n    }\n}\n\nimpl PipeWriter {\n    fn Close(&self) -> error {\n        EXT\n    }\n\n    fn CloseWithError(&self, err: error) -> error {\n        EXT\n    }\n\n    fn Write(&self, data: [byte]) -> Result<int> {\n        EXT\n    }\n}\n\ntrait ByteReader {\n    fn ReadByte() -> Result<byte>;\n}\n\ntrait ByteScanner: ByteReader {\n    fn UnreadByte() -> error;\n}\n\ntrait ByteWriter {\n    fn WriteByte(c: byte) -> error;\n}\n\ntrait Closer {\n    fn Close() -> error;\n}\n\nstruct LimitedReader {\n    R: Reader,\n    N: int64,\n}\n\nstruct PipeReader {}\n\nstruct PipeWriter {}\n\ntrait ReadCloser: Reader + Closer {}\n\ntrait ReadSeekCloser: Reader + Seeker + Closer {}\n\ntrait ReadSeeker: Reader + Seeker {}\n\ntrait ReadWriteCloser: Reader + Writer + Closer {}\n\ntrait ReadWriteSeeker: Reader + Writer + Seeker {}\n\ntrait ReadWriter: Reader + Writer {}\n\ntrait Reader {\n    fn Read(p: [byte]) -> Result<int>;\n}\n\ntrait ReaderAt {\n    fn ReadAt(p: [byte], off: int64) -> Result<int>;\n}\n\ntrait ReaderFrom {\n    fn ReadFrom(r: Reader) -> Result<int64>;\n}\n\ntrait RuneReader {\n    fn ReadRune() -> (rune, int, error);\n}\n\ntrait RuneScanner: RuneReader {\n    fn UnreadRune() -> error;\n}\n\nstruct SectionReader {}\n\ntrait Seeker {\n    fn Seek(offset: int64, whence: int) -> Result<int64>;\n}\n\ntrait StringWriter {\n    fn WriteString(s: string) -> Result<int>;\n}\n\ntrait WriteCloser: Writer + Closer {}\n\ntrait WriteSeeker: Writer + Seeker {}\n\ntrait Writer {\n    fn Write(p: [byte]) -> Result<int>;\n}\n\ntrait WriterAt {\n    fn WriteAt(p: [byte], off: int64) -> Result<int>;\n}\n\ntrait WriterTo {\n    fn WriteTo(w: Writer) -> Result<int64>;\n}\n"},"io/fs":{"fs.brg":"\nstruct FileMode {}\n\ntrait FileInfo {\n    fn Name() -> string;\n    fn Size() -> int64;\n    fn Mode() -> FileMode;\n    // fn ModTime() -> time.Time;\n    fn IsDir() -> bool;\n    fn Sys() -> any;\n}\n\nimpl FileMode {\n    fn IsRegular(&self) -> bool {\n        EXT\n    }\n}\n"},"math/rand":{"rand.brg":"fn New(src: Source) -> &Rand {\n    EXT\n}\n\nfn NewSource(seed: int64) -> Source {\n    EXT\n}\n\nfn NewZipf(r: &Rand, s: float64, v: float64, imax: uint64) -> &Zipf {\n    EXT\n}\n\nfn ExpFloat64() -> float64 {\n    EXT\n}\n\nfn Float32() -> float32 {\n    EXT\n}\n\nfn Float64() -> float64 {\n    EXT\n}\n\nfn Int() -> int {\n    EXT\n}\n\nfn Int31() -> int32 {\n    EXT\n}\n\nfn Int31n(n: int32) -> int32 {\n    EXT\n}\n\nfn Int63() -> int64 {\n    EXT\n}\n\nfn Int63n(n: int64) -> int64 {\n    EXT\n}\n\nfn Intn(n: int) -> int {\n    EXT\n}\n\nfn NormFloat64() -> float64 {\n    EXT\n}\n\nfn Perm(n: int) -> [int] {\n    EXT\n}\n\nfn Read(p: [byte]) -> Result<int> {\n    EXT\n}\n\nfn Seed(seed: int64) -> () {\n    EXT\n}\n\nfn Shuffle(n: int, swap: fn(i: int) -> ()) -> () {\n    EXT\n}\n\nfn Uint32() -> uint32 {\n    EXT\n}\n\nfn Uint64() -> uint64 {\n    EXT\n}\n\nimpl Rand {\n    fn ExpFloat64(&self) -> float64 {\n        EXT\n    }\n\n    fn Float32(&self) -> float32 {\n        EXT\n    }\n\n    fn Float64(&self) -> float64 {\n        EXT\n    }\n\n    fn Int(&self) -> int {\n        EXT\n    }\n\n    fn Int31(&self) -> int32 {\n        EXT\n    }\n\n    fn Int31n(&self, n: int32) -> int32 {\n        EXT\n    }\n\n    fn Int63(&self) -> int64 {\n        EXT\n    }\n\n    fn Int63n(&self, n: int64) -> int64 {\n        EXT\n    }\n\n    fn Intn(&self, n: int) -> int {\n        EXT\n    }\n\n    fn NormFloat64(&self) -> float64 {\n        EXT\n    }\n\n    fn Perm(&self, n: int) -> [int] {\n        EXT\n    }\n\n    fn Read(&self, p: [byte]) -> Result<int> {\n        EXT\n    }\n\n    fn Seed(&self, seed: int64) -> () {\n        EXT\n    }\n\n    fn Shuffle(&self, n: int, swap: fn(i: int) -> ()) -> () {\n        EXT\n    }\n\n    fn Uint32(&self) -> uint32 {\n        EXT\n    }\n\n    fn Uint64(&self) -> uint64 {\n        EXT\n    }\n}\n\nimpl Zipf {\n    fn Uint64(&self) -> uint64 {\n        EXT\n    }\n}\n\nstruct Rand {}\n\ntrait Source {\n    fn Int63() -> int64;\n    fn Seed(seed: int64) -> ();\n}\n\ntrait Source64: Source {\n    fn Uint64() -> uint64;\n}\n\nstruct Zipf {}\n"},"math":{"math.brg":"\nconst Pi: float64 = EXT;\n"},"time":{"time.brg":"fn ParseDuration(s: string) -> Result<Duration> {\n    EXT\n}\n\nfn Since(t: Time) -> Duration {\n    EXT\n}\n\nfn Until(t: Time) -> Duration {\n    EXT\n}\n\nfn FixedZone(name: string, offset: int) -> &Location {\n    EXT\n}\n\nfn LoadLocation(name: string) -> Result<&Location> {\n    EXT\n}\n\nfn LoadLocationFromTZData(name: string, data: [byte]) -> Result<&Location> {\n    EXT\n}\n\nfn NewTicker(d: Duration) -> &Ticker {\n    EXT\n}\n\nfn Date(\n    year: int,\n    month: Month,\n    day: int,\n    hour: int,\n    min: int,\n    sec: int,\n    nsec: int,\n    loc: &Location,\n) -> Time {\n    EXT\n}\n\nfn Now() -> Time {\n    EXT\n}\n\nfn Parse(layout: string, value: string) -> Result<Time> {\n    EXT\n}\n\nfn ParseInLocation(layout: string, value: string, loc: &Location) -> Result<Time> {\n    EXT\n}\n\nfn Unix(sec: int64, nsec: int64) -> Time {\n    EXT\n}\n\nfn UnixMicro(usec: int64) -> Time {\n    EXT\n}\n\nfn UnixMilli(msec: int64) -> Time {\n    EXT\n}\n\nfn AfterFunc(d: Duration, f: fn() -> ()) -> &Timer {\n    EXT\n}\n\nfn NewTimer(d: Duration) -> &Timer {\n    EXT\n}\n\nfn After(d: Duration) -> Receiver<Time> {\n    EXT\n}\n\nfn Sleep(d: Duration) -> () {\n    EXT\n}\n\nfn Tick(d: Duration) -> Receiver<Time> {\n    EXT\n}\n\nimpl ParseError {\n    fn Error(&self) -> string {\n        EXT\n    }\n}\n\nimpl Ticker {\n    fn Reset(&self, d: Duration) -> () {\n        EXT\n    }\n\n    fn Stop(&self) -> () {\n        EXT\n    }\n}\n\nimpl Time {\n    fn Add(self, d: Duration) -> Time {\n        EXT\n    }\n\n    fn AddDate(self, years: int, months: int, days: int) -> Time {\n        EXT\n    }\n\n    fn After(self, u: Time) -> bool {\n        EXT\n    }\n\n    fn AppendFormat(self, b: [byte], layout: string) -> [byte] {\n        EXT\n    }\n\n    fn Before(self, u: Time) -> bool {\n        EXT\n    }\n\n    fn Clock(self) -> int {\n        EXT\n    }\n\n    fn Date(self) -> (int, Month, int) {\n        EXT\n    }\n\n    fn Day(self) -> int {\n        EXT\n    }\n\n    fn Equal(self, u: Time) -> bool {\n        EXT\n    }\n\n    fn Format(self, layout: string) -> string {\n        EXT\n    }\n\n    fn GoString(self) -> string {\n        EXT\n    }\n\n    fn GobDecode(&self, data: [byte]) -> error {\n        EXT\n    }\n\n    fn GobEncode(self) -> Result<[byte]> {\n        EXT\n    }\n\n    fn Hour(self) -> int {\n        EXT\n    }\n\n    fn ISOWeek(self) -> int {\n        EXT\n    }\n\n    fn In(self, loc: &Location) -> Time {\n        EXT\n    }\n\n    fn IsDST(self) -> bool {\n        EXT\n    }\n\n    fn IsZero(self) -> bool {\n        EXT\n    }\n\n    fn Local(self) -> Time {\n        EXT\n    }\n\n    fn Location(self) -> &Location {\n        EXT\n    }\n\n    fn MarshalBinary(self) -> Result<[byte]> {\n        EXT\n    }\n\n    fn MarshalJSON(self) -> Result<[byte]> {\n        EXT\n    }\n\n    fn MarshalText(self) -> Result<[byte]> {\n        EXT\n    }\n\n    fn Minute(self) -> int {\n        EXT\n    }\n\n    fn Month(self) -> Month {\n        EXT\n    }\n\n    fn Nanosecond(self) -> int {\n        EXT\n    }\n\n    fn Round(self, d: Duration) -> Time {\n        EXT\n    }\n\n    fn Second(self) -> int {\n        EXT\n    }\n\n    fn String(self) -> string {\n        EXT\n    }\n\n    fn Sub(self, u: Time) -> Duration {\n        EXT\n    }\n\n    fn Truncate(self, d: Duration) -> Time {\n        EXT\n    }\n\n    fn UTC(self) -> Time {\n        EXT\n    }\n\n    fn Unix(self) -> int64 {\n        EXT\n    }\n\n    fn UnixMicro(self) -> int64 {\n        EXT\n    }\n\n    fn UnixMilli(self) -> int64 {\n        EXT\n    }\n\n    fn UnixNano(self) -> int64 {\n        EXT\n    }\n\n    fn UnmarshalBinary(&self, data: [byte]) -> error {\n        EXT\n    }\n\n    fn UnmarshalJSON(&self, data: [byte]) -> error {\n        EXT\n    }\n\n    fn UnmarshalText(&self, data: [byte]) -> error {\n        EXT\n    }\n\n    fn Weekday(self) -> Weekday {\n        EXT\n    }\n\n    fn Year(self) -> int {\n        EXT\n    }\n\n    fn YearDay(self) -> int {\n        EXT\n    }\n\n    fn Zone(self) -> (string, int) {\n        EXT\n    }\n\n    fn ZoneBounds(self) -> Time {\n        EXT\n    }\n}\n\nimpl Timer {\n    fn Reset(&self, d: Duration) -> bool {\n        EXT\n    }\n\n    fn Stop(&self) -> bool {\n        EXT\n    }\n}\n\nimpl Weekday {\n    fn String(self) -> string {\n        EXT\n    }\n}\n\nimpl Duration {\n    fn Abs(self) -> Duration {\n        EXT\n    }\n\n    fn Hours(self) -> float64 {\n        EXT\n    }\n\n    fn Microseconds(self) -> int64 {\n        EXT\n    }\n\n    fn Milliseconds(self) -> int64 {\n        EXT\n    }\n\n    fn Minutes(self) -> float64 {\n        EXT\n    }\n\n    fn Nanoseconds(self) -> int64 {\n        EXT\n    }\n\n    fn Round(self, m: Duration) -> Duration {\n        EXT\n    }\n\n    fn Seconds(self) -> float64 {\n        EXT\n    }\n\n    fn String(self) -> string {\n        EXT\n    }\n\n    fn Truncate(self, m: Duration) -> Duration {\n        EXT\n    }\n}\n\nimpl Location {\n    fn String(&self) -> string {\n        EXT\n    }\n}\n\nimpl Month {\n    fn String(self) -> string {\n        EXT\n    }\n}\n\nstruct Duration(int64);\n\nstruct Month(int);\n\nstruct Weekday(int);\n\nstruct Location {}\n\nstruct ParseError {\n    Layout: string,\n    Value: string,\n    LayoutElem: string,\n    ValueElem: string,\n    Message: string,\n}\n\nstruct Ticker {\n    C: Receiver<Time>,\n}\n\nstruct Time {}\n\nstruct Timer {\n    C: Receiver<Time>,\n}\n"},"log":{"log.brg":"\nfn Fatalf(format: string, a: VarArgs<any>) {\n    EXT\n}\n"},"os":{"os.brg":"\nuse io::fs;\n\nconst Stdin: File = File {};\n\n// TODO remove this when type aliases across packages work properly\n// type FileInfo = fs::FileInfo;\nstruct FileInfo {}\n\nstruct File {}\n\nimpl File {\n    fn Close(&mut self) -> error {\n        EXT\n    }\n    fn Write(&mut self, b: [byte]) -> Result<int> {\n        EXT\n    }\n    fn Read(&self, b: [byte]) -> Result<int> {\n        EXT\n    }\n}\n\nfn Create(name: string) -> Result<&mut File> {\n    EXT\n}\nfn LookupEnv(key: string) -> Option<string> {\n    EXT\n}\nfn Open(name: string) -> Result<&mut File> {\n    EXT\n}\nfn ReadFile(path: string) -> Result<[byte]> {\n    EXT\n}\n// TODO change this\n// fn Stat(name: string) -> Result<FileInfo> {\nfn Stat(name: string) -> Result<fs::FileInfo> {\n    EXT\n}\n"},"errors":{"errors.brg":"\nfn New(text: string) -> error {\n    EXT\n}\n"},"sync":{"sync.brg":"\nstruct Mutex {}\nstruct WaitGroup {}\n\nimpl Mutex {\n    fn Lock(&mut self) {\n        EXT\n    }\n\n    fn Unlock(&mut self) {\n        EXT\n    }\n}\n\nimpl WaitGroup {\n    fn Add(&mut self, delta: int) {\n        EXT\n    }\n    fn Done(&mut self) {\n        EXT\n    }\n    fn Wait(&mut self) {\n        EXT\n    }\n}\n"}}