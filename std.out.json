{"bufio":{"bufio.brg":"use io\n\n\nfn NewReadWriter  (r: *Reader, w: *Writer) -> *ReadWriter { EXT }\n\nfn NewReader  (rd: io.Reader) -> *Reader { EXT }\n\nfn NewReaderSize  (rd: io.Reader, size: int) -> *Reader { EXT }\n\nfn NewScanner  (r: io.Reader) -> *Scanner { EXT }\n\nfn NewWriter  (w: io.Writer) -> *Writer { EXT }\n\nfn NewWriterSize  (w: io.Writer, size: int) -> *Writer { EXT }\n\nfn ScanBytes  (data: [byte], atEOF: bool) -> (int, [byte], error) { EXT }\n\nfn ScanLines  (data: [byte], atEOF: bool) -> (int, [byte], error) { EXT }\n\nfn ScanRunes  (data: [byte], atEOF: bool) -> (int, [byte], error) { EXT }\n\nfn ScanWords  (data: [byte], atEOF: bool) -> (int, [byte], error) { EXT }\n\nimpl (self: Reader) {\n\nfn Buffered  () -> int { EXT }\n\nfn Discard  (n: int) -> Result<int> { EXT }\n\nfn Peek  (n: int) -> Result<[byte]> { EXT }\n\nfn Read  (p: [byte]) -> Result<int> { EXT }\n\nfn ReadByte  () -> Result<byte> { EXT }\n\nfn ReadBytes  (delim: byte) -> Result<[byte]> { EXT }\n\nfn ReadLine  () -> ([byte], bool, error) { EXT }\n\nfn ReadRune  () -> (rune, int, error) { EXT }\n\nfn ReadSlice  (delim: byte) -> Result<[byte]> { EXT }\n\nfn ReadString  (delim: byte) -> Result<string> { EXT }\n\nfn Reset  (r: io.Reader) -> () { EXT }\n\nfn Size  () -> int { EXT }\n\nfn UnreadByte  () -> error { EXT }\n\nfn UnreadRune  () -> error { EXT }\n\nfn WriteTo  (w: io.Writer) -> Result<int64> { EXT }\n\n}\n\nimpl (self: Scanner) {\n\nfn Buffer  (buf: [byte], max: int) -> () { EXT }\n\nfn Bytes  () -> [byte] { EXT }\n\nfn Err  () -> error { EXT }\n\nfn Scan  () -> bool { EXT }\n\nfn Split  (split: SplitFunc) -> () { EXT }\n\nfn Text  () -> string { EXT }\n\n}\n\nimpl (self: Writer) {\n\nfn Available  () -> int { EXT }\n\nfn AvailableBuffer  () -> [byte] { EXT }\n\nfn Buffered  () -> int { EXT }\n\nfn Flush  () -> error { EXT }\n\nfn ReadFrom  (r: io.Reader) -> Result<int64> { EXT }\n\nfn Reset  (w: io.Writer) -> () { EXT }\n\nfn Size  () -> int { EXT }\n\nfn Write  (p: [byte]) -> Result<int> { EXT }\n\nfn WriteByte  (c: byte) -> error { EXT }\n\nfn WriteRune  (r: rune) -> Result<int> { EXT }\n\nfn WriteString  (s: string) -> Result<int> { EXT }\n\n}\n\ntype SplitFunc = fn (data: [byte], atEOF: bool) -> (int, [byte], error)\n\nstruct ReadWriter{\n// skipping embedded field *Reader,\n// skipping embedded field *Writer\n}\n\nstruct Reader{\n\n}\n\nstruct Scanner{\n\n}\n\nstruct Writer{\n\n}"},"crypto":{"crypto.brg":"use io\nuse hash\n\n\nfn RegisterHash  (h: Hash, f: fn () -> hash.Hash) -> () { EXT }\n\nimpl (self: Hash) {\n\nfn Available  () -> bool { EXT }\n\nfn HashFunc  () -> Hash { EXT }\n\nfn New  () -> hash.Hash { EXT }\n\nfn Size  () -> int { EXT }\n\nfn String  () -> string { EXT }\n\n}\n\nstruct DecrypterOpts(any)\n\nstruct Hash(uint)\n\nstruct PrivateKey(any)\n\nstruct PublicKey(any)\n\ninterface Decrypter {\n\n  fn Public () -> PublicKey\n  fn Decrypt (rand: io.Reader, msg: [byte], opts: DecrypterOpts) -> Result<[byte]>\n}\n\ninterface Signer {\n\n  fn Public () -> PublicKey\n  fn Sign (rand: io.Reader, digest: [byte], opts: SignerOpts) -> Result<[byte]>\n}\n\ninterface SignerOpts {\n\n  fn HashFunc () -> Hash\n}"},"crypto/x509":{"x509.brg":"use pkix\nuse io\nuse time\nuse big\nuse asn1\nuse net\nuse net.url\nuse crypto\nuse pem\nuse ecdsa\nuse rsa\n\n\nfn CreateCertificate  (rand: io.Reader, template: *Certificate, parent: *Certificate, pub: any, priv: any) -> Result<[byte]> { EXT }\n\nfn CreateCertificateRequest  (rand: io.Reader, template: *CertificateRequest, priv: any) -> Result<[byte]> { EXT }\n\nfn CreateRevocationList  (rand: io.Reader, template: *RevocationList, issuer: *Certificate, priv: crypto.Signer) -> Result<[byte]> { EXT }\n\nfn DecryptPEMBlock  (b: *pem.Block, password: [byte]) -> Result<[byte]> { EXT }\n\nfn EncryptPEMBlock  (rand: io.Reader, blockType: string, data: [byte], password: [byte], alg: PEMCipher) -> Result<*pem.Block> { EXT }\n\nfn IsEncryptedPEMBlock  (b: *pem.Block) -> bool { EXT }\n\nfn MarshalECPrivateKey  (key: *ecdsa.PrivateKey) -> Result<[byte]> { EXT }\n\nfn MarshalPKCS1PrivateKey  (key: *rsa.PrivateKey) -> [byte] { EXT }\n\nfn MarshalPKCS1PublicKey  (key: *rsa.PublicKey) -> [byte] { EXT }\n\nfn MarshalPKCS8PrivateKey  (key: any) -> Result<[byte]> { EXT }\n\nfn MarshalPKIXPublicKey  (pub: any) -> Result<[byte]> { EXT }\n\nfn NewCertPool  () -> *CertPool { EXT }\n\nfn ParseCRL  (crlBytes: [byte]) -> Result<*pkix.CertificateList> { EXT }\n\nfn ParseCertificate  (der: [byte]) -> Result<*Certificate> { EXT }\n\nfn ParseCertificateRequest  (asn1Data: [byte]) -> Result<*CertificateRequest> { EXT }\n\nfn ParseCertificates  (der: [byte]) -> Result<[*Certificate]> { EXT }\n\nfn ParseDERCRL  (derBytes: [byte]) -> Result<*pkix.CertificateList> { EXT }\n\nfn ParseECPrivateKey  (der: [byte]) -> Result<*ecdsa.PrivateKey> { EXT }\n\nfn ParsePKCS1PrivateKey  (der: [byte]) -> Result<*rsa.PrivateKey> { EXT }\n\nfn ParsePKCS1PublicKey  (der: [byte]) -> Result<*rsa.PublicKey> { EXT }\n\nfn ParsePKCS8PrivateKey  (der: [byte]) -> Result<any> { EXT }\n\nfn ParsePKIXPublicKey  (derBytes: [byte]) -> Result<any> { EXT }\n\nfn ParseRevocationList  (der: [byte]) -> Result<*RevocationList> { EXT }\n\nfn SystemCertPool  () -> Result<*CertPool> { EXT }\n\nimpl (self: CertPool) {\n\nfn AddCert  (cert: *Certificate) -> () { EXT }\n\nfn AppendCertsFromPEM  (pemCerts: [byte]) -> bool { EXT }\n\nfn Clone  () -> *CertPool { EXT }\n\nfn Equal  (other: *CertPool) -> bool { EXT }\n\nfn Subjects  () -> [[byte]] { EXT }\n\n}\n\nimpl (self: Certificate) {\n\nfn CheckCRLSignature  (crl: *pkix.CertificateList) -> error { EXT }\n\nfn CheckSignature  (algo: SignatureAlgorithm, signed: [byte], signature: [byte]) -> error { EXT }\n\nfn CheckSignatureFrom  (parent: *Certificate) -> error { EXT }\n\nfn CreateCRL  (rand: io.Reader, priv: any, revokedCerts: [pkix.RevokedCertificate], now: time.Time, expiry: time.Time) -> Result<[byte]> { EXT }\n\nfn Equal  (other: *Certificate) -> bool { EXT }\n\nfn Verify  (opts: VerifyOptions) -> Result<[[*Certificate]]> { EXT }\n\nfn VerifyHostname  (h: string) -> error { EXT }\n\n}\n\nimpl (self: CertificateInvalidError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: CertificateRequest) {\n\nfn CheckSignature  () -> error { EXT }\n\n}\n\nimpl (self: ConstraintViolationError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: HostnameError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: InsecureAlgorithmError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: PublicKeyAlgorithm) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: RevocationList) {\n\nfn CheckSignatureFrom  (parent: *Certificate) -> error { EXT }\n\n}\n\nimpl (self: SignatureAlgorithm) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: SystemRootsError) {\n\nfn Error  () -> string { EXT }\n\nfn Unwrap  () -> error { EXT }\n\n}\n\nimpl (self: UnhandledCriticalExtension) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: UnknownAuthorityError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nstruct ExtKeyUsage(int)\n\nstruct InsecureAlgorithmError(SignatureAlgorithm)\n\nstruct InvalidReason(int)\n\nstruct KeyUsage(int)\n\nstruct PEMCipher(int)\n\nstruct PublicKeyAlgorithm(int)\n\nstruct SignatureAlgorithm(int)\n\nstruct CertPool{\n\n}\n\nstruct Certificate{\n  Raw: [byte],\n  RawTBSCertificate: [byte],\n  RawSubjectPublicKeyInfo: [byte],\n  RawSubject: [byte],\n  RawIssuer: [byte],\n  Signature: [byte],\n  SignatureAlgorithm: SignatureAlgorithm,\n  PublicKeyAlgorithm: PublicKeyAlgorithm,\n  PublicKey: any,\n  Version: int,\n  SerialNumber: *big.Int,\n  Issuer: pkix.Name,\n  Subject: pkix.Name,\n  NotBefore: time.Time,\n  KeyUsage: KeyUsage,\n  Extensions: [pkix.Extension],\n  ExtraExtensions: [pkix.Extension],\n  UnhandledCriticalExtensions: [asn1.ObjectIdentifier],\n  ExtKeyUsage: [ExtKeyUsage],\n  UnknownExtKeyUsage: [asn1.ObjectIdentifier],\n  BasicConstraintsValid: bool,\n  IsCA: bool,\n  MaxPathLen: int,\n  MaxPathLenZero: bool,\n  SubjectKeyId: [byte],\n  AuthorityKeyId: [byte],\n  OCSPServer: [string],\n  IssuingCertificateURL: [string],\n  DNSNames: [string],\n  EmailAddresses: [string],\n  IPAddresses: [net.IP],\n  URIs: [*url.URL],\n  PermittedDNSDomainsCritical: bool,\n  PermittedDNSDomains: [string],\n  ExcludedDNSDomains: [string],\n  PermittedIPRanges: [*net.IPNet],\n  ExcludedIPRanges: [*net.IPNet],\n  PermittedEmailAddresses: [string],\n  ExcludedEmailAddresses: [string],\n  PermittedURIDomains: [string],\n  ExcludedURIDomains: [string],\n  CRLDistributionPoints: [string],\n  PolicyIdentifiers: [asn1.ObjectIdentifier]\n}\n\nstruct CertificateInvalidError{\n  Cert: *Certificate,\n  Reason: InvalidReason,\n  Detail: string\n}\n\nstruct CertificateRequest{\n  Raw: [byte],\n  RawTBSCertificateRequest: [byte],\n  RawSubjectPublicKeyInfo: [byte],\n  RawSubject: [byte],\n  Version: int,\n  Signature: [byte],\n  SignatureAlgorithm: SignatureAlgorithm,\n  PublicKeyAlgorithm: PublicKeyAlgorithm,\n  PublicKey: any,\n  Subject: pkix.Name,\n  Attributes: [pkix.AttributeTypeAndValueSET],\n  Extensions: [pkix.Extension],\n  ExtraExtensions: [pkix.Extension],\n  DNSNames: [string],\n  EmailAddresses: [string],\n  IPAddresses: [net.IP],\n  URIs: [*url.URL]\n}\n\nstruct ConstraintViolationError{\n\n}\n\nstruct HostnameError{\n  Certificate: *Certificate,\n  Host: string\n}\n\nstruct RevocationList{\n  Raw: [byte],\n  RawTBSRevocationList: [byte],\n  RawIssuer: [byte],\n  Issuer: pkix.Name,\n  AuthorityKeyId: [byte],\n  Signature: [byte],\n  SignatureAlgorithm: SignatureAlgorithm,\n  RevokedCertificates: [pkix.RevokedCertificate],\n  Number: *big.Int,\n  ThisUpdate: time.Time,\n  NextUpdate: time.Time,\n  Extensions: [pkix.Extension],\n  ExtraExtensions: [pkix.Extension]\n}\n\nstruct SystemRootsError{\n  Err: error\n}\n\nstruct UnhandledCriticalExtension{\n\n}\n\nstruct UnknownAuthorityError{\n  Cert: *Certificate\n}\n\nstruct VerifyOptions{\n  DNSName: string,\n  Intermediates: *CertPool,\n  Roots: *CertPool,\n  CurrentTime: time.Time,\n  KeyUsages: [ExtKeyUsage],\n  MaxConstraintComparisions: int\n}"},"crypto/tls":{"tls.brg":"use crypto\n// use crypto.x509\nuse context\nuse net\nuse io\nuse time\n\n\nfn CipherSuiteName  (id: uint16) -> string { EXT }\n\nfn CipherSuites  () -> [*CipherSuite] { EXT }\n\nfn Client  (conn: net.Conn, config: *Config) -> *Conn { EXT }\n\nfn Dial  (network: string, addr: string, config: *Config) -> Result<*Conn> { EXT }\n\nfn DialWithDialer  (dialer: *net.Dialer, network: string, addr: string, config: *Config) -> Result<*Conn> { EXT }\n\nfn InsecureCipherSuites  () -> [*CipherSuite] { EXT }\n\nfn Listen  (network: string, laddr: string, config: *Config) -> Result<net.Listener> { EXT }\n\nfn LoadX509KeyPair  (certFile: string, keyFile: string) -> Result<Certificate> { EXT }\n\nfn NewLRUClientSessionCache  (capacity: int) -> ClientSessionCache { EXT }\n\nfn NewListener  (inner: net.Listener, config: *Config) -> net.Listener { EXT }\n\nfn Server  (conn: net.Conn, config: *Config) -> *Conn { EXT }\n\nfn X509KeyPair  (certPEMBlock: [byte], keyPEMBlock: [byte]) -> Result<Certificate> { EXT }\n\nimpl (self: CertificateRequestInfo) {\n\nfn Context  () -> context.Context { EXT }\n\nfn SupportsCertificate  (c: *Certificate) -> error { EXT }\n\n}\n\nimpl (self: ClientAuthType) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: ClientHelloInfo) {\n\nfn Context  () -> context.Context { EXT }\n\nfn SupportsCertificate  (c: *Certificate) -> error { EXT }\n\n}\n\nimpl (self: Config) {\n\nfn BuildNameToCertificate  () -> () { EXT }\n\nfn Clone  () -> *Config { EXT }\n\nfn SetSessionTicketKeys  (keys: [[byte]]) -> () { EXT }\n\n}\n\nimpl (self: Conn) {\n\nfn Close  () -> error { EXT }\n\nfn CloseWrite  () -> error { EXT }\n\nfn ConnectionState  () -> ConnectionState { EXT }\n\nfn Handshake  () -> error { EXT }\n\nfn HandshakeContext  (ctx: context.Context) -> error { EXT }\n\nfn LocalAddr  () -> net.Addr { EXT }\n\nfn NetConn  () -> net.Conn { EXT }\n\nfn OCSPResponse  () -> [byte] { EXT }\n\nfn Read  (b: [byte]) -> Result<int> { EXT }\n\nfn RemoteAddr  () -> net.Addr { EXT }\n\nfn SetDeadline  (t: time.Time) -> error { EXT }\n\nfn SetReadDeadline  (t: time.Time) -> error { EXT }\n\nfn SetWriteDeadline  (t: time.Time) -> error { EXT }\n\nfn VerifyHostname  (host: string) -> error { EXT }\n\nfn Write  (b: [byte]) -> Result<int> { EXT }\n\n}\n\nimpl (self: ConnectionState) {\n\nfn ExportKeyingMaterial  (label: string, context: [byte], length: int) -> Result<[byte]> { EXT }\n\n}\n\nimpl (self: CurveID) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: Dialer) {\n\nfn Dial  (network: string, addr: string) -> Result<net.Conn> { EXT }\n\nfn DialContext  (ctx: context.Context, network: string, addr: string) -> Result<net.Conn> { EXT }\n\n}\n\nimpl (self: RecordHeaderError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: SignatureScheme) {\n\nfn String  () -> string { EXT }\n\n}\n\nstruct ClientAuthType(int)\n\nstruct CurveID(uint16)\n\nstruct RenegotiationSupport(int)\n\nstruct SignatureScheme(uint16)\n\nstruct Certificate{\n  Certificate: [[byte]],\n  PrivateKey: crypto.PrivateKey,\n  SupportedSignatureAlgorithms: [SignatureScheme],\n  OCSPStaple: [byte],\n  SignedCertificateTimestamps: [[byte]],\n  Leaf: *any\n}\n\nstruct CertificateRequestInfo{\n  AcceptableCAs: [[byte]],\n  SignatureSchemes: [SignatureScheme],\n  Version: uint16\n}\n\nstruct CipherSuite{\n  ID: uint16,\n  Name: string,\n  SupportedVersions: [uint16],\n  Insecure: bool\n}\n\nstruct ClientHelloInfo{\n  CipherSuites: [uint16],\n  ServerName: string,\n  SupportedCurves: [CurveID],\n  SupportedPoints: [uint8],\n  SignatureSchemes: [SignatureScheme],\n  SupportedProtos: [string],\n  SupportedVersions: [uint16],\n  Conn: net.Conn\n}\n\ninterface ClientSessionCache {\n\n  fn Get (sessionKey: string) -> Option<*ClientSessionState>\n  fn Put (sessionKey: string, cs: *ClientSessionState) -> ()\n}\n\nstruct ClientSessionState{\n\n}\n\nstruct Config{\n  Rand: io.Reader,\n  Time: fn () -> time.Time,\n  Certificates: [Certificate],\n  NameToCertificate: Map<string, *Certificate>,\n  GetCertificate: fn (param0: *ClientHelloInfo) -> Result<*Certificate>,\n  GetClientCertificate: fn (param0: *CertificateRequestInfo) -> Result<*Certificate>,\n  GetConfigForClient: fn (param0: *ClientHelloInfo) -> Result<*Config>,\n  VerifyPeerCertificate: fn (rawCerts: [[byte]], verifiedChains: [[*any]]) -> error,\n  VerifyConnection: fn (param0: ConnectionState) -> error,\n  RootCAs: *any,\n  NextProtos: [string],\n  ServerName: string,\n  ClientAuth: ClientAuthType,\n  ClientCAs: *any,\n  InsecureSkipVerify: bool,\n  CipherSuites: [uint16],\n  PreferServerCipherSuites: bool,\n  SessionTicketsDisabled: bool,\n  SessionTicketKey: [byte],\n  ClientSessionCache: ClientSessionCache,\n  MinVersion: uint16,\n  MaxVersion: uint16,\n  CurvePreferences: [CurveID],\n  DynamicRecordSizingDisabled: bool,\n  Renegotiation: RenegotiationSupport,\n  KeyLogWriter: io.Writer\n}\n\nstruct Conn{\n\n}\n\nstruct ConnectionState{\n  Version: uint16,\n  HandshakeComplete: bool,\n  DidResume: bool,\n  CipherSuite: uint16,\n  NegotiatedProtocol: string,\n  NegotiatedProtocolIsMutual: bool,\n  ServerName: string,\n  PeerCertificates: [*any],\n  VerifiedChains: [[*any]],\n  SignedCertificateTimestamps: [[byte]],\n  OCSPResponse: [byte],\n  TLSUnique: [byte]\n}\n\nstruct Dialer{\n  NetDialer: *net.Dialer,\n  Config: *Config\n}\n\nstruct RecordHeaderError{\n  Msg: string,\n  RecordHeader: [byte],\n  Conn: net.Conn\n}"},"strconv":{"strconv.brg":"fn AppendBool  (dst: [byte], b: bool) -> [byte] { EXT }\n\nfn AppendFloat  (dst: [byte], f: float64, fmt: byte, prec: int, bitSize: int) -> [byte] { EXT }\n\nfn AppendInt  (dst: [byte], i: int64, base: int) -> [byte] { EXT }\n\nfn AppendQuote  (dst: [byte], s: string) -> [byte] { EXT }\n\nfn AppendQuoteRune  (dst: [byte], r: rune) -> [byte] { EXT }\n\nfn AppendQuoteRuneToASCII  (dst: [byte], r: rune) -> [byte] { EXT }\n\nfn AppendQuoteRuneToGraphic  (dst: [byte], r: rune) -> [byte] { EXT }\n\nfn AppendQuoteToASCII  (dst: [byte], s: string) -> [byte] { EXT }\n\nfn AppendQuoteToGraphic  (dst: [byte], s: string) -> [byte] { EXT }\n\nfn AppendUint  (dst: [byte], i: uint64, base: int) -> [byte] { EXT }\n\nfn Atoi  (s: string) -> Result<int> { EXT }\n\nfn CanBackquote  (s: string) -> bool { EXT }\n\nfn FormatBool  (b: bool) -> string { EXT }\n\nfn FormatComplex  (c: complex128, fmt: byte, prec: int, bitSize: int) -> string { EXT }\n\nfn FormatFloat  (f: float64, fmt: byte, prec: int, bitSize: int) -> string { EXT }\n\nfn FormatInt  (i: int64, base: int) -> string { EXT }\n\nfn FormatUint  (i: uint64, base: int) -> string { EXT }\n\nfn IsGraphic  (r: rune) -> bool { EXT }\n\nfn IsPrint  (r: rune) -> bool { EXT }\n\nfn Itoa  (i: int) -> string { EXT }\n\nfn ParseBool  (str: string) -> Result<bool> { EXT }\n\nfn ParseComplex  (s: string, bitSize: int) -> Result<complex128> { EXT }\n\nfn ParseFloat  (s: string, bitSize: int) -> Result<float64> { EXT }\n\nfn ParseInt  (s: string, base: int, bitSize: int) -> Result<int64> { EXT }\n\nfn ParseUint  (s: string, base: int, bitSize: int) -> Result<uint64> { EXT }\n\nfn Quote  (s: string) -> string { EXT }\n\nfn QuoteRune  (r: rune) -> string { EXT }\n\nfn QuoteRuneToASCII  (r: rune) -> string { EXT }\n\nfn QuoteRuneToGraphic  (r: rune) -> string { EXT }\n\nfn QuoteToASCII  (s: string) -> string { EXT }\n\nfn QuoteToGraphic  (s: string) -> string { EXT }\n\nfn QuotedPrefix  (s: string) -> Result<string> { EXT }\n\nfn Unquote  (s: string) -> Result<string> { EXT }\n\nfn UnquoteChar  (s: string, quote: byte) -> (rune, bool, string, error) { EXT }\n\nimpl (self: NumError) {\n\nfn Error  () -> string { EXT }\n\nfn Unwrap  () -> error { EXT }\n\n}\n\nstruct NumError{\n  Func: string,\n  Num: string,\n  Err: error\n}"},"strings":{"strings.brg":"use io\nuse unicode\n\n\nfn Clone  (s: string) -> string { EXT }\n\nfn Compare  (a: string, b: string) -> int { EXT }\n\nfn Contains  (s: string, substr: string) -> bool { EXT }\n\nfn ContainsAny  (s: string, chars: string) -> bool { EXT }\n\nfn ContainsRune  (s: string, r: rune) -> bool { EXT }\n\nfn Count  (s: string, substr: string) -> int { EXT }\n\nfn Cut  (s: string, sep: string) -> Option<string> { EXT }\n\nfn EqualFold  (s: string, t: string) -> bool { EXT }\n\nfn Fields  (s: string) -> [string] { EXT }\n\nfn FieldsFunc  (s: string, f: fn (param0: rune) -> bool) -> [string] { EXT }\n\nfn HasPrefix  (s: string, prefix: string) -> bool { EXT }\n\nfn HasSuffix  (s: string, suffix: string) -> bool { EXT }\n\nfn Index  (s: string, substr: string) -> int { EXT }\n\nfn IndexAny  (s: string, chars: string) -> int { EXT }\n\nfn IndexByte  (s: string, c: byte) -> int { EXT }\n\nfn IndexFunc  (s: string, f: fn (param0: rune) -> bool) -> int { EXT }\n\nfn IndexRune  (s: string, r: rune) -> int { EXT }\n\nfn Join  (elems: [string], sep: string) -> string { EXT }\n\nfn LastIndex  (s: string, substr: string) -> int { EXT }\n\nfn LastIndexAny  (s: string, chars: string) -> int { EXT }\n\nfn LastIndexByte  (s: string, c: byte) -> int { EXT }\n\nfn LastIndexFunc  (s: string, f: fn (param0: rune) -> bool) -> int { EXT }\n\nfn Map  (mapping: fn (param0: rune) -> rune, s: string) -> string { EXT }\n\nfn NewReader  (s: string) -> *Reader { EXT }\n\nfn NewReplacer  (oldnew: VarArgs<string>) -> *Replacer { EXT }\n\nfn Repeat  (s: string, count: int) -> string { EXT }\n\nfn Replace  (s: string, old: string, new: string, n: int) -> string { EXT }\n\nfn ReplaceAll  (s: string, old: string, new: string) -> string { EXT }\n\nfn Split  (s: string, sep: string) -> [string] { EXT }\n\nfn SplitAfter  (s: string, sep: string) -> [string] { EXT }\n\nfn SplitAfterN  (s: string, sep: string, n: int) -> [string] { EXT }\n\nfn SplitN  (s: string, sep: string, n: int) -> [string] { EXT }\n\nfn Title  (s: string) -> string { EXT }\n\nfn ToLower  (s: string) -> string { EXT }\n\nfn ToLowerSpecial  (c: unicode.SpecialCase, s: string) -> string { EXT }\n\nfn ToTitle  (s: string) -> string { EXT }\n\nfn ToTitleSpecial  (c: unicode.SpecialCase, s: string) -> string { EXT }\n\nfn ToUpper  (s: string) -> string { EXT }\n\nfn ToUpperSpecial  (c: unicode.SpecialCase, s: string) -> string { EXT }\n\nfn ToValidUTF8  (s: string, replacement: string) -> string { EXT }\n\nfn Trim  (s: string, cutset: string) -> string { EXT }\n\nfn TrimFunc  (s: string, f: fn (param0: rune) -> bool) -> string { EXT }\n\nfn TrimLeft  (s: string, cutset: string) -> string { EXT }\n\nfn TrimLeftFunc  (s: string, f: fn (param0: rune) -> bool) -> string { EXT }\n\nfn TrimPrefix  (s: string, prefix: string) -> string { EXT }\n\nfn TrimRight  (s: string, cutset: string) -> string { EXT }\n\nfn TrimRightFunc  (s: string, f: fn (param0: rune) -> bool) -> string { EXT }\n\nfn TrimSpace  (s: string) -> string { EXT }\n\nfn TrimSuffix  (s: string, suffix: string) -> string { EXT }\n\nimpl (self: Builder) {\n\nfn Cap  () -> int { EXT }\n\nfn Grow  (n: int) -> () { EXT }\n\nfn Len  () -> int { EXT }\n\nfn Reset  () -> () { EXT }\n\nfn String  () -> string { EXT }\n\nfn Write  (p: [byte]) -> Result<int> { EXT }\n\nfn WriteByte  (c: byte) -> error { EXT }\n\nfn WriteRune  (r: rune) -> Result<int> { EXT }\n\nfn WriteString  (s: string) -> Result<int> { EXT }\n\n}\n\nimpl (self: Reader) {\n\nfn Len  () -> int { EXT }\n\nfn Read  (b: [byte]) -> Result<int> { EXT }\n\nfn ReadAt  (b: [byte], off: int64) -> Result<int> { EXT }\n\nfn ReadByte  () -> Result<byte> { EXT }\n\nfn ReadRune  () -> (rune, int, error) { EXT }\n\nfn Reset  (s: string) -> () { EXT }\n\nfn Seek  (offset: int64, whence: int) -> Result<int64> { EXT }\n\nfn Size  () -> int64 { EXT }\n\nfn UnreadByte  () -> error { EXT }\n\nfn UnreadRune  () -> error { EXT }\n\nfn WriteTo  (w: io.Writer) -> Result<int64> { EXT }\n\n}\n\nimpl (self: Replacer) {\n\nfn Replace  (s: string) -> string { EXT }\n\nfn WriteString  (w: io.Writer, s: string) -> Result<int> { EXT }\n\n}\n\nstruct Builder{\n\n}\n\nstruct Reader{\n\n}\n\nstruct Replacer{\n\n}"},"net/textproto":{"textproto.brg":"use io\nuse bufio\n\n\nfn CanonicalMIMEHeaderKey  (s: string) -> string { EXT }\n\nfn Dial  (network: string, addr: string) -> Result<*Conn> { EXT }\n\nfn NewConn  (conn: io.ReadWriteCloser) -> *Conn { EXT }\n\nfn NewReader  (r: *bufio.Reader) -> *Reader { EXT }\n\nfn NewWriter  (w: *bufio.Writer) -> *Writer { EXT }\n\nfn TrimBytes  (b: [byte]) -> [byte] { EXT }\n\nfn TrimString  (s: string) -> string { EXT }\n\nimpl (self: Conn) {\n\nfn Close  () -> error { EXT }\n\nfn Cmd  (format: string, args: VarArgs<any>) -> Result<uint> { EXT }\n\n}\n\nimpl (self: Error) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: MIMEHeader) {\n\nfn Add  (key: string, value: string) -> () { EXT }\n\nfn Del  (key: string) -> () { EXT }\n\nfn Get  (key: string) -> string { EXT }\n\nfn Set  (key: string, value: string) -> () { EXT }\n\nfn Values  (key: string) -> [string] { EXT }\n\n}\n\nimpl (self: Pipeline) {\n\nfn EndRequest  (id: uint) -> () { EXT }\n\nfn EndResponse  (id: uint) -> () { EXT }\n\nfn Next  () -> uint { EXT }\n\nfn StartRequest  (id: uint) -> () { EXT }\n\nfn StartResponse  (id: uint) -> () { EXT }\n\n}\n\nimpl (self: ProtocolError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: Reader) {\n\nfn DotReader  () -> io.Reader { EXT }\n\nfn ReadCodeLine  (expectCode: int) -> (int, string, error) { EXT }\n\nfn ReadContinuedLine  () -> Result<string> { EXT }\n\nfn ReadContinuedLineBytes  () -> Result<[byte]> { EXT }\n\nfn ReadDotBytes  () -> Result<[byte]> { EXT }\n\nfn ReadDotLines  () -> Result<[string]> { EXT }\n\nfn ReadLine  () -> Result<string> { EXT }\n\nfn ReadLineBytes  () -> Result<[byte]> { EXT }\n\nfn ReadMIMEHeader  () -> Result<MIMEHeader> { EXT }\n\nfn ReadResponse  (expectCode: int) -> (int, string, error) { EXT }\n\n}\n\nimpl (self: Writer) {\n\nfn DotWriter  () -> io.WriteCloser { EXT }\n\nfn PrintfLine  (format: string, args: VarArgs<any>) -> error { EXT }\n\n}\n\ntype MIMEHeader = Map<string, [string]>\n\nstruct ProtocolError(string)\n\nstruct Conn{\n// skipping embedded field Reader,\n// skipping embedded field Writer,\n// skipping embedded field Pipeline\n}\n\nstruct Error{\n  Code: int,\n  Msg: string\n}\n\nstruct Pipeline{\n\n}\n\nstruct Reader{\n  R: *bufio.Reader\n}\n\nstruct Writer{\n  W: *bufio.Writer\n}"},"net/url":{"url.brg":"fn JoinPath  (base: string, elem: VarArgs<string>) -> Result<string> { EXT }\n\nfn Parse  (rawURL: string) -> Result<*URL> { EXT }\n\nfn ParseQuery  (query: string) -> Result<Values> { EXT }\n\nfn ParseRequestURI  (rawURL: string) -> Result<*URL> { EXT }\n\nfn PathEscape  (s: string) -> string { EXT }\n\nfn PathUnescape  (s: string) -> Result<string> { EXT }\n\nfn QueryEscape  (s: string) -> string { EXT }\n\nfn QueryUnescape  (s: string) -> Result<string> { EXT }\n\nfn User  (username: string) -> *Userinfo { EXT }\n\nfn UserPassword  (username: string, password: string) -> *Userinfo { EXT }\n\nimpl (self: Error) {\n\nfn Error  () -> string { EXT }\n\nfn Temporary  () -> bool { EXT }\n\nfn Timeout  () -> bool { EXT }\n\nfn Unwrap  () -> error { EXT }\n\n}\n\nimpl (self: EscapeError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: InvalidHostError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: URL) {\n\nfn EscapedFragment  () -> string { EXT }\n\nfn EscapedPath  () -> string { EXT }\n\nfn Hostname  () -> string { EXT }\n\nfn IsAbs  () -> bool { EXT }\n\nfn JoinPath  (elem: VarArgs<string>) -> *URL { EXT }\n\nfn MarshalBinary  () -> Result<[byte]> { EXT }\n\nfn Parse  (ref: string) -> Result<*URL> { EXT }\n\nfn Port  () -> string { EXT }\n\nfn Query  () -> Values { EXT }\n\nfn Redacted  () -> string { EXT }\n\nfn RequestURI  () -> string { EXT }\n\nfn ResolveReference  (ref: *URL) -> *URL { EXT }\n\nfn String  () -> string { EXT }\n\nfn UnmarshalBinary  (text: [byte]) -> error { EXT }\n\n}\n\nimpl (self: Userinfo) {\n\nfn Password  () -> Option<string> { EXT }\n\nfn String  () -> string { EXT }\n\nfn Username  () -> string { EXT }\n\n}\n\nimpl (self: Values) {\n\nfn Add  (key: string, value: string) -> () { EXT }\n\nfn Del  (key: string) -> () { EXT }\n\nfn Encode  () -> string { EXT }\n\nfn Get  (key: string) -> string { EXT }\n\nfn Has  (key: string) -> bool { EXT }\n\nfn Set  (key: string, value: string) -> () { EXT }\n\n}\n\ntype Values = Map<string, [string]>\n\nstruct EscapeError(string)\n\nstruct InvalidHostError(string)\n\nstruct Error{\n  Op: string,\n  URL: string,\n  Err: error\n}\n\nstruct URL{\n  Scheme: string,\n  Opaque: string,\n  User: *Userinfo,\n  Host: string,\n  Path: string,\n  RawPath: string,\n  OmitHost: bool,\n  ForceQuery: bool,\n  RawQuery: string,\n  Fragment: string,\n  RawFragment: string\n}\n\nstruct Userinfo{\n\n}"},"net/http":{"http.brg":"use io\nuse net.url\nuse time\nuse io.fs\nuse net\nuse bufio\nuse context\nuse mime.multipart\nuse crypto.tls\nuse log\n\n\nfn AllowQuerySemicolons  (h: Handler) -> Handler { EXT }\n\nfn CanonicalHeaderKey  (s: string) -> string { EXT }\n\nfn DetectContentType  (data: [byte]) -> string { EXT }\n\nfn Error  (w: ResponseWriter, error: string, code: int) -> () { EXT }\n\nfn FS  (fsys: fs.FS) -> FileSystem { EXT }\n\nfn FileServer  (root: FileSystem) -> Handler { EXT }\n\nfn Get  (url: string) -> Result<*Response> { EXT }\n\nfn Handle  (pattern: string, handler: Handler) -> () { EXT }\n\nfn HandleFunc  (pattern: string, handler: fn (param0: ResponseWriter, param1: *Request) -> ()) -> () { EXT }\n\nfn Head  (url: string) -> Result<*Response> { EXT }\n\nfn ListenAndServe  (addr: string, handler: Handler) -> error { EXT }\n\nfn ListenAndServeTLS  (addr: string, certFile: string, keyFile: string, handler: Handler) -> error { EXT }\n\nfn MaxBytesHandler  (h: Handler, n: int64) -> Handler { EXT }\n\nfn MaxBytesReader  (w: ResponseWriter, r: io.ReadCloser, n: int64) -> io.ReadCloser { EXT }\n\nfn NewFileTransport  (fs: FileSystem) -> RoundTripper { EXT }\n\nfn NewRequest  (method: string, url: string, body: io.Reader) -> Result<*Request> { EXT }\n\nfn NewRequestWithContext  (ctx: context.Context, method: string, url: string, body: io.Reader) -> Result<*Request> { EXT }\n\nfn NewServeMux  () -> *ServeMux { EXT }\n\nfn NotFound  (w: ResponseWriter, r: *Request) -> () { EXT }\n\nfn NotFoundHandler  () -> Handler { EXT }\n\nfn ParseHTTPVersion  (vers: string) -> Option<int> { EXT }\n\nfn ParseTime  (text: string) -> Result<time.Time> { EXT }\n\nfn Post  (url: string, contentType: string, body: io.Reader) -> Result<*Response> { EXT }\n\nfn PostForm  (url: string, data: url.Values) -> Result<*Response> { EXT }\n\nfn ProxyFromEnvironment  (req: *Request) -> Result<*url.URL> { EXT }\n\nfn ProxyURL  (fixedURL: *url.URL) -> fn (param0: *Request) -> Result<*url.URL> { EXT }\n\nfn ReadRequest  (b: *bufio.Reader) -> Result<*Request> { EXT }\n\nfn ReadResponse  (r: *bufio.Reader, req: *Request) -> Result<*Response> { EXT }\n\nfn Redirect  (w: ResponseWriter, r: *Request, url: string, code: int) -> () { EXT }\n\nfn RedirectHandler  (url: string, code: int) -> Handler { EXT }\n\nfn Serve  (l: net.Listener, handler: Handler) -> error { EXT }\n\nfn ServeContent  (w: ResponseWriter, req: *Request, name: string, modtime: time.Time, content: io.ReadSeeker) -> () { EXT }\n\nfn ServeFile  (w: ResponseWriter, r: *Request, name: string) -> () { EXT }\n\nfn ServeTLS  (l: net.Listener, handler: Handler, certFile: string, keyFile: string) -> error { EXT }\n\nfn SetCookie  (w: ResponseWriter, cookie: *Cookie) -> () { EXT }\n\nfn StatusText  (code: int) -> string { EXT }\n\nfn StripPrefix  (prefix: string, h: Handler) -> Handler { EXT }\n\nfn TimeoutHandler  (h: Handler, dt: time.Duration, msg: string) -> Handler { EXT }\n\nimpl (self: Client) {\n\nfn CloseIdleConnections  () -> () { EXT }\n\nfn Do  (req: *Request) -> Result<*Response> { EXT }\n\nfn Get  (url: string) -> Result<*Response> { EXT }\n\nfn Head  (url: string) -> Result<*Response> { EXT }\n\nfn Post  (url: string, contentType: string, body: io.Reader) -> Result<*Response> { EXT }\n\nfn PostForm  (url: string, data: url.Values) -> Result<*Response> { EXT }\n\n}\n\nimpl (self: ConnState) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: Cookie) {\n\nfn String  () -> string { EXT }\n\nfn Valid  () -> error { EXT }\n\n}\n\nimpl (self: Dir) {\n\nfn Open  (name: string) -> Result<File> { EXT }\n\n}\n\nimpl (self: HandlerFunc) {\n\nfn ServeHTTP  (w: ResponseWriter, r: *Request) -> () { EXT }\n\n}\n\nimpl (self: Header) {\n\nfn Add  (key: string, value: string) -> () { EXT }\n\nfn Clone  () -> Header { EXT }\n\nfn Del  (key: string) -> () { EXT }\n\nfn Get  (key: string) -> string { EXT }\n\nfn Set  (key: string, value: string) -> () { EXT }\n\nfn Values  (key: string) -> [string] { EXT }\n\nfn Write  (w: io.Writer) -> error { EXT }\n\nfn WriteSubset  (w: io.Writer, exclude: Map<string, bool>) -> error { EXT }\n\n}\n\nimpl (self: MaxBytesError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: ProtocolError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: Request) {\n\nfn AddCookie  (c: *Cookie) -> () { EXT }\n\nfn BasicAuth  () -> Option<string> { EXT }\n\nfn Clone  (ctx: context.Context) -> *Request { EXT }\n\nfn Context  () -> context.Context { EXT }\n\nfn Cookie  (name: string) -> Result<*Cookie> { EXT }\n\nfn Cookies  () -> [*Cookie] { EXT }\n\nfn FormFile  (key: string) -> (multipart.File, *multipart.FileHeader, error) { EXT }\n\nfn FormValue  (key: string) -> string { EXT }\n\nfn MultipartReader  () -> Result<*multipart.Reader> { EXT }\n\nfn ParseForm  () -> error { EXT }\n\nfn ParseMultipartForm  (maxMemory: int64) -> error { EXT }\n\nfn PostFormValue  (key: string) -> string { EXT }\n\nfn ProtoAtLeast  (major: int, minor: int) -> bool { EXT }\n\nfn Referer  () -> string { EXT }\n\nfn SetBasicAuth  (username: string, password: string) -> () { EXT }\n\nfn UserAgent  () -> string { EXT }\n\nfn WithContext  (ctx: context.Context) -> *Request { EXT }\n\nfn Write  (w: io.Writer) -> error { EXT }\n\nfn WriteProxy  (w: io.Writer) -> error { EXT }\n\n}\n\nimpl (self: Response) {\n\nfn Cookies  () -> [*Cookie] { EXT }\n\nfn Location  () -> Result<*url.URL> { EXT }\n\nfn ProtoAtLeast  (major: int, minor: int) -> bool { EXT }\n\nfn Write  (w: io.Writer) -> error { EXT }\n\n}\n\nimpl (self: ServeMux) {\n\nfn Handle  (pattern: string, handler: Handler) -> () { EXT }\n\nfn HandleFunc  (pattern: string, handler: fn (param0: ResponseWriter, param1: *Request) -> ()) -> () { EXT }\n\nfn Handler  (r: *Request) -> (Handler, string) { EXT }\n\nfn ServeHTTP  (w: ResponseWriter, r: *Request) -> () { EXT }\n\n}\n\nimpl (self: Server) {\n\nfn Close  () -> error { EXT }\n\nfn ListenAndServe  () -> error { EXT }\n\nfn ListenAndServeTLS  (certFile: string, keyFile: string) -> error { EXT }\n\nfn RegisterOnShutdown  (f: fn () -> ()) -> () { EXT }\n\nfn Serve  (l: net.Listener) -> error { EXT }\n\nfn ServeTLS  (l: net.Listener, certFile: string, keyFile: string) -> error { EXT }\n\nfn SetKeepAlivesEnabled  (v: bool) -> () { EXT }\n\nfn Shutdown  (ctx: context.Context) -> error { EXT }\n\n}\n\nimpl (self: Transport) {\n\nfn CancelRequest  (req: *Request) -> () { EXT }\n\nfn Clone  () -> *Transport { EXT }\n\nfn CloseIdleConnections  () -> () { EXT }\n\nfn RegisterProtocol  (scheme: string, rt: RoundTripper) -> () { EXT }\n\nfn RoundTrip  (req: *Request) -> Result<*Response> { EXT }\n\n}\n\ntype HandlerFunc = fn (param0: ResponseWriter, param1: *Request) -> ()\n\ntype Header = Map<string, [string]>\n\nstruct ConnState(int)\n\nstruct Dir(string)\n\nstruct SameSite(int)\n\nstruct Client{\n  Transport: RoundTripper,\n  CheckRedirect: fn (req: *Request, via: [*Request]) -> error,\n  Jar: CookieJar,\n  Timeout: time.Duration\n}\n\ninterface CloseNotifier {\n\n  fn CloseNotify () -> Receiver<bool>\n}\n\nstruct Cookie{\n  Name: string,\n  Value: string,\n  Path: string,\n  Domain: string,\n  Expires: time.Time,\n  RawExpires: string,\n  MaxAge: int,\n  Secure: bool,\n  HttpOnly: bool,\n  SameSite: SameSite,\n  Raw: string,\n  Unparsed: [string]\n}\n\ninterface CookieJar {\n\n  fn SetCookies (u: *url.URL, cookies: [*Cookie]) -> ()\n  fn Cookies (u: *url.URL) -> [*Cookie]\n}\n\ninterface File {\nimpl io.Closer\nimpl io.Reader\nimpl io.Seeker\n  fn Readdir (count: int) -> Result<[fs.FileInfo]>\n  fn Stat () -> Result<fs.FileInfo>\n}\n\ninterface FileSystem {\n\n  fn Open (name: string) -> Result<File>\n}\n\ninterface Flusher {\n\n  fn Flush () -> ()\n}\n\ninterface Handler {\n\n  fn ServeHTTP (param0: ResponseWriter, param1: *Request) -> ()\n}\n\ninterface Hijacker {\n\n  fn Hijack () -> (net.Conn, *bufio.ReadWriter, error)\n}\n\nstruct MaxBytesError{\n  Limit: int64\n}\n\nstruct ProtocolError{\n  ErrorString: string\n}\n\nstruct PushOptions{\n  Method: string,\n  Header: Header\n}\n\ninterface Pusher {\n\n  fn Push (target: string, opts: *PushOptions) -> error\n}\n\nstruct Request{\n  Method: string,\n  URL: *url.URL,\n  Proto: string,\n  ProtoMajor: int,\n  ProtoMinor: int,\n  Header: Header,\n  Body: io.ReadCloser,\n  GetBody: fn () -> Result<io.ReadCloser>,\n  ContentLength: int64,\n  TransferEncoding: [string],\n  Close: bool,\n  Host: string,\n  Form: url.Values,\n  PostForm: url.Values,\n  MultipartForm: *multipart.Form,\n  Trailer: Header,\n  RemoteAddr: string,\n  RequestURI: string,\n  TLS: *tls.ConnectionState,\n  Cancel: Receiver<()>,\n  Response: *Response\n}\n\nstruct Response{\n  Status: string,\n  StatusCode: int,\n  Proto: string,\n  ProtoMajor: int,\n  ProtoMinor: int,\n  Header: Header,\n  Body: io.ReadCloser,\n  ContentLength: int64,\n  TransferEncoding: [string],\n  Close: bool,\n  Uncompressed: bool,\n  Trailer: Header,\n  Request: *Request,\n  TLS: *tls.ConnectionState\n}\n\ninterface ResponseWriter {\n\n  fn Header () -> Header\n  fn Write (param0: [byte]) -> Result<int>\n  fn WriteHeader (statusCode: int) -> ()\n}\n\ninterface RoundTripper {\n\n  fn RoundTrip (param0: *Request) -> Result<*Response>\n}\n\nstruct ServeMux{\n\n}\n\nstruct Server{\n  Addr: string,\n  Handler: Handler,\n  TLSConfig: *tls.Config,\n  ReadTimeout: time.Duration,\n  ReadHeaderTimeout: time.Duration,\n  WriteTimeout: time.Duration,\n  IdleTimeout: time.Duration,\n  MaxHeaderBytes: int,\n  TLSNextProto: Map<string, fn (param0: *Server, param1: *tls.Conn, param2: Handler) -> ()>,\n  ConnState: fn (param0: net.Conn, param1: ConnState) -> (),\n  ErrorLog: *log.Logger,\n  BaseContext: fn (param0: net.Listener) -> context.Context,\n  ConnContext: fn (ctx: context.Context, c: net.Conn) -> context.Context\n}\n\nstruct Transport{\n  Proxy: fn (param0: *Request) -> Result<*url.URL>,\n  DialContext: fn (ctx: context.Context, network: string, addr: string) -> Result<net.Conn>,\n  Dial: fn (network: string, addr: string) -> Result<net.Conn>,\n  DialTLSContext: fn (ctx: context.Context, network: string, addr: string) -> Result<net.Conn>,\n  DialTLS: fn (network: string, addr: string) -> Result<net.Conn>,\n  TLSClientConfig: *tls.Config,\n  TLSHandshakeTimeout: time.Duration,\n  DisableKeepAlives: bool,\n  DisableCompression: bool,\n  MaxIdleConns: int,\n  MaxIdleConnsPerHost: int,\n  MaxConnsPerHost: int,\n  IdleConnTimeout: time.Duration,\n  ResponseHeaderTimeout: time.Duration,\n  ExpectContinueTimeout: time.Duration,\n  TLSNextProto: Map<string, fn (authority: string, c: *tls.Conn) -> RoundTripper>,\n  ProxyConnectHeader: Header,\n  GetProxyConnectHeader: fn (ctx: context.Context, proxyURL: *url.URL, target: string) -> Result<Header>,\n  MaxResponseHeaderBytes: int64,\n  WriteBufferSize: int,\n  ReadBufferSize: int,\n  ForceAttemptHTTP2: bool\n}"},"net/http/httptest":{"httptest.brg":"use net.http\nuse bytes\n// use crypto.x509\nuse net\nuse crypto.tls\nuse io\n\n\nfn NewRecorder  () -> *ResponseRecorder { EXT }\n\nfn NewRequest  (method: string, target: string, body: io.Reader) -> *http.Request { EXT }\n\nfn NewServer  (handler: http.Handler) -> *Server { EXT }\n\nfn NewTLSServer  (handler: http.Handler) -> *Server { EXT }\n\nfn NewUnstartedServer  (handler: http.Handler) -> *Server { EXT }\n\nimpl (self: ResponseRecorder) {\n\nfn Flush  () -> () { EXT }\n\nfn Header  () -> http.Header { EXT }\n\nfn Result  () -> *http.Response { EXT }\n\nfn Write  (buf: [byte]) -> Result<int> { EXT }\n\nfn WriteHeader  (code: int) -> () { EXT }\n\nfn WriteString  (str: string) -> Result<int> { EXT }\n\n}\n\nimpl (self: Server) {\n\nfn Certificate  () -> *any { EXT }\n\nfn Client  () -> *http.Client { EXT }\n\nfn Close  () -> () { EXT }\n\nfn CloseClientConnections  () -> () { EXT }\n\nfn Start  () -> () { EXT }\n\nfn StartTLS  () -> () { EXT }\n\n}\n\nstruct ResponseRecorder{\n  Code: int,\n  HeaderMap: http.Header,\n  Body: *bytes.Buffer,\n  Flushed: bool\n}\n\nstruct Server{\n  URL: string,\n  Listener: net.Listener,\n  EnableHTTP2: bool,\n  TLS: *tls.Config,\n  Config: *http.Server\n}"},"net/netip":{"netip.brg":"fn AddrFrom16  (addr: [byte]) -> Addr { EXT }\n\nfn AddrFrom4  (addr: [byte]) -> Addr { EXT }\n\nfn AddrFromSlice  (slice: [byte]) -> Option<Addr> { EXT }\n\nfn AddrPortFrom  (ip: Addr, port: uint16) -> AddrPort { EXT }\n\nfn IPv4Unspecified  () -> Addr { EXT }\n\nfn IPv6LinkLocalAllNodes  () -> Addr { EXT }\n\nfn IPv6Unspecified  () -> Addr { EXT }\n\nfn MustParseAddr  (s: string) -> Addr { EXT }\n\nfn MustParseAddrPort  (s: string) -> AddrPort { EXT }\n\nfn MustParsePrefix  (s: string) -> Prefix { EXT }\n\nfn ParseAddr  (s: string) -> Result<Addr> { EXT }\n\nfn ParseAddrPort  (s: string) -> Result<AddrPort> { EXT }\n\nfn ParsePrefix  (s: string) -> Result<Prefix> { EXT }\n\nfn PrefixFrom  (ip: Addr, bits: int) -> Prefix { EXT }\n\nimpl (self: Addr) {\n\nfn AppendTo  (b: [byte]) -> [byte] { EXT }\n\nfn As16  () -> [byte] { EXT }\n\nfn As4  () -> [byte] { EXT }\n\nfn AsSlice  () -> [byte] { EXT }\n\nfn BitLen  () -> int { EXT }\n\nfn Compare  (ip2: Addr) -> int { EXT }\n\nfn Is4  () -> bool { EXT }\n\nfn Is4In6  () -> bool { EXT }\n\nfn Is6  () -> bool { EXT }\n\nfn IsGlobalUnicast  () -> bool { EXT }\n\nfn IsInterfaceLocalMulticast  () -> bool { EXT }\n\nfn IsLinkLocalMulticast  () -> bool { EXT }\n\nfn IsLinkLocalUnicast  () -> bool { EXT }\n\nfn IsLoopback  () -> bool { EXT }\n\nfn IsMulticast  () -> bool { EXT }\n\nfn IsPrivate  () -> bool { EXT }\n\nfn IsUnspecified  () -> bool { EXT }\n\nfn IsValid  () -> bool { EXT }\n\nfn Less  (ip2: Addr) -> bool { EXT }\n\nfn MarshalBinary  () -> Result<[byte]> { EXT }\n\nfn MarshalText  () -> Result<[byte]> { EXT }\n\nfn Next  () -> Addr { EXT }\n\nfn Prefix  (b: int) -> Result<Prefix> { EXT }\n\nfn Prev  () -> Addr { EXT }\n\nfn String  () -> string { EXT }\n\nfn StringExpanded  () -> string { EXT }\n\nfn Unmap  () -> Addr { EXT }\n\nfn UnmarshalBinary  (b: [byte]) -> error { EXT }\n\nfn UnmarshalText  (text: [byte]) -> error { EXT }\n\nfn WithZone  (zone: string) -> Addr { EXT }\n\nfn Zone  () -> string { EXT }\n\n}\n\nimpl (self: AddrPort) {\n\nfn Addr  () -> Addr { EXT }\n\nfn AppendTo  (b: [byte]) -> [byte] { EXT }\n\nfn IsValid  () -> bool { EXT }\n\nfn MarshalBinary  () -> Result<[byte]> { EXT }\n\nfn MarshalText  () -> Result<[byte]> { EXT }\n\nfn Port  () -> uint16 { EXT }\n\nfn String  () -> string { EXT }\n\nfn UnmarshalBinary  (b: [byte]) -> error { EXT }\n\nfn UnmarshalText  (text: [byte]) -> error { EXT }\n\n}\n\nimpl (self: Prefix) {\n\nfn Addr  () -> Addr { EXT }\n\nfn AppendTo  (b: [byte]) -> [byte] { EXT }\n\nfn Bits  () -> int { EXT }\n\nfn Contains  (ip: Addr) -> bool { EXT }\n\nfn IsSingleIP  () -> bool { EXT }\n\nfn IsValid  () -> bool { EXT }\n\nfn MarshalBinary  () -> Result<[byte]> { EXT }\n\nfn MarshalText  () -> Result<[byte]> { EXT }\n\nfn Masked  () -> Prefix { EXT }\n\nfn Overlaps  (o: Prefix) -> bool { EXT }\n\nfn String  () -> string { EXT }\n\nfn UnmarshalBinary  (b: [byte]) -> error { EXT }\n\nfn UnmarshalText  (text: [byte]) -> error { EXT }\n\n}\n\nstruct Addr{\n\n}\n\nstruct AddrPort{\n\n}\n\nstruct Prefix{\n\n}"},"net":{"net.brg":"use io\nuse time\nuse os\nuse context\n// use syscall\nuse net.netip\n\n\nfn CIDRMask  (ones: int, bits: int) -> IPMask { EXT }\n\nfn Dial  (network: string, address: string) -> Result<Conn> { EXT }\n\nfn DialIP  (network: string, laddr: *IPAddr, raddr: *IPAddr) -> Result<*IPConn> { EXT }\n\nfn DialTCP  (network: string, laddr: *TCPAddr, raddr: *TCPAddr) -> Result<*TCPConn> { EXT }\n\nfn DialTimeout  (network: string, address: string, timeout: time.Duration) -> Result<Conn> { EXT }\n\nfn DialUDP  (network: string, laddr: *UDPAddr, raddr: *UDPAddr) -> Result<*UDPConn> { EXT }\n\nfn DialUnix  (network: string, laddr: *UnixAddr, raddr: *UnixAddr) -> Result<*UnixConn> { EXT }\n\nfn FileConn  (f: *os.File) -> Result<Conn> { EXT }\n\nfn FileListener  (f: *os.File) -> Result<Listener> { EXT }\n\nfn FilePacketConn  (f: *os.File) -> Result<PacketConn> { EXT }\n\nfn IPv4  (a: byte, b: byte, c: byte, d: byte) -> IP { EXT }\n\nfn IPv4Mask  (a: byte, b: byte, c: byte, d: byte) -> IPMask { EXT }\n\nfn InterfaceAddrs  () -> Result<[Addr]> { EXT }\n\nfn InterfaceByIndex  (index: int) -> Result<*Interface> { EXT }\n\nfn InterfaceByName  (name: string) -> Result<*Interface> { EXT }\n\nfn Interfaces  () -> Result<[Interface]> { EXT }\n\nfn JoinHostPort  (host: string, port: string) -> string { EXT }\n\nfn Listen  (network: string, address: string) -> Result<Listener> { EXT }\n\nfn ListenIP  (network: string, laddr: *IPAddr) -> Result<*IPConn> { EXT }\n\nfn ListenMulticastUDP  (network: string, ifi: *Interface, gaddr: *UDPAddr) -> Result<*UDPConn> { EXT }\n\nfn ListenPacket  (network: string, address: string) -> Result<PacketConn> { EXT }\n\nfn ListenTCP  (network: string, laddr: *TCPAddr) -> Result<*TCPListener> { EXT }\n\nfn ListenUDP  (network: string, laddr: *UDPAddr) -> Result<*UDPConn> { EXT }\n\nfn ListenUnix  (network: string, laddr: *UnixAddr) -> Result<*UnixListener> { EXT }\n\nfn ListenUnixgram  (network: string, laddr: *UnixAddr) -> Result<*UnixConn> { EXT }\n\nfn LookupAddr  (addr: string) -> Result<[string]> { EXT }\n\nfn LookupCNAME  (host: string) -> Result<string> { EXT }\n\nfn LookupHost  (host: string) -> Result<[string]> { EXT }\n\nfn LookupIP  (host: string) -> Result<[IP]> { EXT }\n\nfn LookupMX  (name: string) -> Result<[*MX]> { EXT }\n\nfn LookupNS  (name: string) -> Result<[*NS]> { EXT }\n\nfn LookupPort  (network: string, service: string) -> Result<int> { EXT }\n\nfn LookupSRV  (service: string, proto: string, name: string) -> (string, [*SRV], error) { EXT }\n\nfn LookupTXT  (name: string) -> Result<[string]> { EXT }\n\nfn ParseCIDR  (s: string) -> (IP, *IPNet, error) { EXT }\n\nfn ParseIP  (s: string) -> IP { EXT }\n\nfn ParseMAC  (s: string) -> Result<HardwareAddr> { EXT }\n\nfn Pipe  () -> (Conn, Conn) { EXT }\n\nfn ResolveIPAddr  (network: string, address: string) -> Result<*IPAddr> { EXT }\n\nfn ResolveTCPAddr  (network: string, address: string) -> Result<*TCPAddr> { EXT }\n\nfn ResolveUDPAddr  (network: string, address: string) -> Result<*UDPAddr> { EXT }\n\nfn ResolveUnixAddr  (network: string, address: string) -> Result<*UnixAddr> { EXT }\n\nfn SplitHostPort  (hostport: string) -> Result<string> { EXT }\n\nfn TCPAddrFromAddrPort  (addr: netip.AddrPort) -> *TCPAddr { EXT }\n\nfn UDPAddrFromAddrPort  (addr: netip.AddrPort) -> *UDPAddr { EXT }\n\nimpl (self: AddrError) {\n\nfn Error  () -> string { EXT }\n\nfn Temporary  () -> bool { EXT }\n\nfn Timeout  () -> bool { EXT }\n\n}\n\nimpl (self: Buffers) {\n\nfn Read  (p: [byte]) -> Result<int> { EXT }\n\nfn WriteTo  (w: io.Writer) -> Result<int64> { EXT }\n\n}\n\nimpl (self: DNSConfigError) {\n\nfn Error  () -> string { EXT }\n\nfn Temporary  () -> bool { EXT }\n\nfn Timeout  () -> bool { EXT }\n\nfn Unwrap  () -> error { EXT }\n\n}\n\nimpl (self: DNSError) {\n\nfn Error  () -> string { EXT }\n\nfn Temporary  () -> bool { EXT }\n\nfn Timeout  () -> bool { EXT }\n\n}\n\nimpl (self: Dialer) {\n\nfn Dial  (network: string, address: string) -> Result<Conn> { EXT }\n\nfn DialContext  (ctx: context.Context, network: string, address: string) -> Result<Conn> { EXT }\n\n}\n\nimpl (self: Flags) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: HardwareAddr) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: IP) {\n\nfn DefaultMask  () -> IPMask { EXT }\n\nfn Equal  (x: IP) -> bool { EXT }\n\nfn IsGlobalUnicast  () -> bool { EXT }\n\nfn IsInterfaceLocalMulticast  () -> bool { EXT }\n\nfn IsLinkLocalMulticast  () -> bool { EXT }\n\nfn IsLinkLocalUnicast  () -> bool { EXT }\n\nfn IsLoopback  () -> bool { EXT }\n\nfn IsMulticast  () -> bool { EXT }\n\nfn IsPrivate  () -> bool { EXT }\n\nfn IsUnspecified  () -> bool { EXT }\n\nfn MarshalText  () -> Result<[byte]> { EXT }\n\nfn Mask  (mask: IPMask) -> IP { EXT }\n\nfn String  () -> string { EXT }\n\nfn To16  () -> IP { EXT }\n\nfn To4  () -> IP { EXT }\n\nfn UnmarshalText  (text: [byte]) -> error { EXT }\n\n}\n\nimpl (self: IPAddr) {\n\nfn Network  () -> string { EXT }\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: IPConn) {\n\nfn Close  () -> error { EXT }\n\nfn File  () -> Result<*os.File> { EXT }\n\nfn LocalAddr  () -> Addr { EXT }\n\nfn Read  (b: [byte]) -> Result<int> { EXT }\n\nfn ReadFrom  (b: [byte]) -> (int, Addr, error) { EXT }\n\nfn ReadFromIP  (b: [byte]) -> (int, *IPAddr, error) { EXT }\n\nfn ReadMsgIP  (b: [byte], oob: [byte]) -> (int, *IPAddr, error) { EXT }\n\nfn RemoteAddr  () -> Addr { EXT }\n\nfn SetDeadline  (t: time.Time) -> error { EXT }\n\nfn SetReadBuffer  (bytes: int) -> error { EXT }\n\nfn SetReadDeadline  (t: time.Time) -> error { EXT }\n\nfn SetWriteBuffer  (bytes: int) -> error { EXT }\n\nfn SetWriteDeadline  (t: time.Time) -> error { EXT }\n\nfn SyscallConn  () -> Result<any> { EXT }\n\nfn Write  (b: [byte]) -> Result<int> { EXT }\n\nfn WriteMsgIP  (b: [byte], oob: [byte], addr: *IPAddr) -> Result<int> { EXT }\n\nfn WriteTo  (b: [byte], addr: Addr) -> Result<int> { EXT }\n\nfn WriteToIP  (b: [byte], addr: *IPAddr) -> Result<int> { EXT }\n\n}\n\nimpl (self: IPMask) {\n\nfn Size  () -> int { EXT }\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: IPNet) {\n\nfn Contains  (ip: IP) -> bool { EXT }\n\nfn Network  () -> string { EXT }\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: Interface) {\n\nfn Addrs  () -> Result<[Addr]> { EXT }\n\nfn MulticastAddrs  () -> Result<[Addr]> { EXT }\n\n}\n\nimpl (self: InvalidAddrError) {\n\nfn Error  () -> string { EXT }\n\nfn Temporary  () -> bool { EXT }\n\nfn Timeout  () -> bool { EXT }\n\n}\n\nimpl (self: ListenConfig) {\n\nfn Listen  (ctx: context.Context, network: string, address: string) -> Result<Listener> { EXT }\n\nfn ListenPacket  (ctx: context.Context, network: string, address: string) -> Result<PacketConn> { EXT }\n\n}\n\nimpl (self: OpError) {\n\nfn Error  () -> string { EXT }\n\nfn Temporary  () -> bool { EXT }\n\nfn Timeout  () -> bool { EXT }\n\nfn Unwrap  () -> error { EXT }\n\n}\n\nimpl (self: ParseError) {\n\nfn Error  () -> string { EXT }\n\nfn Temporary  () -> bool { EXT }\n\nfn Timeout  () -> bool { EXT }\n\n}\n\nimpl (self: Resolver) {\n\nfn LookupAddr  (ctx: context.Context, addr: string) -> Result<[string]> { EXT }\n\nfn LookupCNAME  (ctx: context.Context, host: string) -> Result<string> { EXT }\n\nfn LookupHost  (ctx: context.Context, host: string) -> Result<[string]> { EXT }\n\nfn LookupIP  (ctx: context.Context, network: string, host: string) -> Result<[IP]> { EXT }\n\nfn LookupIPAddr  (ctx: context.Context, host: string) -> Result<[IPAddr]> { EXT }\n\nfn LookupMX  (ctx: context.Context, name: string) -> Result<[*MX]> { EXT }\n\nfn LookupNS  (ctx: context.Context, name: string) -> Result<[*NS]> { EXT }\n\nfn LookupNetIP  (ctx: context.Context, network: string, host: string) -> Result<[netip.Addr]> { EXT }\n\nfn LookupPort  (ctx: context.Context, network: string, service: string) -> Result<int> { EXT }\n\nfn LookupSRV  (ctx: context.Context, service: string, proto: string, name: string) -> (string, [*SRV], error) { EXT }\n\nfn LookupTXT  (ctx: context.Context, name: string) -> Result<[string]> { EXT }\n\n}\n\nimpl (self: TCPAddr) {\n\nfn AddrPort  () -> netip.AddrPort { EXT }\n\nfn Network  () -> string { EXT }\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: TCPConn) {\n\nfn Close  () -> error { EXT }\n\nfn CloseRead  () -> error { EXT }\n\nfn CloseWrite  () -> error { EXT }\n\nfn File  () -> Result<*os.File> { EXT }\n\nfn LocalAddr  () -> Addr { EXT }\n\nfn Read  (b: [byte]) -> Result<int> { EXT }\n\nfn ReadFrom  (r: io.Reader) -> Result<int64> { EXT }\n\nfn RemoteAddr  () -> Addr { EXT }\n\nfn SetDeadline  (t: time.Time) -> error { EXT }\n\nfn SetKeepAlive  (keepalive: bool) -> error { EXT }\n\nfn SetKeepAlivePeriod  (d: time.Duration) -> error { EXT }\n\nfn SetLinger  (sec: int) -> error { EXT }\n\nfn SetNoDelay  (noDelay: bool) -> error { EXT }\n\nfn SetReadBuffer  (bytes: int) -> error { EXT }\n\nfn SetReadDeadline  (t: time.Time) -> error { EXT }\n\nfn SetWriteBuffer  (bytes: int) -> error { EXT }\n\nfn SetWriteDeadline  (t: time.Time) -> error { EXT }\n\nfn SyscallConn  () -> Result<any> { EXT }\n\nfn Write  (b: [byte]) -> Result<int> { EXT }\n\n}\n\nimpl (self: TCPListener) {\n\nfn Accept  () -> Result<Conn> { EXT }\n\nfn AcceptTCP  () -> Result<*TCPConn> { EXT }\n\nfn Addr  () -> Addr { EXT }\n\nfn Close  () -> error { EXT }\n\nfn File  () -> Result<*os.File> { EXT }\n\nfn SetDeadline  (t: time.Time) -> error { EXT }\n\nfn SyscallConn  () -> Result<any> { EXT }\n\n}\n\nimpl (self: UDPAddr) {\n\nfn AddrPort  () -> netip.AddrPort { EXT }\n\nfn Network  () -> string { EXT }\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: UDPConn) {\n\nfn Close  () -> error { EXT }\n\nfn File  () -> Result<*os.File> { EXT }\n\nfn LocalAddr  () -> Addr { EXT }\n\nfn Read  (b: [byte]) -> Result<int> { EXT }\n\nfn ReadFrom  (b: [byte]) -> (int, Addr, error) { EXT }\n\nfn ReadFromUDP  (b: [byte]) -> (int, *UDPAddr, error) { EXT }\n\nfn ReadFromUDPAddrPort  (b: [byte]) -> (int, netip.AddrPort, error) { EXT }\n\nfn ReadMsgUDP  (b: [byte], oob: [byte]) -> (int, *UDPAddr, error) { EXT }\n\nfn ReadMsgUDPAddrPort  (b: [byte], oob: [byte]) -> (int, netip.AddrPort, error) { EXT }\n\nfn RemoteAddr  () -> Addr { EXT }\n\nfn SetDeadline  (t: time.Time) -> error { EXT }\n\nfn SetReadBuffer  (bytes: int) -> error { EXT }\n\nfn SetReadDeadline  (t: time.Time) -> error { EXT }\n\nfn SetWriteBuffer  (bytes: int) -> error { EXT }\n\nfn SetWriteDeadline  (t: time.Time) -> error { EXT }\n\nfn SyscallConn  () -> Result<any> { EXT }\n\nfn Write  (b: [byte]) -> Result<int> { EXT }\n\nfn WriteMsgUDP  (b: [byte], oob: [byte], addr: *UDPAddr) -> Result<int> { EXT }\n\nfn WriteMsgUDPAddrPort  (b: [byte], oob: [byte], addr: netip.AddrPort) -> Result<int> { EXT }\n\nfn WriteTo  (b: [byte], addr: Addr) -> Result<int> { EXT }\n\nfn WriteToUDP  (b: [byte], addr: *UDPAddr) -> Result<int> { EXT }\n\nfn WriteToUDPAddrPort  (b: [byte], addr: netip.AddrPort) -> Result<int> { EXT }\n\n}\n\nimpl (self: UnixAddr) {\n\nfn Network  () -> string { EXT }\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: UnixConn) {\n\nfn Close  () -> error { EXT }\n\nfn CloseRead  () -> error { EXT }\n\nfn CloseWrite  () -> error { EXT }\n\nfn File  () -> Result<*os.File> { EXT }\n\nfn LocalAddr  () -> Addr { EXT }\n\nfn Read  (b: [byte]) -> Result<int> { EXT }\n\nfn ReadFrom  (b: [byte]) -> (int, Addr, error) { EXT }\n\nfn ReadFromUnix  (b: [byte]) -> (int, *UnixAddr, error) { EXT }\n\nfn ReadMsgUnix  (b: [byte], oob: [byte]) -> (int, *UnixAddr, error) { EXT }\n\nfn RemoteAddr  () -> Addr { EXT }\n\nfn SetDeadline  (t: time.Time) -> error { EXT }\n\nfn SetReadBuffer  (bytes: int) -> error { EXT }\n\nfn SetReadDeadline  (t: time.Time) -> error { EXT }\n\nfn SetWriteBuffer  (bytes: int) -> error { EXT }\n\nfn SetWriteDeadline  (t: time.Time) -> error { EXT }\n\nfn SyscallConn  () -> Result<any> { EXT }\n\nfn Write  (b: [byte]) -> Result<int> { EXT }\n\nfn WriteMsgUnix  (b: [byte], oob: [byte], addr: *UnixAddr) -> Result<int> { EXT }\n\nfn WriteTo  (b: [byte], addr: Addr) -> Result<int> { EXT }\n\nfn WriteToUnix  (b: [byte], addr: *UnixAddr) -> Result<int> { EXT }\n\n}\n\nimpl (self: UnixListener) {\n\nfn Accept  () -> Result<Conn> { EXT }\n\nfn AcceptUnix  () -> Result<*UnixConn> { EXT }\n\nfn Addr  () -> Addr { EXT }\n\nfn Close  () -> error { EXT }\n\nfn File  () -> Result<*os.File> { EXT }\n\nfn SetDeadline  (t: time.Time) -> error { EXT }\n\nfn SetUnlinkOnClose  (unlink: bool) -> () { EXT }\n\nfn SyscallConn  () -> Result<any> { EXT }\n\n}\n\nimpl (self: UnknownNetworkError) {\n\nfn Error  () -> string { EXT }\n\nfn Temporary  () -> bool { EXT }\n\nfn Timeout  () -> bool { EXT }\n\n}\n\ntype Buffers = [[byte]]\n\ntype HardwareAddr = [byte]\n\ntype IP = [byte]\n\ntype IPMask = [byte]\n\nstruct Flags(uint)\n\nstruct InvalidAddrError(string)\n\nstruct UnknownNetworkError(string)\n\ninterface Addr {\n\n  fn Network () -> string\n  fn String () -> string\n}\n\nstruct AddrError{\n  Err: string,\n  Addr: string\n}\n\ninterface Conn {\n\n  fn Read (b: [byte]) -> Result<int>\n  fn Write (b: [byte]) -> Result<int>\n  fn Close () -> error\n  fn LocalAddr () -> Addr\n  fn RemoteAddr () -> Addr\n  fn SetDeadline (t: time.Time) -> error\n  fn SetReadDeadline (t: time.Time) -> error\n  fn SetWriteDeadline (t: time.Time) -> error\n}\n\nstruct DNSConfigError{\n  Err: error\n}\n\nstruct DNSError{\n  Err: string,\n  Name: string,\n  Server: string,\n  IsTimeout: bool,\n  IsTemporary: bool,\n  IsNotFound: bool\n}\n\nstruct Dialer{\n  Timeout: time.Duration,\n  Deadline: time.Time,\n  LocalAddr: Addr,\n  DualStack: bool,\n  FallbackDelay: time.Duration,\n  KeepAlive: time.Duration,\n  Resolver: *Resolver,\n  Cancel: Receiver<()>,\n  Control: fn (network: string, address: string, c: any) -> error\n}\n\ninterface Error {\nimpl error\n  fn Timeout () -> bool\n  fn Temporary () -> bool\n}\n\nstruct IPAddr{\n  IP: IP,\n  Zone: string\n}\n\nstruct IPConn{\n\n}\n\nstruct IPNet{\n  IP: IP,\n  Mask: IPMask\n}\n\nstruct Interface{\n  Index: int,\n  MTU: int,\n  Name: string,\n  HardwareAddr: HardwareAddr,\n  Flags: Flags\n}\n\nstruct ListenConfig{\n  Control: fn (network: string, address: string, c: any) -> error,\n  KeepAlive: time.Duration\n}\n\ninterface Listener {\n\n  fn Accept () -> Result<Conn>\n  fn Close () -> error\n  fn Addr () -> Addr\n}\n\nstruct MX{\n  Host: string,\n  Pref: uint16\n}\n\nstruct NS{\n  Host: string\n}\n\nstruct OpError{\n  Op: string,\n  Net: string,\n  Source: Addr,\n  Addr: Addr,\n  Err: error\n}\n\ninterface PacketConn {\n\n  fn ReadFrom (p: [byte]) -> (int, Addr, error)\n  fn WriteTo (p: [byte], addr: Addr) -> Result<int>\n  fn Close () -> error\n  fn LocalAddr () -> Addr\n  fn SetDeadline (t: time.Time) -> error\n  fn SetReadDeadline (t: time.Time) -> error\n  fn SetWriteDeadline (t: time.Time) -> error\n}\n\nstruct ParseError{\n  Type: string,\n  Text: string\n}\n\nstruct Resolver{\n  PreferGo: bool,\n  StrictErrors: bool,\n  Dial: fn (ctx: context.Context, network: string, address: string) -> Result<Conn>\n}\n\nstruct SRV{\n  Target: string,\n  Port: uint16,\n  Priority: uint16,\n  Weight: uint16\n}\n\nstruct TCPAddr{\n  IP: IP,\n  Port: int,\n  Zone: string\n}\n\nstruct TCPConn{\n\n}\n\nstruct TCPListener{\n\n}\n\nstruct UDPAddr{\n  IP: IP,\n  Port: int,\n  Zone: string\n}\n\nstruct UDPConn{\n\n}\n\nstruct UnixAddr{\n  Name: string,\n  Net: string\n}\n\nstruct UnixConn{\n\n}\n\nstruct UnixListener{\n\n}"},"context":{"context.brg":"use time\n\n\nfn Background  () -> Context { EXT }\n\nfn TODO  () -> Context { EXT }\n\nfn WithCancel  (parent: Context) -> (Context, CancelFunc) { EXT }\n\nfn WithDeadline  (parent: Context, d: time.Time) -> (Context, CancelFunc) { EXT }\n\nfn WithTimeout  (parent: Context, timeout: time.Duration) -> (Context, CancelFunc) { EXT }\n\nfn WithValue  (parent: Context, key: any, val: any) -> Context { EXT }\n\ntype CancelFunc = fn () -> ()\n\ninterface Context {\n\n  fn Deadline () -> Option<time.Time>\n  fn Done () -> Receiver<()>\n  fn Err () -> error\n  fn Value (key: any) -> any\n}"},"regexp":{"regexp.brg":"use io\n\n\nfn Compile  (expr: string) -> Result<*Regexp> { EXT }\n\nfn CompilePOSIX  (expr: string) -> Result<*Regexp> { EXT }\n\nfn Match  (pattern: string, b: [byte]) -> Result<bool> { EXT }\n\nfn MatchReader  (pattern: string, r: io.RuneReader) -> Result<bool> { EXT }\n\nfn MatchString  (pattern: string, s: string) -> Result<bool> { EXT }\n\nfn MustCompile  (str: string) -> *Regexp { EXT }\n\nfn MustCompilePOSIX  (str: string) -> *Regexp { EXT }\n\nfn QuoteMeta  (s: string) -> string { EXT }\n\nimpl (self: Regexp) {\n\nfn Copy  () -> *Regexp { EXT }\n\nfn Expand  (dst: [byte], template: [byte], src: [byte], match_: [int]) -> [byte] { EXT }\n\nfn ExpandString  (dst: [byte], template: string, src: string, match_: [int]) -> [byte] { EXT }\n\nfn Find  (b: [byte]) -> [byte] { EXT }\n\nfn FindAll  (b: [byte], n: int) -> [[byte]] { EXT }\n\nfn FindAllIndex  (b: [byte], n: int) -> [[int]] { EXT }\n\nfn FindAllString  (s: string, n: int) -> [string] { EXT }\n\nfn FindAllStringIndex  (s: string, n: int) -> [[int]] { EXT }\n\nfn FindAllStringSubmatch  (s: string, n: int) -> [[string]] { EXT }\n\nfn FindAllStringSubmatchIndex  (s: string, n: int) -> [[int]] { EXT }\n\nfn FindAllSubmatch  (b: [byte], n: int) -> [[[byte]]] { EXT }\n\nfn FindAllSubmatchIndex  (b: [byte], n: int) -> [[int]] { EXT }\n\nfn FindIndex  (b: [byte]) -> [int] { EXT }\n\nfn FindReaderIndex  (r: io.RuneReader) -> [int] { EXT }\n\nfn FindReaderSubmatchIndex  (r: io.RuneReader) -> [int] { EXT }\n\nfn FindString  (s: string) -> string { EXT }\n\nfn FindStringIndex  (s: string) -> [int] { EXT }\n\nfn FindStringSubmatch  (s: string) -> [string] { EXT }\n\nfn FindStringSubmatchIndex  (s: string) -> [int] { EXT }\n\nfn FindSubmatch  (b: [byte]) -> [[byte]] { EXT }\n\nfn FindSubmatchIndex  (b: [byte]) -> [int] { EXT }\n\nfn LiteralPrefix  () -> Option<string> { EXT }\n\nfn Longest  () -> () { EXT }\n\nfn Match  (b: [byte]) -> bool { EXT }\n\nfn MatchReader  (r: io.RuneReader) -> bool { EXT }\n\nfn MatchString  (s: string) -> bool { EXT }\n\nfn NumSubexp  () -> int { EXT }\n\nfn ReplaceAll  (src: [byte], repl: [byte]) -> [byte] { EXT }\n\nfn ReplaceAllFunc  (src: [byte], repl: fn (param0: [byte]) -> [byte]) -> [byte] { EXT }\n\nfn ReplaceAllLiteral  (src: [byte], repl: [byte]) -> [byte] { EXT }\n\nfn ReplaceAllLiteralString  (src: string, repl: string) -> string { EXT }\n\nfn ReplaceAllString  (src: string, repl: string) -> string { EXT }\n\nfn ReplaceAllStringFunc  (src: string, repl: fn (param0: string) -> string) -> string { EXT }\n\nfn Split  (s: string, n: int) -> [string] { EXT }\n\nfn String  () -> string { EXT }\n\nfn SubexpIndex  (name: string) -> int { EXT }\n\nfn SubexpNames  () -> [string] { EXT }\n\n}\n\nstruct Regexp{\n\n}"},"core":{"core.brg":"// TODO asdf move this to builtin.brg\ninterface ComplexType {}\ninterface FloatType {}\ninterface IntegerType {}\ninterface any {}\ntype bool = EXT;\ntype byte = EXT;\ninterface comparable {}\ntype complex128 = EXT;\ntype complex64 = EXT;\ninterface error {\n    fn Error() -> string;\n}\ntype float32 = EXT;\ntype float64 = EXT;\ntype int = EXT;\ntype int16 = EXT;\ntype int32 = EXT;\ntype int64 = EXT;\ntype int8 = EXT;\ntype rune = EXT;\ntype string = EXT;\ntype uint = EXT;\ntype uint16 = EXT;\ntype uint32 = EXT;\ntype uint64 = EXT;\ntype uint8 = EXT;\ntype uintptr = EXT;\n\nfn string(a: any) -> string {\n    EXT\n}\n\n/// ---------------------------------------------------------------\n\ntype Map<K, V> = EXT;\n\ntype EnumerateSlice<T> = EXT;\n\ntype VarArgs<T> = EXT;\n\ntype Channel<T> = EXT;\ntype Sender<T> = EXT;\ntype Receiver<T> = EXT;\n\ntype Unit = EXT;\ntype Slice<T> = EXT;\ntype never = EXT;\ntype Ref<T> = EXT;\ntype RefMut<T> = EXT;\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nimpl<T, E> (r: Result<T, E>) {\n    fn IsOk() -> bool {\n        match r {\n            Ok(_) => true,\n            Err(_) => false,\n        }\n    }\n\n    fn Unwrap() -> T {\n        @rawgo(\n          \\\\ if r.tag == Result_Err {\n          \\\\   inspect(r.Err)\n          \\\\   panic(\"Unwrapped Err value\")\n          \\\\ }\n          \\\\ return r.Ok\n        )\n    }\n}\n\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nimpl<T> (o: Option<T>) {\n    fn IsSome() -> bool {\n        match o {\n            Some(_) => true,\n            None => false,\n        }\n    }\n\n    fn IsNone() -> bool {\n        !o.IsSome()\n    }\n\n    fn UnwrapOr(def: T) -> T {\n        match o {\n            Some(x) => x,\n            None => def,\n        }\n    }\n\n    fn UnwrapOrElse(f: fn() -> T) -> T {\n        match o {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n\n    fn Unwrap() -> T {\n        @rawgo(\n          \\\\ if o.tag == Option_None {\n          \\\\  panic(\"Unwrapped None value\")\n          \\\\ }\n          \\\\ return o.Some\n        )\n    }\n}\n\nfn Option.ToOption<T>(value: T, check: bool) -> Option<T> {\n    if check {\n        Some(value)\n    } else {\n        None\n    }\n}\n\nstruct Tuple2<T, Y> {\n    first: T,\n    second: Y,\n}\n\nstruct Tuple3<T, Y, Z> {\n    first: T,\n    second: Y,\n    third: Z,\n}\n\nstruct Tuple4<T, X, Y, Z> {\n    first: T,\n    second: X,\n    third: Y,\n    fourth: Z,\n}\n\nfn zeroValue<T>() -> T {\n    @rawgo(\n      \\\\ var m T\n      \\\\ return m\n    )\n}\n\nfn assertEq<T>(a: T, b: T) {\n    @rawgo(\n    \\\\ if !reflect.DeepEqual(a, b) {\n        \\\\ inspect(a);\n        \\\\ inspect(b);\n        \\\\ panic(\"something wrong\")\n    \\\\ }\n    )\n}\n\nfn inspect<T>(a: T) -> T {\n    @rawgo(\n      \\\\ fmt.Printf(\"%+v\\n\", a);\n      \\\\ return a\n    )\n}\n\nfn Debug_unreachable<T>() -> T {\n    @rawgo( \n      \\\\panic(\"unreachable code\")\n    )\n}\n\nfn Result.fromError(e: error) -> Result<()> {\n    @rawgo(\n      \\\\ if e != nil {\n      \\\\   return struct{}{}, e\n      \\\\ }\n      \\\\ return struct{}{}, nil\n    )\n}\n\nimpl<T> (xs: [T]) {\n    fn Len() -> int {\n        @rawgo(\n          \\\\return len(xs)\n        )\n    }\n\n    fn Enumerate() -> EnumerateSlice<T> {\n        @rawgo(\n          \\\\return xs\n        )\n    }\n\n    fn Set(index: int, item: T) {\n        @rawgo(\n          \\\\ xs[index] = item\n        )\n    }\n\n    fn Append(item: T) -> [T] {\n        @rawgo(\n          \\\\ return append(xs, item)\n        )\n    }\n\n    fn Get(i: int) -> Option<T> {\n        @rawgo(\n          \\\\ if i < 0 || i >= len(xs) {\n          \\\\   return *new(T), false\n          \\\\ }\n          \\\\ return xs[i], true\n        )\n    }\n}\n\n\nfn Map.new<K: comparable, V>() -> Map<K, V> {\n    @rawgo(\n      \\\\ return map[K]V{}\n    )\n}\n\n\nimpl<K: comparable, V> (m: Map<K, V>) {\n    fn Len() -> int {\n        @rawgo(\n          \\\\ return len(m)\n        )\n    }\n\n    fn Insert(k: K, v: V) {\n        @rawgo(\n          \\\\ m[k] = v\n        )\n    }\n\n    fn Get(k: K) -> Option<V> {\n        @rawgo(\n          \\\\ v, ok := m[k]\n          \\\\ return v, ok\n        )\n    }\n}\n\nfn Channel.new<T>() -> (Sender<T>, Receiver<T>) {\n    @rawgo(\n      \\\\ ch := make(chan T)\n      \\\\ return Tuple2[chan<- T, <-chan T]{ first: ch, second: ch }\n    )\n}\n\nimpl<T> (ch: Sender<T>) {\n    fn Send(value: T) {\n        @rawgo(\n          \\\\ ch <- value\n        )\n    }\n\n    fn Close() {\n        @rawgo(\n          \\\\ close(ch)\n        )\n    }\n}\n\nimpl<T> (ch: Receiver<T>) {\n    fn Recv() -> T {\n        @rawgo(\n          \\\\ return <- ch\n        )\n    }\n}\n\nimpl (s: string) {\n    fn Enumerate() -> EnumerateSlice<rune> {\n        @rawgo(\n          \\\\ return []rune(s)\n        )\n    }\n}\n"},"bytes":{"bytes.brg":"use io\nuse unicode\n\n\nfn Compare  (a: [byte], b: [byte]) -> int { EXT }\n\nfn Contains  (b: [byte], subslice: [byte]) -> bool { EXT }\n\nfn ContainsAny  (b: [byte], chars: string) -> bool { EXT }\n\nfn ContainsRune  (b: [byte], r: rune) -> bool { EXT }\n\nfn Count  (s: [byte], sep: [byte]) -> int { EXT }\n\nfn Cut  (s: [byte], sep: [byte]) -> Option<[byte]> { EXT }\n\nfn Equal  (a: [byte], b: [byte]) -> bool { EXT }\n\nfn EqualFold  (s: [byte], t: [byte]) -> bool { EXT }\n\nfn Fields  (s: [byte]) -> [[byte]] { EXT }\n\nfn FieldsFunc  (s: [byte], f: fn (param0: rune) -> bool) -> [[byte]] { EXT }\n\nfn HasPrefix  (s: [byte], prefix: [byte]) -> bool { EXT }\n\nfn HasSuffix  (s: [byte], suffix: [byte]) -> bool { EXT }\n\nfn Index  (s: [byte], sep: [byte]) -> int { EXT }\n\nfn IndexAny  (s: [byte], chars: string) -> int { EXT }\n\nfn IndexByte  (b: [byte], c: byte) -> int { EXT }\n\nfn IndexFunc  (s: [byte], f: fn (r: rune) -> bool) -> int { EXT }\n\nfn IndexRune  (s: [byte], r: rune) -> int { EXT }\n\nfn Join  (s: [[byte]], sep: [byte]) -> [byte] { EXT }\n\nfn LastIndex  (s: [byte], sep: [byte]) -> int { EXT }\n\nfn LastIndexAny  (s: [byte], chars: string) -> int { EXT }\n\nfn LastIndexByte  (s: [byte], c: byte) -> int { EXT }\n\nfn LastIndexFunc  (s: [byte], f: fn (r: rune) -> bool) -> int { EXT }\n\nfn Map  (mapping: fn (r: rune) -> rune, s: [byte]) -> [byte] { EXT }\n\nfn NewBuffer  (buf: [byte]) -> *Buffer { EXT }\n\nfn NewBufferString  (s: string) -> *Buffer { EXT }\n\nfn NewReader  (b: [byte]) -> *Reader { EXT }\n\nfn Repeat  (b: [byte], count: int) -> [byte] { EXT }\n\nfn Replace  (s: [byte], old: [byte], new: [byte], n: int) -> [byte] { EXT }\n\nfn ReplaceAll  (s: [byte], old: [byte], new: [byte]) -> [byte] { EXT }\n\nfn Runes  (s: [byte]) -> [rune] { EXT }\n\nfn Split  (s: [byte], sep: [byte]) -> [[byte]] { EXT }\n\nfn SplitAfter  (s: [byte], sep: [byte]) -> [[byte]] { EXT }\n\nfn SplitAfterN  (s: [byte], sep: [byte], n: int) -> [[byte]] { EXT }\n\nfn SplitN  (s: [byte], sep: [byte], n: int) -> [[byte]] { EXT }\n\nfn Title  (s: [byte]) -> [byte] { EXT }\n\nfn ToLower  (s: [byte]) -> [byte] { EXT }\n\nfn ToLowerSpecial  (c: unicode.SpecialCase, s: [byte]) -> [byte] { EXT }\n\nfn ToTitle  (s: [byte]) -> [byte] { EXT }\n\nfn ToTitleSpecial  (c: unicode.SpecialCase, s: [byte]) -> [byte] { EXT }\n\nfn ToUpper  (s: [byte]) -> [byte] { EXT }\n\nfn ToUpperSpecial  (c: unicode.SpecialCase, s: [byte]) -> [byte] { EXT }\n\nfn ToValidUTF8  (s: [byte], replacement: [byte]) -> [byte] { EXT }\n\nfn Trim  (s: [byte], cutset: string) -> [byte] { EXT }\n\nfn TrimFunc  (s: [byte], f: fn (r: rune) -> bool) -> [byte] { EXT }\n\nfn TrimLeft  (s: [byte], cutset: string) -> [byte] { EXT }\n\nfn TrimLeftFunc  (s: [byte], f: fn (r: rune) -> bool) -> [byte] { EXT }\n\nfn TrimPrefix  (s: [byte], prefix: [byte]) -> [byte] { EXT }\n\nfn TrimRight  (s: [byte], cutset: string) -> [byte] { EXT }\n\nfn TrimRightFunc  (s: [byte], f: fn (r: rune) -> bool) -> [byte] { EXT }\n\nfn TrimSpace  (s: [byte]) -> [byte] { EXT }\n\nfn TrimSuffix  (s: [byte], suffix: [byte]) -> [byte] { EXT }\n\nimpl (self: Buffer) {\n\nfn Bytes  () -> [byte] { EXT }\n\nfn Cap  () -> int { EXT }\n\nfn Grow  (n: int) -> () { EXT }\n\nfn Len  () -> int { EXT }\n\nfn Next  (n: int) -> [byte] { EXT }\n\nfn Read  (p: [byte]) -> Result<int> { EXT }\n\nfn ReadByte  () -> Result<byte> { EXT }\n\nfn ReadBytes  (delim: byte) -> Result<[byte]> { EXT }\n\nfn ReadFrom  (r: io.Reader) -> Result<int64> { EXT }\n\nfn ReadRune  () -> (rune, int, error) { EXT }\n\nfn ReadString  (delim: byte) -> Result<string> { EXT }\n\nfn Reset  () -> () { EXT }\n\nfn String  () -> string { EXT }\n\nfn Truncate  (n: int) -> () { EXT }\n\nfn UnreadByte  () -> error { EXT }\n\nfn UnreadRune  () -> error { EXT }\n\nfn Write  (p: [byte]) -> Result<int> { EXT }\n\nfn WriteByte  (c: byte) -> error { EXT }\n\nfn WriteRune  (r: rune) -> Result<int> { EXT }\n\nfn WriteString  (s: string) -> Result<int> { EXT }\n\nfn WriteTo  (w: io.Writer) -> Result<int64> { EXT }\n\n}\n\nimpl (self: Reader) {\n\nfn Len  () -> int { EXT }\n\nfn Read  (b: [byte]) -> Result<int> { EXT }\n\nfn ReadAt  (b: [byte], off: int64) -> Result<int> { EXT }\n\nfn ReadByte  () -> Result<byte> { EXT }\n\nfn ReadRune  () -> (rune, int, error) { EXT }\n\nfn Reset  (b: [byte]) -> () { EXT }\n\nfn Seek  (offset: int64, whence: int) -> Result<int64> { EXT }\n\nfn Size  () -> int64 { EXT }\n\nfn UnreadByte  () -> error { EXT }\n\nfn UnreadRune  () -> error { EXT }\n\nfn WriteTo  (w: io.Writer) -> Result<int64> { EXT }\n\n}\n\nstruct Buffer{\n\n}\n\nstruct Reader{\n\n}"},"unicode":{"unicode.brg":"fn In  (r: rune, ranges: VarArgs<*RangeTable>) -> bool { EXT }\n\nfn Is  (rangeTab: *RangeTable, r: rune) -> bool { EXT }\n\nfn IsControl  (r: rune) -> bool { EXT }\n\nfn IsDigit  (r: rune) -> bool { EXT }\n\nfn IsGraphic  (r: rune) -> bool { EXT }\n\nfn IsLetter  (r: rune) -> bool { EXT }\n\nfn IsLower  (r: rune) -> bool { EXT }\n\nfn IsMark  (r: rune) -> bool { EXT }\n\nfn IsNumber  (r: rune) -> bool { EXT }\n\nfn IsOneOf  (ranges: [*RangeTable], r: rune) -> bool { EXT }\n\nfn IsPrint  (r: rune) -> bool { EXT }\n\nfn IsPunct  (r: rune) -> bool { EXT }\n\nfn IsSpace  (r: rune) -> bool { EXT }\n\nfn IsSymbol  (r: rune) -> bool { EXT }\n\nfn IsTitle  (r: rune) -> bool { EXT }\n\nfn IsUpper  (r: rune) -> bool { EXT }\n\nfn SimpleFold  (r: rune) -> rune { EXT }\n\nfn To  (_case: int, r: rune) -> rune { EXT }\n\nfn ToLower  (r: rune) -> rune { EXT }\n\nfn ToTitle  (r: rune) -> rune { EXT }\n\nfn ToUpper  (r: rune) -> rune { EXT }\n\nimpl (self: SpecialCase) {\n\nfn ToLower  (r: rune) -> rune { EXT }\n\nfn ToTitle  (r: rune) -> rune { EXT }\n\nfn ToUpper  (r: rune) -> rune { EXT }\n\n}\n\ntype SpecialCase = [CaseRange]\n\nstruct CaseRange{\n  Lo: uint32,\n  Hi: uint32,\n  Delta: d\n}\n\nstruct Range16{\n  Lo: uint16,\n  Hi: uint16,\n  Stride: uint16\n}\n\nstruct Range32{\n  Lo: uint32,\n  Hi: uint32,\n  Stride: uint32\n}\n\nstruct RangeTable{\n  R16: [Range16],\n  R32: [Range32],\n  LatinOffset: int\n}","consts.brg":"// this type is referenced in CaseRange, but it's not exported :thinking_face:\ntype d = any;\n"},"hash":{"hash.brg":"use io\n\n\ninterface Hash {\nimpl io.Writer\n  fn Sum (b: [byte]) -> [byte]\n  fn Reset () -> ()\n  fn Size () -> int\n  fn BlockSize () -> int\n}\n\ninterface Hash32 {\nimpl Hash\n  fn Sum32 () -> uint32\n}\n\ninterface Hash64 {\nimpl Hash\n  fn Sum64 () -> uint64\n}"},"fmt":{"fmt.brg":"use io\n\n\nfn Append  (b: [byte], a: VarArgs<any>) -> [byte] { EXT }\n\nfn Appendf  (b: [byte], format: string, a: VarArgs<any>) -> [byte] { EXT }\n\nfn Appendln  (b: [byte], a: VarArgs<any>) -> [byte] { EXT }\n\nfn Errorf  (format: string, a: VarArgs<any>) -> error { EXT }\n\nfn Fprint  (w: io.Writer, a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Fprintf  (w: io.Writer, format: string, a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Fprintln  (w: io.Writer, a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Fscan  (r: io.Reader, a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Fscanf  (r: io.Reader, format: string, a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Fscanln  (r: io.Reader, a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Print  (a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Printf  (format: string, a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Println  (a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Scan  (a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Scanf  (format: string, a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Scanln  (a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Sprint  (a: VarArgs<any>) -> string { EXT }\n\nfn Sprintf  (format: string, a: VarArgs<any>) -> string { EXT }\n\nfn Sprintln  (a: VarArgs<any>) -> string { EXT }\n\nfn Sscan  (str: string, a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Sscanf  (str: string, format: string, a: VarArgs<any>) -> Result<int> { EXT }\n\nfn Sscanln  (str: string, a: VarArgs<any>) -> Result<int> { EXT }\n\ninterface Formatter {\n\n  fn Format (f: State, verb: rune) -> ()\n}\n\ninterface GoStringer {\n\n  fn GoString () -> string\n}\n\ninterface ScanState {\n\n  fn ReadRune () -> (rune, int, error)\n  fn UnreadRune () -> error\n  fn SkipSpace () -> ()\n  fn Token (skipSpace: bool, f: fn (param0: rune) -> bool) -> Result<[byte]>\n  fn Width () -> Option<int>\n  fn Read (buf: [byte]) -> Result<int>\n}\n\ninterface Scanner {\n\n  fn Scan (state: ScanState, verb: rune) -> error\n}\n\ninterface State {\n\n  fn Write (b: [byte]) -> Result<int>\n  fn Width () -> Option<int>\n  fn Precision () -> Option<int>\n  fn Flag (c: int) -> bool\n}\n\ninterface Stringer {\n\n  fn String () -> string\n}"},"reflect":{"reflect.brg":"use unsafe\n\n\nfn Append  (s: Value, x: VarArgs<Value>) -> Value { EXT }\n\nfn AppendSlice  (s: Value, t: Value) -> Value { EXT }\n\nfn ArrayOf  (length: int, elem: Type) -> Type { EXT }\n\nfn ChanOf  (dir: ChanDir, t: Type) -> Type { EXT }\n\nfn Copy  (dst: Value, src: Value) -> int { EXT }\n\nfn DeepEqual  (x: any, y: any) -> bool { EXT }\n\nfn FuncOf  (in_: [Type], out: [Type], variadic: bool) -> Type { EXT }\n\nfn Indirect  (v: Value) -> Value { EXT }\n\nfn MakeChan  (typ: Type, buffer: int) -> Value { EXT }\n\nfn MakeFunc  (typ: Type, fn_: fn (args: [Value]) -> [Value]) -> Value { EXT }\n\nfn MakeMap  (typ: Type) -> Value { EXT }\n\nfn MakeMapWithSize  (typ: Type, n: int) -> Value { EXT }\n\nfn MakeSlice  (typ: Type, len: int, cap: int) -> Value { EXT }\n\nfn MapOf  (key: Type, elem: Type) -> Type { EXT }\n\nfn New  (typ: Type) -> Value { EXT }\n\nfn NewAt  (typ: Type, p: unsafe.Pointer) -> Value { EXT }\n\nfn PointerTo  (t: Type) -> Type { EXT }\n\nfn PtrTo  (t: Type) -> Type { EXT }\n\nfn Select  (cases: [SelectCase]) -> (int, Value, bool) { EXT }\n\nfn SliceOf  (t: Type) -> Type { EXT }\n\nfn StructOf  (fields: [StructField]) -> Type { EXT }\n\nfn Swapper  (slice: any) -> fn (i: int, j: int) -> () { EXT }\n\nfn TypeOf  (i: any) -> Type { EXT }\n\nfn ValueOf  (i: any) -> Value { EXT }\n\nfn VisibleFields  (t: Type) -> [StructField] { EXT }\n\nfn Zero  (typ: Type) -> Value { EXT }\n\nimpl (self: ChanDir) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: Kind) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: MapIter) {\n\nfn Key  () -> Value { EXT }\n\nfn Next  () -> bool { EXT }\n\nfn Reset  (v: Value) -> () { EXT }\n\nfn Value  () -> Value { EXT }\n\n}\n\nimpl (self: Method) {\n\nfn IsExported  () -> bool { EXT }\n\n}\n\nimpl (self: StructField) {\n\nfn IsExported  () -> bool { EXT }\n\n}\n\nimpl (self: StructTag) {\n\nfn Get  (key: string) -> string { EXT }\n\nfn Lookup  (key: string) -> Option<string> { EXT }\n\n}\n\nimpl (self: Value) {\n\nfn Addr  () -> Value { EXT }\n\nfn Bool  () -> bool { EXT }\n\nfn Bytes  () -> [byte] { EXT }\n\nfn Call  (in_: [Value]) -> [Value] { EXT }\n\nfn CallSlice  (in_: [Value]) -> [Value] { EXT }\n\nfn CanAddr  () -> bool { EXT }\n\nfn CanComplex  () -> bool { EXT }\n\nfn CanConvert  (t: Type) -> bool { EXT }\n\nfn CanFloat  () -> bool { EXT }\n\nfn CanInt  () -> bool { EXT }\n\nfn CanInterface  () -> bool { EXT }\n\nfn CanSet  () -> bool { EXT }\n\nfn CanUint  () -> bool { EXT }\n\nfn Cap  () -> int { EXT }\n\nfn Close  () -> () { EXT }\n\nfn Complex  () -> complex128 { EXT }\n\nfn Convert  (t: Type) -> Value { EXT }\n\nfn Elem  () -> Value { EXT }\n\nfn Field  (i: int) -> Value { EXT }\n\nfn FieldByIndex  (index: [int]) -> Value { EXT }\n\nfn FieldByIndexErr  (index: [int]) -> Result<Value> { EXT }\n\nfn FieldByName  (name: string) -> Value { EXT }\n\nfn FieldByNameFunc  (match_: fn (param0: string) -> bool) -> Value { EXT }\n\nfn Float  () -> float64 { EXT }\n\nfn Index  (i: int) -> Value { EXT }\n\nfn Int  () -> int64 { EXT }\n\nfn Interface  () -> any { EXT }\n\nfn InterfaceData  () -> [uintptr] { EXT }\n\nfn IsNil  () -> bool { EXT }\n\nfn IsValid  () -> bool { EXT }\n\nfn IsZero  () -> bool { EXT }\n\nfn Kind  () -> Kind { EXT }\n\nfn Len  () -> int { EXT }\n\nfn MapIndex  (key: Value) -> Value { EXT }\n\nfn MapKeys  () -> [Value] { EXT }\n\nfn MapRange  () -> *MapIter { EXT }\n\nfn Method  (i: int) -> Value { EXT }\n\nfn MethodByName  (name: string) -> Value { EXT }\n\nfn NumField  () -> int { EXT }\n\nfn NumMethod  () -> int { EXT }\n\nfn OverflowComplex  (x: complex128) -> bool { EXT }\n\nfn OverflowFloat  (x: float64) -> bool { EXT }\n\nfn OverflowInt  (x: int64) -> bool { EXT }\n\nfn OverflowUint  (x: uint64) -> bool { EXT }\n\nfn Pointer  () -> uintptr { EXT }\n\nfn Recv  () -> Option<Value> { EXT }\n\nfn Send  (x: Value) -> () { EXT }\n\nfn Set  (x: Value) -> () { EXT }\n\nfn SetBool  (x: bool) -> () { EXT }\n\nfn SetBytes  (x: [byte]) -> () { EXT }\n\nfn SetCap  (n: int) -> () { EXT }\n\nfn SetComplex  (x: complex128) -> () { EXT }\n\nfn SetFloat  (x: float64) -> () { EXT }\n\nfn SetInt  (x: int64) -> () { EXT }\n\nfn SetIterKey  (iter: *MapIter) -> () { EXT }\n\nfn SetIterValue  (iter: *MapIter) -> () { EXT }\n\nfn SetLen  (n: int) -> () { EXT }\n\nfn SetMapIndex  (key: Value, elem: Value) -> () { EXT }\n\nfn SetPointer  (x: unsafe.Pointer) -> () { EXT }\n\nfn SetString  (x: string) -> () { EXT }\n\nfn SetUint  (x: uint64) -> () { EXT }\n\nfn Slice  (i: int, j: int) -> Value { EXT }\n\nfn Slice3  (i: int, j: int, k: int) -> Value { EXT }\n\nfn String  () -> string { EXT }\n\nfn TryRecv  () -> Option<Value> { EXT }\n\nfn TrySend  (x: Value) -> bool { EXT }\n\nfn Type  () -> Type { EXT }\n\nfn Uint  () -> uint64 { EXT }\n\nfn UnsafeAddr  () -> uintptr { EXT }\n\nfn UnsafePointer  () -> unsafe.Pointer { EXT }\n\n}\n\nimpl (self: ValueError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nstruct ChanDir(int)\n\nstruct Kind(uint)\n\nstruct SelectDir(int)\n\nstruct StructTag(string)\n\nstruct MapIter{\n\n}\n\nstruct Method{\n  Name: string,\n  PkgPath: string,\n  Type: Type,\n  Func: Value,\n  Index: int\n}\n\nstruct SelectCase{\n  Dir: SelectDir,\n  Chan: Value,\n  Send: Value\n}\n\nstruct SliceHeader{\n  Data: uintptr,\n  Len: int,\n  Cap: int\n}\n\nstruct StringHeader{\n  Data: uintptr,\n  Len: int\n}\n\nstruct StructField{\n  Name: string,\n  PkgPath: string,\n  Type: Type,\n  Tag: StructTag,\n  Offset: uintptr,\n  Index: [int],\n  Anonymous: bool\n}\n\ninterface Type {\n\n  fn Align () -> int\n  fn FieldAlign () -> int\n  fn Method (param0: int) -> Method\n  fn MethodByName (param0: string) -> Option<Method>\n  fn NumMethod () -> int\n  fn Name () -> string\n  fn PkgPath () -> string\n  fn Size () -> uintptr\n  fn String () -> string\n  fn Kind () -> Kind\n  fn Implements (u: Type) -> bool\n  fn AssignableTo (u: Type) -> bool\n  fn ConvertibleTo (u: Type) -> bool\n  fn Comparable () -> bool\n  fn Bits () -> int\n  fn ChanDir () -> ChanDir\n  fn IsVariadic () -> bool\n  fn Elem () -> Type\n  fn Field (i: int) -> StructField\n  fn FieldByIndex (index: [int]) -> StructField\n  fn FieldByName (name: string) -> Option<StructField>\n  fn FieldByNameFunc (match_: fn (param0: string) -> bool) -> Option<StructField>\n  fn In (i: int) -> Type\n  fn Key () -> Type\n  fn Len () -> int\n  fn NumField () -> int\n  fn NumIn () -> int\n  fn NumOut () -> int\n  fn Out (i: int) -> Type\n}\n\nstruct Value{\n\n}\n\nstruct ValueError{\n  Method: string,\n  Kind: Kind\n}"},"io":{"io.brg":"fn Copy  (dst: Writer, src: Reader) -> Result<int64> { EXT }\n\nfn CopyBuffer  (dst: Writer, src: Reader, buf: [byte]) -> Result<int64> { EXT }\n\nfn CopyN  (dst: Writer, src: Reader, n: int64) -> Result<int64> { EXT }\n\nfn LimitReader  (r: Reader, n: int64) -> Reader { EXT }\n\nfn MultiReader  (readers: VarArgs<Reader>) -> Reader { EXT }\n\nfn MultiWriter  (writers: VarArgs<Writer>) -> Writer { EXT }\n\nfn NewSectionReader  (r: ReaderAt, off: int64, n: int64) -> *SectionReader { EXT }\n\nfn NopCloser  (r: Reader) -> ReadCloser { EXT }\n\nfn Pipe  () -> (*PipeReader, *PipeWriter) { EXT }\n\nfn ReadAll  (r: Reader) -> Result<[byte]> { EXT }\n\nfn ReadAtLeast  (r: Reader, buf: [byte], min: int) -> Result<int> { EXT }\n\nfn ReadFull  (r: Reader, buf: [byte]) -> Result<int> { EXT }\n\nfn TeeReader  (r: Reader, w: Writer) -> Reader { EXT }\n\nfn WriteString  (w: Writer, s: string) -> Result<int> { EXT }\n\nimpl (self: LimitedReader) {\n\nfn Read  (p: [byte]) -> Result<int> { EXT }\n\n}\n\nimpl (self: PipeReader) {\n\nfn Close  () -> error { EXT }\n\nfn CloseWithError  (err: error) -> error { EXT }\n\nfn Read  (data: [byte]) -> Result<int> { EXT }\n\n}\n\nimpl (self: PipeWriter) {\n\nfn Close  () -> error { EXT }\n\nfn CloseWithError  (err: error) -> error { EXT }\n\nfn Write  (data: [byte]) -> Result<int> { EXT }\n\n}\n\nimpl (self: SectionReader) {\n\nfn Read  (p: [byte]) -> Result<int> { EXT }\n\nfn ReadAt  (p: [byte], off: int64) -> Result<int> { EXT }\n\nfn Seek  (offset: int64, whence: int) -> Result<int64> { EXT }\n\nfn Size  () -> int64 { EXT }\n\n}\n\ninterface ByteReader {\n\n  fn ReadByte () -> Result<byte>\n}\n\ninterface ByteScanner {\nimpl ByteReader\n  fn UnreadByte () -> error\n}\n\ninterface ByteWriter {\n\n  fn WriteByte (c: byte) -> error\n}\n\ninterface Closer {\n\n  fn Close () -> error\n}\n\nstruct LimitedReader{\n  R: Reader,\n  N: int64\n}\n\nstruct PipeReader{\n\n}\n\nstruct PipeWriter{\n\n}\n\ninterface ReadCloser {\nimpl Reader\nimpl Closer\n\n}\n\ninterface ReadSeekCloser {\nimpl Reader\nimpl Seeker\nimpl Closer\n\n}\n\ninterface ReadSeeker {\nimpl Reader\nimpl Seeker\n\n}\n\ninterface ReadWriteCloser {\nimpl Reader\nimpl Writer\nimpl Closer\n\n}\n\ninterface ReadWriteSeeker {\nimpl Reader\nimpl Writer\nimpl Seeker\n\n}\n\ninterface ReadWriter {\nimpl Reader\nimpl Writer\n\n}\n\ninterface Reader {\n\n  fn Read (p: [byte]) -> Result<int>\n}\n\ninterface ReaderAt {\n\n  fn ReadAt (p: [byte], off: int64) -> Result<int>\n}\n\ninterface ReaderFrom {\n\n  fn ReadFrom (r: Reader) -> Result<int64>\n}\n\ninterface RuneReader {\n\n  fn ReadRune () -> (rune, int, error)\n}\n\ninterface RuneScanner {\nimpl RuneReader\n  fn UnreadRune () -> error\n}\n\nstruct SectionReader{\n\n}\n\ninterface Seeker {\n\n  fn Seek (offset: int64, whence: int) -> Result<int64>\n}\n\ninterface StringWriter {\n\n  fn WriteString (s: string) -> Result<int>\n}\n\ninterface WriteCloser {\nimpl Writer\nimpl Closer\n\n}\n\ninterface WriteSeeker {\nimpl Writer\nimpl Seeker\n\n}\n\ninterface Writer {\n\n  fn Write (p: [byte]) -> Result<int>\n}\n\ninterface WriterAt {\n\n  fn WriteAt (p: [byte], off: int64) -> Result<int>\n}\n\ninterface WriterTo {\n\n  fn WriteTo (w: Writer) -> Result<int64>\n}"},"io/fs":{"fs.brg":"use time\n\n\nfn FileInfoToDirEntry  (info: FileInfo) -> DirEntry { EXT }\n\nfn Glob  (fsys: FS, pattern: string) -> Result<[string]> { EXT }\n\nfn ReadDir  (fsys: FS, name: string) -> Result<[DirEntry]> { EXT }\n\nfn ReadFile  (fsys: FS, name: string) -> Result<[byte]> { EXT }\n\nfn Stat  (fsys: FS, name: string) -> Result<FileInfo> { EXT }\n\nfn Sub  (fsys: FS, dir: string) -> Result<FS> { EXT }\n\nfn ValidPath  (name: string) -> bool { EXT }\n\nfn WalkDir  (fsys: FS, root: string, fn_: WalkDirFunc) -> error { EXT }\n\nimpl (self: FileMode) {\n\nfn IsDir  () -> bool { EXT }\n\nfn IsRegular  () -> bool { EXT }\n\nfn Perm  () -> FileMode { EXT }\n\nfn String  () -> string { EXT }\n\nfn Type  () -> FileMode { EXT }\n\n}\n\nimpl (self: PathError) {\n\nfn Error  () -> string { EXT }\n\nfn Timeout  () -> bool { EXT }\n\nfn Unwrap  () -> error { EXT }\n\n}\n\ntype WalkDirFunc = fn (path: string, d: DirEntry, err: error) -> error\n\nstruct FileMode(uint32)\n\ninterface DirEntry {\n\n  fn Name () -> string\n  fn IsDir () -> bool\n  fn Type () -> FileMode\n  fn Info () -> Result<FileInfo>\n}\n\ninterface FS {\n\n  fn Open (name: string) -> Result<File>\n}\n\ninterface File {\n\n  fn Stat () -> Result<FileInfo>\n  fn Read (param0: [byte]) -> Result<int>\n  fn Close () -> error\n}\n\ninterface FileInfo {\n\n  fn Name () -> string\n  fn Size () -> int64\n  fn Mode () -> FileMode\n  fn ModTime () -> time.Time\n  fn IsDir () -> bool\n  fn Sys () -> any\n}\n\ninterface GlobFS {\nimpl FS\n  fn Glob (pattern: string) -> Result<[string]>\n}\n\nstruct PathError{\n  Op: string,\n  Path: string,\n  Err: error\n}\n\ninterface ReadDirFS {\nimpl FS\n  fn ReadDir (name: string) -> Result<[DirEntry]>\n}\n\ninterface ReadDirFile {\nimpl File\n  fn ReadDir (n: int) -> Result<[DirEntry]>\n}\n\ninterface ReadFileFS {\nimpl FS\n  fn ReadFile (name: string) -> Result<[byte]>\n}\n\ninterface StatFS {\nimpl FS\n  fn Stat (name: string) -> Result<FileInfo>\n}\n\ninterface SubFS {\nimpl FS\n  fn Sub (dir: string) -> Result<FS>\n}","consts.brg":"const ErrInvalid: error = EXT;\nconst SkipDir: error = EXT;\nconst ModeDir: FileMode = EXT;\n"},"math":{"consts.brg":"// These are imported manually...\n\nconst E: float64 = EXT;\nconst Pi: float64 = EXT;\nconst Phi: float64 = EXT;\nconst Sqrt2: float64 = EXT;\nconst SqrtE: float64 = EXT;\nconst SqrtPi: float64 = EXT;\nconst SqrtPhi: float64 = EXT;\nconst Ln2: float64 = EXT;\nconst Log2E: float64 = EXT;\nconst Ln10: float64 = EXT;\nconst Log10E: float64 = EXT;\n","math.brg":"fn Abs  (x: float64) -> float64 { EXT }\n\nfn Acos  (x: float64) -> float64 { EXT }\n\nfn Acosh  (x: float64) -> float64 { EXT }\n\nfn Asin  (x: float64) -> float64 { EXT }\n\nfn Asinh  (x: float64) -> float64 { EXT }\n\nfn Atan  (x: float64) -> float64 { EXT }\n\nfn Atan2  (y: float64, x: float64) -> float64 { EXT }\n\nfn Atanh  (x: float64) -> float64 { EXT }\n\nfn Cbrt  (x: float64) -> float64 { EXT }\n\nfn Ceil  (x: float64) -> float64 { EXT }\n\nfn Copysign  (f: float64, sign: float64) -> float64 { EXT }\n\nfn Cos  (x: float64) -> float64 { EXT }\n\nfn Cosh  (x: float64) -> float64 { EXT }\n\nfn Dim  (x: float64, y: float64) -> float64 { EXT }\n\nfn Erf  (x: float64) -> float64 { EXT }\n\nfn Erfc  (x: float64) -> float64 { EXT }\n\nfn Erfcinv  (x: float64) -> float64 { EXT }\n\nfn Erfinv  (x: float64) -> float64 { EXT }\n\nfn Exp  (x: float64) -> float64 { EXT }\n\nfn Exp2  (x: float64) -> float64 { EXT }\n\nfn Expm1  (x: float64) -> float64 { EXT }\n\nfn FMA  (x: float64, y: float64, z: float64) -> float64 { EXT }\n\nfn Float32bits  (f: float32) -> uint32 { EXT }\n\nfn Float32frombits  (b: uint32) -> float32 { EXT }\n\nfn Float64bits  (f: float64) -> uint64 { EXT }\n\nfn Float64frombits  (b: uint64) -> float64 { EXT }\n\nfn Floor  (x: float64) -> float64 { EXT }\n\nfn Frexp  (f: float64) -> (float64, int) { EXT }\n\nfn Gamma  (x: float64) -> float64 { EXT }\n\nfn Hypot  (p: float64, q: float64) -> float64 { EXT }\n\nfn Ilogb  (x: float64) -> int { EXT }\n\nfn Inf  (sign: int) -> float64 { EXT }\n\nfn IsInf  (f: float64, sign: int) -> bool { EXT }\n\nfn IsNaN  (f: float64) -> bool { EXT }\n\nfn J0  (x: float64) -> float64 { EXT }\n\nfn J1  (x: float64) -> float64 { EXT }\n\nfn Jn  (n: int, x: float64) -> float64 { EXT }\n\nfn Ldexp  (frac: float64, exp: int) -> float64 { EXT }\n\nfn Lgamma  (x: float64) -> (float64, int) { EXT }\n\nfn Log  (x: float64) -> float64 { EXT }\n\nfn Log10  (x: float64) -> float64 { EXT }\n\nfn Log1p  (x: float64) -> float64 { EXT }\n\nfn Log2  (x: float64) -> float64 { EXT }\n\nfn Logb  (x: float64) -> float64 { EXT }\n\nfn Max  (x: float64, y: float64) -> float64 { EXT }\n\nfn Min  (x: float64, y: float64) -> float64 { EXT }\n\nfn Mod  (x: float64, y: float64) -> float64 { EXT }\n\nfn Modf  (f: float64) -> (float64, float64) { EXT }\n\nfn NaN  () -> float64 { EXT }\n\nfn Nextafter  (x: float64, y: float64) -> float64 { EXT }\n\nfn Nextafter32  (x: float32, y: float32) -> float32 { EXT }\n\nfn Pow  (x: float64, y: float64) -> float64 { EXT }\n\nfn Pow10  (n: int) -> float64 { EXT }\n\nfn Remainder  (x: float64, y: float64) -> float64 { EXT }\n\nfn Round  (x: float64) -> float64 { EXT }\n\nfn RoundToEven  (x: float64) -> float64 { EXT }\n\nfn Signbit  (x: float64) -> bool { EXT }\n\nfn Sin  (x: float64) -> float64 { EXT }\n\nfn Sincos  (x: float64) -> float64 { EXT }\n\nfn Sinh  (x: float64) -> float64 { EXT }\n\nfn Sqrt  (x: float64) -> float64 { EXT }\n\nfn Tan  (x: float64) -> float64 { EXT }\n\nfn Tanh  (x: float64) -> float64 { EXT }\n\nfn Trunc  (x: float64) -> float64 { EXT }\n\nfn Y0  (x: float64) -> float64 { EXT }\n\nfn Y1  (x: float64) -> float64 { EXT }\n\nfn Yn  (n: int, x: float64) -> float64 { EXT }"},"math/rand":{"rand.brg":"fn ExpFloat64  () -> float64 { EXT }\n\nfn Float32  () -> float32 { EXT }\n\nfn Float64  () -> float64 { EXT }\n\nfn Int  () -> int { EXT }\n\nfn Int31  () -> int32 { EXT }\n\nfn Int31n  (n: int32) -> int32 { EXT }\n\nfn Int63  () -> int64 { EXT }\n\nfn Int63n  (n: int64) -> int64 { EXT }\n\nfn Intn  (n: int) -> int { EXT }\n\nfn New  (src: Source) -> *Rand { EXT }\n\nfn NewSource  (seed: int64) -> Source { EXT }\n\nfn NewZipf  (r: *Rand, s: float64, v: float64, imax: uint64) -> *Zipf { EXT }\n\nfn NormFloat64  () -> float64 { EXT }\n\nfn Perm  (n: int) -> [int] { EXT }\n\nfn Read  (p: [byte]) -> Result<int> { EXT }\n\nfn Seed  (seed: int64) -> () { EXT }\n\nfn Shuffle  (n: int, swap: fn (i: int, j: int) -> ()) -> () { EXT }\n\nfn Uint32  () -> uint32 { EXT }\n\nfn Uint64  () -> uint64 { EXT }\n\nimpl (self: Rand) {\n\nfn ExpFloat64  () -> float64 { EXT }\n\nfn Float32  () -> float32 { EXT }\n\nfn Float64  () -> float64 { EXT }\n\nfn Int  () -> int { EXT }\n\nfn Int31  () -> int32 { EXT }\n\nfn Int31n  (n: int32) -> int32 { EXT }\n\nfn Int63  () -> int64 { EXT }\n\nfn Int63n  (n: int64) -> int64 { EXT }\n\nfn Intn  (n: int) -> int { EXT }\n\nfn NormFloat64  () -> float64 { EXT }\n\nfn Perm  (n: int) -> [int] { EXT }\n\nfn Read  (p: [byte]) -> Result<int> { EXT }\n\nfn Seed  (seed: int64) -> () { EXT }\n\nfn Shuffle  (n: int, swap: fn (i: int, j: int) -> ()) -> () { EXT }\n\nfn Uint32  () -> uint32 { EXT }\n\nfn Uint64  () -> uint64 { EXT }\n\n}\n\nimpl (self: Zipf) {\n\nfn Uint64  () -> uint64 { EXT }\n\n}\n\nstruct Rand{\n\n}\n\ninterface Source {\n\n  fn Int63 () -> int64\n  fn Seed (seed: int64) -> ()\n}\n\ninterface Source64 {\nimpl Source\n  fn Uint64 () -> uint64\n}\n\nstruct Zipf{\n\n}"},"time":{"time.brg":"fn After  (d: Duration) -> Receiver<Time> { EXT }\n\nfn AfterFunc  (d: Duration, f: fn () -> ()) -> *Timer { EXT }\n\nfn Date  (year: int, month: Month, day: int, hour: int, min: int, sec: int, nsec: int, loc: *Location) -> Time { EXT }\n\nfn FixedZone  (name: string, offset: int) -> *Location { EXT }\n\nfn LoadLocation  (name: string) -> Result<*Location> { EXT }\n\nfn LoadLocationFromTZData  (name: string, data: [byte]) -> Result<*Location> { EXT }\n\nfn NewTicker  (d: Duration) -> *Ticker { EXT }\n\nfn NewTimer  (d: Duration) -> *Timer { EXT }\n\nfn Now  () -> Time { EXT }\n\nfn Parse  (layout: string, value: string) -> Result<Time> { EXT }\n\nfn ParseDuration  (s: string) -> Result<Duration> { EXT }\n\nfn ParseInLocation  (layout: string, value: string, loc: *Location) -> Result<Time> { EXT }\n\nfn Since  (t: Time) -> Duration { EXT }\n\nfn Sleep  (d: Duration) -> () { EXT }\n\nfn Tick  (d: Duration) -> Receiver<Time> { EXT }\n\nfn Unix  (sec: int64, nsec: int64) -> Time { EXT }\n\nfn UnixMicro  (usec: int64) -> Time { EXT }\n\nfn UnixMilli  (msec: int64) -> Time { EXT }\n\nfn Until  (t: Time) -> Duration { EXT }\n\nimpl (self: Duration) {\n\nfn Abs  () -> Duration { EXT }\n\nfn Hours  () -> float64 { EXT }\n\nfn Microseconds  () -> int64 { EXT }\n\nfn Milliseconds  () -> int64 { EXT }\n\nfn Minutes  () -> float64 { EXT }\n\nfn Nanoseconds  () -> int64 { EXT }\n\nfn Round  (m: Duration) -> Duration { EXT }\n\nfn Seconds  () -> float64 { EXT }\n\nfn String  () -> string { EXT }\n\nfn Truncate  (m: Duration) -> Duration { EXT }\n\n}\n\nimpl (self: Location) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: Month) {\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: ParseError) {\n\nfn Error  () -> string { EXT }\n\n}\n\nimpl (self: Ticker) {\n\nfn Reset  (d: Duration) -> () { EXT }\n\nfn Stop  () -> () { EXT }\n\n}\n\nimpl (self: Time) {\n\nfn Add  (d: Duration) -> Time { EXT }\n\nfn AddDate  (years: int, months: int, days: int) -> Time { EXT }\n\nfn After  (u: Time) -> bool { EXT }\n\nfn AppendFormat  (b: [byte], layout: string) -> [byte] { EXT }\n\nfn Before  (u: Time) -> bool { EXT }\n\nfn Clock  () -> int { EXT }\n\nfn Date  () -> (int, Month, int) { EXT }\n\nfn Day  () -> int { EXT }\n\nfn Equal  (u: Time) -> bool { EXT }\n\nfn Format  (layout: string) -> string { EXT }\n\nfn GoString  () -> string { EXT }\n\nfn GobDecode  (data: [byte]) -> error { EXT }\n\nfn GobEncode  () -> Result<[byte]> { EXT }\n\nfn Hour  () -> int { EXT }\n\nfn ISOWeek  () -> int { EXT }\n\nfn In  (loc: *Location) -> Time { EXT }\n\nfn IsDST  () -> bool { EXT }\n\nfn IsZero  () -> bool { EXT }\n\nfn Local  () -> Time { EXT }\n\nfn Location  () -> *Location { EXT }\n\nfn MarshalBinary  () -> Result<[byte]> { EXT }\n\nfn MarshalJSON  () -> Result<[byte]> { EXT }\n\nfn MarshalText  () -> Result<[byte]> { EXT }\n\nfn Minute  () -> int { EXT }\n\nfn Month  () -> Month { EXT }\n\nfn Nanosecond  () -> int { EXT }\n\nfn Round  (d: Duration) -> Time { EXT }\n\nfn Second  () -> int { EXT }\n\nfn String  () -> string { EXT }\n\nfn Sub  (u: Time) -> Duration { EXT }\n\nfn Truncate  (d: Duration) -> Time { EXT }\n\nfn UTC  () -> Time { EXT }\n\nfn Unix  () -> int64 { EXT }\n\nfn UnixMicro  () -> int64 { EXT }\n\nfn UnixMilli  () -> int64 { EXT }\n\nfn UnixNano  () -> int64 { EXT }\n\nfn UnmarshalBinary  (data: [byte]) -> error { EXT }\n\nfn UnmarshalJSON  (data: [byte]) -> error { EXT }\n\nfn UnmarshalText  (data: [byte]) -> error { EXT }\n\nfn Weekday  () -> Weekday { EXT }\n\nfn Year  () -> int { EXT }\n\nfn YearDay  () -> int { EXT }\n\nfn Zone  () -> (string, int) { EXT }\n\nfn ZoneBounds  () -> Time { EXT }\n\n}\n\nimpl (self: Timer) {\n\nfn Reset  (d: Duration) -> bool { EXT }\n\nfn Stop  () -> bool { EXT }\n\n}\n\nimpl (self: Weekday) {\n\nfn String  () -> string { EXT }\n\n}\n\nstruct Duration(int64)\n\nstruct Month(int)\n\nstruct Weekday(int)\n\nstruct Location{\n\n}\n\nstruct ParseError{\n  Layout: string,\n  Value: string,\n  LayoutElem: string,\n  ValueElem: string,\n  Message: string\n}\n\nstruct Ticker{\n  C: Receiver<Time>\n}\n\nstruct Time{\n\n}\n\nstruct Timer{\n  C: Receiver<Time>\n}","consts.brg":"// These are imported manually...\n\nconst Nanosecond: Duration = EXT;\nconst Microsecond: Duration = EXT;\nconst Millisecond: Duration = EXT;\nconst Second: Duration = EXT;\nconst Minute: Duration = EXT;\nconst Hour: Duration = EXT;\n"},"testing":{"testing.brg":"use time\n\n\nfn AllocsPerRun  (runs: int, f: fn () -> ()) -> float64 { EXT }\n\nfn Benchmark  (f: fn (b: *B) -> ()) -> BenchmarkResult { EXT }\n\nfn CoverMode  () -> string { EXT }\n\nfn Coverage  () -> float64 { EXT }\n\nfn Init  () -> () { EXT }\n\nfn Main  (matchString: fn (pat: string, str: string) -> Result<bool>, tests: [InternalTest], benchmarks: [InternalBenchmark], examples: [InternalExample]) -> () { EXT }\n\nfn MainStart  (deps: testDeps, tests: [InternalTest], benchmarks: [InternalBenchmark], fuzzTargets: [InternalFuzzTarget], examples: [InternalExample]) -> *M { EXT }\n\nfn RegisterCover  (c: Cover) -> () { EXT }\n\nfn RunBenchmarks  (matchString: fn (pat: string, str: string) -> Result<bool>, benchmarks: [InternalBenchmark]) -> () { EXT }\n\nfn RunExamples  (matchString: fn (pat: string, str: string) -> Result<bool>, examples: [InternalExample]) -> bool { EXT }\n\nfn RunTests  (matchString: fn (pat: string, str: string) -> Result<bool>, tests: [InternalTest]) -> bool { EXT }\n\nfn Short  () -> bool { EXT }\n\nfn Verbose  () -> bool { EXT }\n\nimpl (self: B) {\n\nfn Cleanup  (f: fn () -> ()) -> () { EXT }\n\nfn Error  (args: VarArgs<any>) -> () { EXT }\n\nfn Errorf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Fail  () -> () { EXT }\n\nfn FailNow  () -> () { EXT }\n\nfn Failed  () -> bool { EXT }\n\nfn Fatal  (args: VarArgs<any>) -> () { EXT }\n\nfn Fatalf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Helper  () -> () { EXT }\n\nfn Log  (args: VarArgs<any>) -> () { EXT }\n\nfn Logf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Name  () -> string { EXT }\n\nfn ReportAllocs  () -> () { EXT }\n\nfn ReportMetric  (n: float64, unit: string) -> () { EXT }\n\nfn ResetTimer  () -> () { EXT }\n\nfn Run  (name: string, f: fn (b: *B) -> ()) -> bool { EXT }\n\nfn RunParallel  (body: fn (param0: *PB) -> ()) -> () { EXT }\n\nfn SetBytes  (n: int64) -> () { EXT }\n\nfn SetParallelism  (p: int) -> () { EXT }\n\nfn Setenv  (key: string, value: string) -> () { EXT }\n\nfn Skip  (args: VarArgs<any>) -> () { EXT }\n\nfn SkipNow  () -> () { EXT }\n\nfn Skipf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Skipped  () -> bool { EXT }\n\nfn StartTimer  () -> () { EXT }\n\nfn StopTimer  () -> () { EXT }\n\nfn TempDir  () -> string { EXT }\n\n}\n\nimpl (self: BenchmarkResult) {\n\nfn AllocedBytesPerOp  () -> int64 { EXT }\n\nfn AllocsPerOp  () -> int64 { EXT }\n\nfn MemString  () -> string { EXT }\n\nfn NsPerOp  () -> int64 { EXT }\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: F) {\n\nfn Add  (args: VarArgs<any>) -> () { EXT }\n\nfn Cleanup  (f: fn () -> ()) -> () { EXT }\n\nfn Error  (args: VarArgs<any>) -> () { EXT }\n\nfn Errorf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Fail  () -> () { EXT }\n\nfn FailNow  () -> () { EXT }\n\nfn Failed  () -> bool { EXT }\n\nfn Fatal  (args: VarArgs<any>) -> () { EXT }\n\nfn Fatalf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Fuzz  (ff: any) -> () { EXT }\n\nfn Helper  () -> () { EXT }\n\nfn Log  (args: VarArgs<any>) -> () { EXT }\n\nfn Logf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Name  () -> string { EXT }\n\nfn Setenv  (key: string, value: string) -> () { EXT }\n\nfn Skip  (args: VarArgs<any>) -> () { EXT }\n\nfn SkipNow  () -> () { EXT }\n\nfn Skipf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Skipped  () -> bool { EXT }\n\nfn TempDir  () -> string { EXT }\n\n}\n\nimpl (self: M) {\n\nfn Run  () -> int { EXT }\n\n}\n\nimpl (self: PB) {\n\nfn Next  () -> bool { EXT }\n\n}\n\nimpl (self: T) {\n\nfn Cleanup  (f: fn () -> ()) -> () { EXT }\n\nfn Deadline  () -> Option<time.Time> { EXT }\n\nfn Error  (args: VarArgs<any>) -> () { EXT }\n\nfn Errorf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Fail  () -> () { EXT }\n\nfn FailNow  () -> () { EXT }\n\nfn Failed  () -> bool { EXT }\n\nfn Fatal  (args: VarArgs<any>) -> () { EXT }\n\nfn Fatalf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Helper  () -> () { EXT }\n\nfn Log  (args: VarArgs<any>) -> () { EXT }\n\nfn Logf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Name  () -> string { EXT }\n\nfn Parallel  () -> () { EXT }\n\nfn Run  (name: string, f: fn (t: *T) -> ()) -> bool { EXT }\n\nfn Setenv  (key: string, value: string) -> () { EXT }\n\nfn Skip  (args: VarArgs<any>) -> () { EXT }\n\nfn SkipNow  () -> () { EXT }\n\nfn Skipf  (format: string, args: VarArgs<any>) -> () { EXT }\n\nfn Skipped  () -> bool { EXT }\n\nfn TempDir  () -> string { EXT }\n\n}\n\nstruct B{\n  N: int\n}\n\nstruct BenchmarkResult{\n  N: int,\n  T: time.Duration,\n  Bytes: int64,\n  MemAllocs: uint64,\n  MemBytes: uint64,\n  Extra: Map<string, float64>\n}\n\nstruct Cover{\n  Mode: string,\n  Counters: Map<string, [uint32]>,\n  Blocks: Map<string, [CoverBlock]>,\n  CoveredPackages: string\n}\n\nstruct CoverBlock{\n  Line0: uint32,\n  Col0: uint16,\n  Line1: uint32,\n  Col1: uint16,\n  Stmts: uint16\n}\n\nstruct F{\n\n}\n\nstruct InternalBenchmark{\n  Name: string,\n  F: fn (b: *B) -> ()\n}\n\nstruct InternalExample{\n  Name: string,\n  F: fn () -> (),\n  Output: string,\n  Unordered: bool\n}\n\nstruct InternalFuzzTarget{\n  Name: string,\n  Fn: fn (f: *F) -> ()\n}\n\nstruct InternalTest{\n  Name: string,\n  F: fn (param0: *T) -> ()\n}\n\nstruct M{\n\n}\n\nstruct PB{\n\n}\n\nstruct T{\n\n}\n\ninterface TB {\n\n  fn Cleanup (param0: fn () -> ()) -> ()\n  fn Error (args: VarArgs<any>) -> ()\n  fn Errorf (format: string, args: VarArgs<any>) -> ()\n  fn Fail () -> ()\n  fn FailNow () -> ()\n  fn Failed () -> bool\n  fn Fatal (args: VarArgs<any>) -> ()\n  fn Fatalf (format: string, args: VarArgs<any>) -> ()\n  fn Helper () -> ()\n  fn Log (args: VarArgs<any>) -> ()\n  fn Logf (format: string, args: VarArgs<any>) -> ()\n  fn Name () -> string\n  fn Setenv (key: string, value: string) -> ()\n  fn Skip (args: VarArgs<any>) -> ()\n  fn SkipNow () -> ()\n  fn Skipf (format: string, args: VarArgs<any>) -> ()\n  fn Skipped () -> bool\n  fn TempDir () -> string\n}"},"unsafe":{"unsafe.brg":"fn Add  (ptr: Pointer, len: IntegerType) -> Pointer { EXT }\n\nfn Alignof  (x: ArbitraryType) -> uintptr { EXT }\n\nfn Offsetof  (x: ArbitraryType) -> uintptr { EXT }\n\nfn Sizeof  (x: ArbitraryType) -> uintptr { EXT }\n\nfn Slice  (ptr: *ArbitraryType, len: IntegerType) -> [ArbitraryType] { EXT }\n\ntype Pointer = *ArbitraryType\n\nstruct ArbitraryType(int)\n\nstruct IntegerType(int)"},"log":{"log.brg":"use io\n\n\nfn Default  () -> *Logger { EXT }\n\nfn Fatal  (v: VarArgs<any>) -> () { EXT }\n\nfn Fatalf  (format: string, v: VarArgs<any>) -> () { EXT }\n\nfn Fatalln  (v: VarArgs<any>) -> () { EXT }\n\nfn Flags  () -> int { EXT }\n\nfn New  (out: io.Writer, prefix: string, flag: int) -> *Logger { EXT }\n\nfn Output  (calldepth: int, s: string) -> error { EXT }\n\nfn Panic  (v: VarArgs<any>) -> () { EXT }\n\nfn Panicf  (format: string, v: VarArgs<any>) -> () { EXT }\n\nfn Panicln  (v: VarArgs<any>) -> () { EXT }\n\nfn Prefix  () -> string { EXT }\n\nfn Print  (v: VarArgs<any>) -> () { EXT }\n\nfn Printf  (format: string, v: VarArgs<any>) -> () { EXT }\n\nfn Println  (v: VarArgs<any>) -> () { EXT }\n\nfn SetFlags  (flag: int) -> () { EXT }\n\nfn SetOutput  (w: io.Writer) -> () { EXT }\n\nfn SetPrefix  (prefix: string) -> () { EXT }\n\nfn Writer  () -> io.Writer { EXT }\n\nimpl (self: Logger) {\n\nfn Fatal  (v: VarArgs<any>) -> () { EXT }\n\nfn Fatalf  (format: string, v: VarArgs<any>) -> () { EXT }\n\nfn Fatalln  (v: VarArgs<any>) -> () { EXT }\n\nfn Flags  () -> int { EXT }\n\nfn Output  (calldepth: int, s: string) -> error { EXT }\n\nfn Panic  (v: VarArgs<any>) -> () { EXT }\n\nfn Panicf  (format: string, v: VarArgs<any>) -> () { EXT }\n\nfn Panicln  (v: VarArgs<any>) -> () { EXT }\n\nfn Prefix  () -> string { EXT }\n\nfn Print  (v: VarArgs<any>) -> () { EXT }\n\nfn Printf  (format: string, v: VarArgs<any>) -> () { EXT }\n\nfn Println  (v: VarArgs<any>) -> () { EXT }\n\nfn SetFlags  (flag: int) -> () { EXT }\n\nfn SetOutput  (w: io.Writer) -> () { EXT }\n\nfn SetPrefix  (prefix: string) -> () { EXT }\n\nfn Writer  () -> io.Writer { EXT }\n\n}\n\nstruct Logger{\n\n}"},"mime/multipart":{"multipart.brg":"use io\nuse net.textproto\n\n\nfn NewReader  (r: io.Reader, boundary: string) -> *Reader { EXT }\n\nfn NewWriter  (w: io.Writer) -> *Writer { EXT }\n\nimpl (self: FileHeader) {\n\nfn Open  () -> Result<File> { EXT }\n\n}\n\nimpl (self: Form) {\n\nfn RemoveAll  () -> error { EXT }\n\n}\n\nimpl (self: Part) {\n\nfn Close  () -> error { EXT }\n\nfn FileName  () -> string { EXT }\n\nfn FormName  () -> string { EXT }\n\nfn Read  (d: [byte]) -> Result<int> { EXT }\n\n}\n\nimpl (self: Reader) {\n\nfn NextPart  () -> Result<*Part> { EXT }\n\nfn NextRawPart  () -> Result<*Part> { EXT }\n\nfn ReadForm  (maxMemory: int64) -> Result<*Form> { EXT }\n\n}\n\nimpl (self: Writer) {\n\nfn Boundary  () -> string { EXT }\n\nfn Close  () -> error { EXT }\n\nfn CreateFormField  (fieldname: string) -> Result<io.Writer> { EXT }\n\nfn CreateFormFile  (fieldname: string, filename: string) -> Result<io.Writer> { EXT }\n\nfn CreatePart  (header: textproto.MIMEHeader) -> Result<io.Writer> { EXT }\n\nfn FormDataContentType  () -> string { EXT }\n\nfn SetBoundary  (boundary: string) -> error { EXT }\n\nfn WriteField  (fieldname: string, value: string) -> error { EXT }\n\n}\n\ninterface File {\nimpl io.Reader\nimpl io.ReaderAt\nimpl io.Seeker\nimpl io.Closer\n\n}\n\nstruct FileHeader{\n  Filename: string,\n  Header: textproto.MIMEHeader,\n  Size: int64\n}\n\nstruct Form{\n  Value: Map<string, [string]>,\n  File: Map<string, [*FileHeader]>\n}\n\nstruct Part{\n  Header: textproto.MIMEHeader\n}\n\nstruct Reader{\n\n}\n\nstruct Writer{\n\n}"},"os":{"consts.brg":"use io.fs;\n\nconst O_RDONLY: int = EXT;\nconst SEEK_SET: int = EXT;\nconst PathSeparator: string = EXT;\nconst ModeDir: fs.FileMode = EXT;\nconst DevNull: string = EXT;\n\nconst ErrInvalid: error = EXT;\nconst Stdin: *File = EXT;\nconst Args: [string] = EXT;\nconst ErrProcessDone: error = EXT;\n","os.brg":"use io\nuse time\n// use syscall\nuse io.fs\n\n\nfn Chdir  (dir: string) -> error { EXT }\n\nfn Chmod  (name: string, mode: FileMode) -> error { EXT }\n\nfn Chown  (name: string, uid: int, gid: int) -> error { EXT }\n\nfn Chtimes  (name: string, atime: time.Time, mtime: time.Time) -> error { EXT }\n\nfn Clearenv  () -> () { EXT }\n\nfn Create  (name: string) -> Result<*File> { EXT }\n\nfn CreateTemp  (dir: string, pattern: string) -> Result<*File> { EXT }\n\nfn DirFS  (dir: string) -> fs.FS { EXT }\n\nfn Environ  () -> [string] { EXT }\n\nfn Executable  () -> Result<string> { EXT }\n\nfn Exit  (code: int) -> () { EXT }\n\nfn Expand  (s: string, mapping: fn (param0: string) -> string) -> string { EXT }\n\nfn ExpandEnv  (s: string) -> string { EXT }\n\nfn FindProcess  (pid: int) -> Result<*Process> { EXT }\n\nfn Getegid  () -> int { EXT }\n\nfn Getenv  (key: string) -> string { EXT }\n\nfn Geteuid  () -> int { EXT }\n\nfn Getgid  () -> int { EXT }\n\nfn Getgroups  () -> Result<[int]> { EXT }\n\nfn Getpagesize  () -> int { EXT }\n\nfn Getpid  () -> int { EXT }\n\nfn Getppid  () -> int { EXT }\n\nfn Getuid  () -> int { EXT }\n\nfn Getwd  () -> Result<string> { EXT }\n\nfn Hostname  () -> Result<string> { EXT }\n\nfn IsExist  (err: error) -> bool { EXT }\n\nfn IsNotExist  (err: error) -> bool { EXT }\n\nfn IsPathSeparator  (c: uint8) -> bool { EXT }\n\nfn IsPermission  (err: error) -> bool { EXT }\n\nfn IsTimeout  (err: error) -> bool { EXT }\n\nfn Lchown  (name: string, uid: int, gid: int) -> error { EXT }\n\nfn Link  (oldname: string, newname: string) -> error { EXT }\n\nfn LookupEnv  (key: string) -> Option<string> { EXT }\n\nfn Lstat  (name: string) -> Result<FileInfo> { EXT }\n\nfn Mkdir  (name: string, perm: FileMode) -> error { EXT }\n\nfn MkdirAll  (path: string, perm: FileMode) -> error { EXT }\n\nfn MkdirTemp  (dir: string, pattern: string) -> Result<string> { EXT }\n\nfn NewFile  (fd: uintptr, name: string) -> *File { EXT }\n\nfn NewSyscallError  (syscall: string, err: error) -> error { EXT }\n\nfn Open  (name: string) -> Result<*File> { EXT }\n\nfn OpenFile  (name: string, flag: int, perm: FileMode) -> Result<*File> { EXT }\n\nfn Pipe  () -> (*File, *File, error) { EXT }\n\nfn ReadDir  (name: string) -> Result<[DirEntry]> { EXT }\n\nfn ReadFile  (name: string) -> Result<[byte]> { EXT }\n\nfn Readlink  (name: string) -> Result<string> { EXT }\n\nfn Remove  (name: string) -> error { EXT }\n\nfn RemoveAll  (path: string) -> error { EXT }\n\nfn Rename  (oldpath: string, newpath: string) -> error { EXT }\n\nfn SameFile  (fi1: FileInfo, fi2: FileInfo) -> bool { EXT }\n\nfn Setenv  (key: string, value: string) -> error { EXT }\n\nfn StartProcess  (name: string, argv: [string], attr: *ProcAttr) -> Result<*Process> { EXT }\n\nfn Stat  (name: string) -> Result<FileInfo> { EXT }\n\nfn Symlink  (oldname: string, newname: string) -> error { EXT }\n\nfn TempDir  () -> string { EXT }\n\nfn Truncate  (name: string, size: int64) -> error { EXT }\n\nfn Unsetenv  (key: string) -> error { EXT }\n\nfn UserCacheDir  () -> Result<string> { EXT }\n\nfn UserConfigDir  () -> Result<string> { EXT }\n\nfn UserHomeDir  () -> Result<string> { EXT }\n\nfn WriteFile  (name: string, data: [byte], perm: FileMode) -> error { EXT }\n\nimpl (self: File) {\n\nfn Chdir  () -> error { EXT }\n\nfn Chmod  (mode: FileMode) -> error { EXT }\n\nfn Chown  (uid: int, gid: int) -> error { EXT }\n\nfn Close  () -> error { EXT }\n\nfn Fd  () -> uintptr { EXT }\n\nfn Name  () -> string { EXT }\n\nfn Read  (b: [byte]) -> Result<int> { EXT }\n\nfn ReadAt  (b: [byte], off: int64) -> Result<int> { EXT }\n\nfn ReadDir  (n: int) -> Result<[DirEntry]> { EXT }\n\nfn ReadFrom  (r: io.Reader) -> Result<int64> { EXT }\n\nfn Readdir  (n: int) -> Result<[FileInfo]> { EXT }\n\nfn Readdirnames  (n: int) -> Result<[string]> { EXT }\n\nfn Seek  (offset: int64, whence: int) -> Result<int64> { EXT }\n\nfn SetDeadline  (t: time.Time) -> error { EXT }\n\nfn SetReadDeadline  (t: time.Time) -> error { EXT }\n\nfn SetWriteDeadline  (t: time.Time) -> error { EXT }\n\nfn Stat  () -> Result<FileInfo> { EXT }\n\nfn Sync  () -> error { EXT }\n\nfn SyscallConn  () -> Result<any> { EXT }\n\nfn Truncate  (size: int64) -> error { EXT }\n\nfn Write  (b: [byte]) -> Result<int> { EXT }\n\nfn WriteAt  (b: [byte], off: int64) -> Result<int> { EXT }\n\nfn WriteString  (s: string) -> Result<int> { EXT }\n\n}\n\nimpl (self: LinkError) {\n\nfn Error  () -> string { EXT }\n\nfn Unwrap  () -> error { EXT }\n\n}\n\nimpl (self: Process) {\n\nfn Kill  () -> error { EXT }\n\nfn Release  () -> error { EXT }\n\nfn Signal  (sig: Signal) -> error { EXT }\n\nfn Wait  () -> Result<*ProcessState> { EXT }\n\n}\n\nimpl (self: ProcessState) {\n\nfn ExitCode  () -> int { EXT }\n\nfn Exited  () -> bool { EXT }\n\nfn Pid  () -> int { EXT }\n\nfn String  () -> string { EXT }\n\nfn Success  () -> bool { EXT }\n\nfn Sys  () -> any { EXT }\n\nfn SysUsage  () -> any { EXT }\n\nfn SystemTime  () -> time.Duration { EXT }\n\nfn UserTime  () -> time.Duration { EXT }\n\n}\n\nimpl (self: SyscallError) {\n\nfn Error  () -> string { EXT }\n\nfn Timeout  () -> bool { EXT }\n\nfn Unwrap  () -> error { EXT }\n\n}\n\ntype DirEntry = fs.DirEntry\n\ntype FileInfo = fs.FileInfo\n\ntype FileMode = fs.FileMode\n\ntype PathError = fs.PathError\n\nstruct File{\n\n}\n\nstruct LinkError{\n  Op: string,\n  Old: string,\n  New: string,\n  Err: error\n}\n\nstruct ProcAttr{\n  Dir: string,\n  Env: [string],\n  Files: [*File],\n  Sys: *any\n}\n\nstruct Process{\n  Pid: int\n}\n\nstruct ProcessState{\n\n}\n\ninterface Signal {\n\n  fn String () -> string\n  fn Signal () -> ()\n}\n\nstruct SyscallError{\n  Syscall: string,\n  Err: error\n}"},"errors":{"errors.brg":"fn As  (err: error, target: any) -> bool { EXT }\n\nfn Is  (err: error, target: error) -> bool { EXT }\n\nfn New  (text: string) -> error { EXT }\n\nfn Unwrap  (err: error) -> error { EXT }"},"sync":{"sync.brg":"fn NewCond  (l: Locker) -> *Cond { EXT }\n\nimpl (self: Cond) {\n\nfn Broadcast  () -> () { EXT }\n\nfn Signal  () -> () { EXT }\n\nfn Wait  () -> () { EXT }\n\n}\n\nimpl (self: Map) {\n\nfn Delete  (key: any) -> () { EXT }\n\nfn Load  (key: any) -> Option<any> { EXT }\n\nfn LoadAndDelete  (key: any) -> Option<any> { EXT }\n\nfn LoadOrStore  (key: any, value: any) -> Option<any> { EXT }\n\nfn Range  (f: fn (key: any, value: any) -> bool) -> () { EXT }\n\nfn Store  (key: any, value: any) -> () { EXT }\n\n}\n\nimpl (self: Mutex) {\n\nfn Lock  () -> () { EXT }\n\nfn TryLock  () -> bool { EXT }\n\nfn Unlock  () -> () { EXT }\n\n}\n\nimpl (self: Once) {\n\nfn Do  (f: fn () -> ()) -> () { EXT }\n\n}\n\nimpl (self: Pool) {\n\nfn Get  () -> any { EXT }\n\nfn Put  (x: any) -> () { EXT }\n\n}\n\nimpl (self: RWMutex) {\n\nfn Lock  () -> () { EXT }\n\nfn RLock  () -> () { EXT }\n\nfn RLocker  () -> Locker { EXT }\n\nfn RUnlock  () -> () { EXT }\n\nfn TryLock  () -> bool { EXT }\n\nfn TryRLock  () -> bool { EXT }\n\nfn Unlock  () -> () { EXT }\n\n}\n\nimpl (self: WaitGroup) {\n\nfn Add  (delta: int) -> () { EXT }\n\nfn Done  () -> () { EXT }\n\nfn Wait  () -> () { EXT }\n\n}\n\nstruct Cond{\n  L: Locker\n}\n\ninterface Locker {\n\n  fn Lock () -> ()\n  fn Unlock () -> ()\n}\n\nstruct Map{\n\n}\n\nstruct Mutex{\n\n}\n\nstruct Once{\n\n}\n\nstruct Pool{\n  New: fn () -> any\n}\n\nstruct RWMutex{\n\n}\n\nstruct WaitGroup{\n\n}"},"syscall":{"syscall.brg":"fn Accept  (fd: Handle) -> (Handle, Sockaddr, error) { EXT }\n\nfn Accept  (fd: Handle) -> (Handle, Sockaddr, error) { EXT }\n\nfn Accept4  (fd: int, flags: int) -> (int, Sockaddr, error) { EXT }\n\nfn AcceptEx  (ls: Handle, as: Handle, buf: *byte, rxdatalen: uint32, laddrlen: uint32, raddrlen: uint32, recvd: *uint32, overlapped: *Overlapped) -> error { EXT }\n\nfn Access  (path: string, mode: uint32) -> error { EXT }\n\nfn Acct  (path: string) -> error { EXT }\n\nfn Adjtime  (delta: *Timeval, olddelta: *Timeval) -> error { EXT }\n\nfn Adjtimex  (buf: *Timex) -> Result<int> { EXT }\n\nfn AllThreadsSyscall  (trap: uintptr, a1: uintptr, a2: uintptr, a3: uintptr) -> (uintptr, Errno) { EXT }\n\nfn AllThreadsSyscall6  (trap: uintptr, a1: uintptr, a2: uintptr, a3: uintptr, a4: uintptr, a5: uintptr, a6: uintptr) -> (uintptr, Errno) { EXT }\n\nfn AttachLsf  (fd: int, i: [SockFilter]) -> error { EXT }\n\nfn Await  (w: *Waitmsg) -> error { EXT }\n\nfn Bind  (fd: int, sa: Sockaddr) -> error { EXT }\n\nfn BindToDevice  (fd: int, device: string) -> error { EXT }\n\nfn BpfBuflen  (fd: int) -> Result<int> { EXT }\n\nfn BpfDatalink  (fd: int) -> Result<int> { EXT }\n\nfn BpfHeadercmpl  (fd: int) -> Result<int> { EXT }\n\nfn BpfInterface  (fd: int, name: string) -> Result<string> { EXT }\n\nfn BpfJump  (code: int, k: int, jt: int, jf: int) -> *BpfInsn { EXT }\n\nfn BpfStats  (fd: int) -> Result<*BpfStat> { EXT }\n\nfn BpfStmt  (code: int, k: int) -> *BpfInsn { EXT }\n\nfn BpfTimeout  (fd: int) -> Result<*Timeval> { EXT }\n\nfn BytePtrFromString  (s: string) -> Result<*byte> { EXT }\n\nfn ByteSliceFromString  (s: string) -> Result<[byte]> { EXT }\n\nfn CancelIo  (s: Handle) -> error { EXT }\n\nfn CancelIoEx  (s: Handle, o: *Overlapped) -> error { EXT }\n\nfn CertAddCertificateContextToStore  (store: Handle, certContext: *CertContext, addDisposition: uint32, storeContext: **CertContext) -> error { EXT }\n\nfn CertCloseStore  (store: Handle, flags: uint32) -> error { EXT }\n\nfn CertCreateCertificateContext  (certEncodingType: uint32, certEncoded: *byte, encodedLen: uint32) -> Result<*CertContext> { EXT }\n\nfn CertEnumCertificatesInStore  (store: Handle, prevContext: *CertContext) -> Result<*CertContext> { EXT }\n\nfn CertFreeCertificateChain  (ctx: *CertChainContext) -> () { EXT }\n\nfn CertFreeCertificateContext  (ctx: *CertContext) -> error { EXT }\n\nfn CertGetCertificateChain  (engine: Handle, leaf: *CertContext, time: *Filetime, additionalStore: Handle, para: *CertChainPara, flags: uint32, reserved: uintptr, chainCtx: **CertChainContext) -> error { EXT }\n\nfn CertOpenStore  (storeProvider: uintptr, msgAndCertEncodingType: uint32, cryptProv: uintptr, flags: uint32, para: uintptr) -> Result<Handle> { EXT }\n\nfn CertOpenSystemStore  (hprov: Handle, name: *uint16) -> Result<Handle> { EXT }\n\nfn CertVerifyCertificateChainPolicy  (policyOID: uintptr, chain: *CertChainContext, para: *CertChainPolicyPara, status: *CertChainPolicyStatus) -> error { EXT }\n\nfn Chdir  (path: string) -> error { EXT }\n\nfn CheckBpfVersion  (fd: int) -> error { EXT }\n\nfn Chflags  (path: string, flags: int) -> error { EXT }\n\nfn Chmod  (path: string, mode: uint32) -> error { EXT }\n\nfn Chown  (path: string, uid: int, gid: int) -> error { EXT }\n\nfn Chroot  (path: string) -> error { EXT }\n\nfn Clearenv  () -> () { EXT }\n\nfn Close  (fd: int) -> error { EXT }\n\nfn CloseHandle  (handle: Handle) -> error { EXT }\n\nfn CloseOnExec  (fd: int) -> () { EXT }\n\nfn Closesocket  (s: Handle) -> error { EXT }\n\nfn CmsgLen  (datalen: int) -> int { EXT }\n\nfn CmsgSpace  (datalen: int) -> int { EXT }\n\nfn CommandLineToArgv  (cmd: *uint16, argc: *int32) -> Result<*[*[uint16]]> { EXT }\n\nfn ComputerName  () -> Result<string> { EXT }\n\nfn Connect  (fd: int, sa: Sockaddr) -> error { EXT }\n\nfn ConnectEx  (fd: Handle, sa: Sockaddr, sendBuf: *byte, sendDataLen: uint32, bytesSent: *uint32, overlapped: *Overlapped) -> error { EXT }\n\nfn ConvertSidToStringSid  (sid: *SID, stringSid: **uint16) -> error { EXT }\n\nfn ConvertStringSidToSid  (stringSid: *uint16, sid: **SID) -> error { EXT }\n\nfn CopySid  (destSidLen: uint32, destSid: *SID, srcSid: *SID) -> error { EXT }\n\nfn Creat  (path: string, mode: uint32) -> Result<int> { EXT }\n\nfn Create  (path: string, mode: int, perm: uint32) -> Result<int> { EXT }\n\nfn CreateDirectory  (path: *uint16, sa: *SecurityAttributes) -> error { EXT }\n\nfn CreateFile  (name: *uint16, access: uint32, mode: uint32, sa: *SecurityAttributes, createmode: uint32, attrs: uint32, templatefile: int32) -> Result<Handle> { EXT }\n\nfn CreateFileMapping  (fhandle: Handle, sa: *SecurityAttributes, prot: uint32, maxSizeHigh: uint32, maxSizeLow: uint32, name: *uint16) -> Result<Handle> { EXT }\n\nfn CreateHardLink  (filename: *uint16, existingfilename: *uint16, reserved: uintptr) -> error { EXT }\n\nfn CreateIoCompletionPort  (filehandle: Handle, cphandle: Handle, key: uint32, threadcnt: uint32) -> Result<Handle> { EXT }\n\nfn CreatePipe  (readhandle: *Handle, writehandle: *Handle, sa: *SecurityAttributes, size: uint32) -> error { EXT }\n\nfn CreateProcess  (appName: *uint16, commandLine: *uint16, procSecurity: *SecurityAttributes, threadSecurity: *SecurityAttributes, inheritHandles: bool, creationFlags: uint32, env: *uint16, currentDir: *uint16, startupInfo: *StartupInfo, outProcInfo: *ProcessInformation) -> error { EXT }\n\nfn CreateProcessAsUser  (token: Token, appName: *uint16, commandLine: *uint16, procSecurity: *SecurityAttributes, threadSecurity: *SecurityAttributes, inheritHandles: bool, creationFlags: uint32, env: *uint16, currentDir: *uint16, startupInfo: *StartupInfo, outProcInfo: *ProcessInformation) -> error { EXT }\n\nfn CreateSymbolicLink  (symlinkfilename: *uint16, targetfilename: *uint16, flags: uint32) -> error { EXT }\n\nfn CreateToolhelp32Snapshot  (flags: uint32, processId: uint32) -> Result<Handle> { EXT }\n\nfn CryptAcquireContext  (provhandle: *Handle, container: *uint16, provider: *uint16, provtype: uint32, flags: uint32) -> error { EXT }\n\nfn CryptGenRandom  (provhandle: Handle, buflen: uint32, buf: *byte) -> error { EXT }\n\nfn CryptReleaseContext  (provhandle: Handle, flags: uint32) -> error { EXT }\n\nfn DeleteFile  (path: *uint16) -> error { EXT }\n\nfn DetachLsf  (fd: int) -> error { EXT }\n\nfn DeviceIoControl  (handle: Handle, ioControlCode: uint32, inBuffer: *byte, inBufferSize: uint32, outBuffer: *byte, outBufferSize: uint32, bytesReturned: *uint32, overlapped: *Overlapped) -> error { EXT }\n\nfn DnsNameCompare  (name1: *uint16, name2: *uint16) -> bool { EXT }\n\nfn DnsQuery  (name: string, qtype: uint16, options: uint32, extra: *byte, qrs: **DNSRecord, pr: *byte) -> error { EXT }\n\nfn DnsRecordListFree  (rl: *DNSRecord, freetype: uint32) -> () { EXT }\n\nfn Dup  (fd: int) -> Result<int> { EXT }\n\nfn Dup2  (from: int, to: int) -> error { EXT }\n\nfn Dup3  (oldfd: int, newfd: int, flags: int) -> error { EXT }\n\nfn DuplicateHandle  (hSourceProcessHandle: Handle, hSourceHandle: Handle, hTargetProcessHandle: Handle, lpTargetHandle: *Handle, dwDesiredAccess: uint32, bInheritHandle: bool, dwOptions: uint32) -> error { EXT }\n\nfn Environ  () -> [string] { EXT }\n\nfn EpollCreate  (size: int) -> Result<int> { EXT }\n\nfn EpollCreate1  (flag: int) -> Result<int> { EXT }\n\nfn EpollCtl  (epfd: int, op: int, fd: int, event: *EpollEvent) -> error { EXT }\n\nfn EpollWait  (epfd: int, events: [EpollEvent], msec: int) -> Result<int> { EXT }\n\nfn EscapeArg  (s: string) -> string { EXT }\n\nfn Exchangedata  (path1: string, path2: string, options: int) -> error { EXT }\n\nfn Exec  (argv0: string, argv: [string], envv: [string]) -> error { EXT }\n\nfn Exit  (code: int) -> () { EXT }\n\nfn ExitProcess  (exitcode: uint32) -> () { EXT }\n\nfn Faccessat  (dirfd: int, path: string, mode: uint32, flags: int) -> error { EXT }\n\nfn Fallocate  (fd: int, mode: uint32, off: int64, len: int64) -> error { EXT }\n\nfn Fchdir  (fd: Handle) -> error { EXT }\n\nfn Fchflags  (fd: int, flags: int) -> error { EXT }\n\nfn Fchmod  (fd: int, mode: uint32) -> error { EXT }\n\nfn Fchmodat  (dirfd: int, path: string, mode: uint32, flags: int) -> error { EXT }\n\nfn Fchown  (fd: int, uid: int, gid: int) -> error { EXT }\n\nfn Fchownat  (dirfd: int, path: string, uid: int, gid: int, flags: int) -> error { EXT }\n\nfn FcntlFlock  (fd: uintptr, cmd: int, lk: *Flock_t) -> error { EXT }\n\nfn Fd2path  (fd: int) -> Result<string> { EXT }\n\nfn Fdatasync  (fd: int) -> error { EXT }\n\nfn FindClose  (handle: Handle) -> error { EXT }\n\nfn FindFirstFile  (name: *uint16, data: *Win32finddata) -> Result<Handle> { EXT }\n\nfn FindNextFile  (handle: Handle, data: *Win32finddata) -> error { EXT }\n\nfn Fixwd  () -> () { EXT }\n\nfn Flock  (fd: int, how: int) -> error { EXT }\n\nfn FlushBpf  (fd: int) -> error { EXT }\n\nfn FlushFileBuffers  (handle: Handle) -> error { EXT }\n\nfn FlushViewOfFile  (addr: uintptr, length: uintptr) -> error { EXT }\n\nfn ForkExec  (argv0: string, argv: [string], attr: *ProcAttr) -> Result<int> { EXT }\n\nfn FormatMessage  (flags: uint32, msgsrc: uint32, msgid: uint32, langid: uint32, buf: [uint16], args: *byte) -> Result<uint32> { EXT }\n\nfn Fpathconf  (fd: int, name: int) -> Result<int> { EXT }\n\nfn FreeAddrInfoW  (addrinfo: *AddrinfoW) -> () { EXT }\n\nfn FreeEnvironmentStrings  (envs: *uint16) -> error { EXT }\n\nfn FreeLibrary  (handle: Handle) -> error { EXT }\n\nfn Fstat  (fd: int, stat: *Stat_t) -> error { EXT }\n\nfn Fstatat  (fd: int, path: string, stat: *Stat_t, flags: int) -> error { EXT }\n\nfn Fstatfs  (fd: int, stat: *Statfs_t) -> error { EXT }\n\nfn Fsync  (fd: int) -> error { EXT }\n\nfn Ftruncate  (fd: int, length: int64) -> error { EXT }\n\nfn FullPath  (name: string) -> Result<string> { EXT }\n\nfn Futimes  (fd: int, tv: [Timeval]) -> error { EXT }\n\nfn Futimesat  (dirfd: int, path: string, tv: [Timeval]) -> error { EXT }\n\nfn Fwstat  (fd: int, edir: [byte]) -> error { EXT }\n\nfn GetAcceptExSockaddrs  (buf: *byte, rxdatalen: uint32, laddrlen: uint32, raddrlen: uint32, lrsa: **RawSockaddrAny, lrsalen: *int32, rrsa: **RawSockaddrAny, rrsalen: *int32) -> () { EXT }\n\nfn GetAdaptersInfo  (ai: *IpAdapterInfo, ol: *uint32) -> error { EXT }\n\nfn GetAddrInfoW  (nodename: *uint16, servicename: *uint16, hints: *AddrinfoW, result: **AddrinfoW) -> error { EXT }\n\nfn GetCommandLine  () -> *uint16 { EXT }\n\nfn GetComputerName  (buf: *uint16, n: *uint32) -> error { EXT }\n\nfn GetConsoleMode  (console: Handle, mode: *uint32) -> error { EXT }\n\nfn GetCurrentDirectory  (buflen: uint32, buf: *uint16) -> Result<uint32> { EXT }\n\nfn GetCurrentProcess  () -> Result<Handle> { EXT }\n\nfn GetEnvironmentStrings  () -> Result<*uint16> { EXT }\n\nfn GetEnvironmentVariable  (name: *uint16, buffer: *uint16, size: uint32) -> Result<uint32> { EXT }\n\nfn GetExitCodeProcess  (handle: Handle, exitcode: *uint32) -> error { EXT }\n\nfn GetFileAttributes  (name: *uint16) -> Result<uint32> { EXT }\n\nfn GetFileAttributesEx  (name: *uint16, level: uint32, info: *byte) -> error { EXT }\n\nfn GetFileInformationByHandle  (handle: Handle, data: *ByHandleFileInformation) -> error { EXT }\n\nfn GetFileType  (filehandle: Handle) -> Result<uint32> { EXT }\n\nfn GetFullPathName  (path: *uint16, buflen: uint32, buf: *uint16, fname: **uint16) -> Result<uint32> { EXT }\n\nfn GetHostByName  (name: string) -> Result<*Hostent> { EXT }\n\nfn GetIfEntry  (pIfRow: *MibIfRow) -> error { EXT }\n\nfn GetLastError  () -> error { EXT }\n\nfn GetLengthSid  (sid: *SID) -> uint32 { EXT }\n\nfn GetLongPathName  (path: *uint16, buf: *uint16, buflen: uint32) -> Result<uint32> { EXT }\n\nfn GetProcAddress  (module: Handle, procname: string) -> Result<uintptr> { EXT }\n\nfn GetProcessTimes  (handle: Handle, creationTime: *Filetime, exitTime: *Filetime, kernelTime: *Filetime, userTime: *Filetime) -> error { EXT }\n\nfn GetProtoByName  (name: string) -> Result<*Protoent> { EXT }\n\nfn GetQueuedCompletionStatus  (cphandle: Handle, qty: *uint32, key: *uint32, overlapped: **Overlapped, timeout: uint32) -> error { EXT }\n\nfn GetServByName  (name: string, proto: string) -> Result<*Servent> { EXT }\n\nfn GetShortPathName  (longpath: *uint16, shortpath: *uint16, buflen: uint32) -> Result<uint32> { EXT }\n\nfn GetStartupInfo  (startupInfo: *StartupInfo) -> error { EXT }\n\nfn GetStdHandle  (stdhandle: int) -> Result<Handle> { EXT }\n\nfn GetSystemTimeAsFileTime  (time: *Filetime) -> () { EXT }\n\nfn GetTempPath  (buflen: uint32, buf: *uint16) -> Result<uint32> { EXT }\n\nfn GetTimeZoneInformation  (tzi: *Timezoneinformation) -> Result<uint32> { EXT }\n\nfn GetTokenInformation  (t: Token, infoClass: uint32, info: *byte, infoLen: uint32, returnedLen: *uint32) -> error { EXT }\n\nfn GetUserNameEx  (nameFormat: uint32, nameBuffre: *uint16, nSize: *uint32) -> error { EXT }\n\nfn GetUserProfileDirectory  (t: Token, dir: *uint16, dirLen: *uint32) -> error { EXT }\n\nfn GetVersion  () -> Result<uint32> { EXT }\n\nfn Getcwd  (buf: [byte]) -> Result<int> { EXT }\n\nfn Getdents  (fd: int, buf: [byte]) -> Result<int> { EXT }\n\nfn Getdirentries  (fd: int, buf: [byte], basep: *uintptr) -> Result<int> { EXT }\n\nfn Getdtablesize  () -> int { EXT }\n\nfn Getegid  () -> int { EXT }\n\nfn Getenv  (key: string) -> Option<string> { EXT }\n\nfn Geteuid  () -> int { EXT }\n\nfn Getexecname  () -> Result<string> { EXT }\n\nfn Getfsstat  (buf: [Statfs_t], flags: int) -> Result<int> { EXT }\n\nfn Getgid  () -> int { EXT }\n\nfn Getgroups  () -> Result<[int]> { EXT }\n\nfn Gethostname  () -> Result<string> { EXT }\n\nfn Getkerninfo  (op: int32, where: uintptr, size: uintptr, arg: int64) -> Result<int32> { EXT }\n\nfn Getpagesize  () -> int { EXT }\n\nfn Getpeername  (fd: int) -> Result<Sockaddr> { EXT }\n\nfn Getpgid  (pid: int) -> Result<int> { EXT }\n\nfn Getpgrp  () -> int { EXT }\n\nfn Getpid  () -> int { EXT }\n\nfn Getppid  () -> int { EXT }\n\nfn Getpriority  (which: int, who: int) -> Result<int> { EXT }\n\nfn Getrlimit  (resource: int, rlim: *Rlimit) -> error { EXT }\n\nfn Getrusage  (who: int, rusage: *Rusage) -> error { EXT }\n\nfn Getsid  (pid: int) -> Result<int> { EXT }\n\nfn Getsockname  (fd: Handle) -> Result<Sockaddr> { EXT }\n\nfn Getsockopt  (s: Handle, level: int32, optname: int32, optval: *byte, optlen: *int32) -> error { EXT }\n\nfn GetsockoptByte  (fd: int, level: int, opt: int) -> Result<byte> { EXT }\n\nfn GetsockoptICMPv6Filter  (fd: int, level: int, opt: int) -> Result<*ICMPv6Filter> { EXT }\n\nfn GetsockoptIPMreq  (fd: int, level: int, opt: int) -> Result<*IPMreq> { EXT }\n\nfn GetsockoptIPMreqn  (fd: int, level: int, opt: int) -> Result<*IPMreqn> { EXT }\n\nfn GetsockoptIPv6MTUInfo  (fd: int, level: int, opt: int) -> Result<*IPv6MTUInfo> { EXT }\n\nfn GetsockoptIPv6Mreq  (fd: int, level: int, opt: int) -> Result<*IPv6Mreq> { EXT }\n\nfn GetsockoptInet4Addr  (fd: int, level: int, opt: int) -> Result<[byte]> { EXT }\n\nfn GetsockoptInt  (fd: int, level: int, opt: int) -> Result<int> { EXT }\n\nfn GetsockoptUcred  (fd: int, level: int, opt: int) -> Result<*Ucred> { EXT }\n\nfn Gettid  () -> int { EXT }\n\nfn Gettimeofday  (tp: *Timeval) -> error { EXT }\n\nfn Getuid  () -> int { EXT }\n\nfn Getwd  () -> Result<string> { EXT }\n\nfn Getxattr  (path: string, attr: string, dest: [byte]) -> Result<int> { EXT }\n\nfn InotifyAddWatch  (fd: int, pathname: string, mask: uint32) -> Result<int> { EXT }\n\nfn InotifyInit  () -> Result<int> { EXT }\n\nfn InotifyInit1  (flags: int) -> Result<int> { EXT }\n\nfn InotifyRmWatch  (fd: int, watchdesc: uint32) -> Result<int> { EXT }\n\nfn Ioperm  (from: int, num: int, on: int) -> error { EXT }\n\nfn Iopl  (level: int) -> error { EXT }\n\nfn Issetugid  () -> bool { EXT }\n\nfn Kevent  (kq: int, changes: [Kevent_t], events: [Kevent_t], timeout: *Timespec) -> Result<int> { EXT }\n\nfn Kill  (pid: int, sig: Signal) -> error { EXT }\n\nfn Klogctl  (typ: int, buf: [byte]) -> Result<int> { EXT }\n\nfn Kqueue  () -> Result<int> { EXT }\n\nfn Lchown  (path: string, uid: int, gid: int) -> error { EXT }\n\nfn Link  (path: string, link: string) -> error { EXT }\n\nfn Listen  (s: int, backlog: int) -> error { EXT }\n\nfn Listxattr  (path: string, dest: [byte]) -> Result<int> { EXT }\n\nfn LoadCancelIoEx  () -> error { EXT }\n\nfn LoadConnectEx  () -> error { EXT }\n\nfn LoadCreateSymbolicLink  () -> error { EXT }\n\nfn LoadDLL  (name: string) -> Result<*DLL> { EXT }\n\nfn LoadGetAddrInfo  () -> error { EXT }\n\nfn LoadLibrary  (libname: string) -> Result<Handle> { EXT }\n\nfn LoadSetFileCompletionNotificationModes  () -> error { EXT }\n\nfn LocalFree  (hmem: Handle) -> Result<Handle> { EXT }\n\nfn LookupAccountName  (systemName: *uint16, accountName: *uint16, sid: *SID, sidLen: *uint32, refdDomainName: *uint16, refdDomainNameLen: *uint32, use_: *uint32) -> error { EXT }\n\nfn LookupAccountSid  (systemName: *uint16, sid: *SID, name: *uint16, nameLen: *uint32, refdDomainName: *uint16, refdDomainNameLen: *uint32, use_: *uint32) -> error { EXT }\n\nfn LookupSID  (system: string, account: string) -> (*SID, string, uint32, error) { EXT }\n\nfn LsfJump  (code: int, k: int, jt: int, jf: int) -> *SockFilter { EXT }\n\nfn LsfSocket  (ifindex: int, proto: int) -> Result<int> { EXT }\n\nfn LsfStmt  (code: int, k: int) -> *SockFilter { EXT }\n\nfn Lstat  (path: string, stat: *Stat_t) -> error { EXT }\n\nfn Madvise  (b: [byte], advice: int) -> error { EXT }\n\nfn MapViewOfFile  (handle: Handle, access: uint32, offsetHigh: uint32, offsetLow: uint32, length: uintptr) -> Result<uintptr> { EXT }\n\nfn Mkdir  (path: string, mode: uint32) -> error { EXT }\n\nfn Mkdirat  (dirfd: int, path: string, mode: uint32) -> error { EXT }\n\nfn Mkfifo  (path: string, mode: uint32) -> error { EXT }\n\nfn Mknod  (path: string, mode: uint32, dev: int) -> error { EXT }\n\nfn Mknodat  (dirfd: int, path: string, mode: uint32, dev: int) -> error { EXT }\n\nfn Mlock  (b: [byte]) -> error { EXT }\n\nfn Mlockall  (flags: int) -> error { EXT }\n\nfn Mmap  (fd: int, offset: int64, length: int, prot: int, flags: int) -> Result<[byte]> { EXT }\n\nfn Mount  (source: string, target: string, fstype: string, flags: uintptr, data: string) -> error { EXT }\n\nfn MoveFile  (from: *uint16, to: *uint16) -> error { EXT }\n\nfn Mprotect  (b: [byte], prot: int) -> error { EXT }\n\nfn Munlock  (b: [byte]) -> error { EXT }\n\nfn Munlockall  () -> error { EXT }\n\nfn Munmap  (b: [byte]) -> error { EXT }\n\nfn MustLoadDLL  (name: string) -> *DLL { EXT }\n\nfn Nanosleep  (time: *Timespec, leftover: *Timespec) -> error { EXT }\n\nfn NetApiBufferFree  (buf: *byte) -> error { EXT }\n\nfn NetGetJoinInformation  (server: *uint16, name: **uint16, bufType: *uint32) -> error { EXT }\n\nfn NetUserGetInfo  (serverName: *uint16, userName: *uint16, level: uint32, buf: **byte) -> error { EXT }\n\nfn NetlinkRIB  (proto: int, family: int) -> Result<[byte]> { EXT }\n\nfn NewCallback  (fn_: any) -> uintptr { EXT }\n\nfn NewCallbackCDecl  (fn_: any) -> uintptr { EXT }\n\nfn NewError  (s: string) -> error { EXT }\n\nfn NewLazyDLL  (name: string) -> *LazyDLL { EXT }\n\nfn NsecToFiletime  (nsec: int64) -> Filetime { EXT }\n\nfn NsecToTimespec  (nsec: int64) -> Timespec { EXT }\n\nfn NsecToTimeval  (nsec: int64) -> Timeval { EXT }\n\nfn Ntohs  (netshort: uint16) -> uint16 { EXT }\n\nfn Open  (path: string, mode: int, perm: uint32) -> Result<int> { EXT }\n\nfn Open  (path: string, mode: int, perm: uint32) -> Result<int> { EXT }\n\nfn OpenCurrentProcessToken  () -> Result<Token> { EXT }\n\nfn OpenProcess  (da: uint32, inheritHandle: bool, pid: uint32) -> Result<Handle> { EXT }\n\nfn OpenProcessToken  (h: Handle, access: uint32, token: *Token) -> error { EXT }\n\nfn Openat  (dirfd: int, path: string, flags: int, mode: uint32) -> Result<int> { EXT }\n\nfn ParseDirent  (buf: [byte], max: int, names: [string]) -> (int, int, [string]) { EXT }\n\nfn ParseNetlinkMessage  (b: [byte]) -> Result<[NetlinkMessage]> { EXT }\n\nfn ParseNetlinkRouteAttr  (m: *NetlinkMessage) -> Result<[NetlinkRouteAttr]> { EXT }\n\nfn ParseRoutingMessage  (b: [byte]) -> Result<[RoutingMessage]> { EXT }\n\nfn ParseRoutingSockaddr  (msg: RoutingMessage) -> Result<[Sockaddr]> { EXT }\n\nfn ParseSocketControlMessage  (b: [byte]) -> Result<[SocketControlMessage]> { EXT }\n\nfn ParseUnixCredentials  (m: *SocketControlMessage) -> Result<*Ucred> { EXT }\n\nfn ParseUnixRights  (m: *SocketControlMessage) -> Result<[int]> { EXT }\n\nfn Pathconf  (path: string, name: int) -> Result<int> { EXT }\n\nfn Pause  () -> error { EXT }\n\nfn Pipe  (p: [int]) -> error { EXT }\n\nfn Pipe2  (p: [int], flags: int) -> error { EXT }\n\nfn PivotRoot  (newroot: string, putold: string) -> error { EXT }\n\nfn PostQueuedCompletionStatus  (cphandle: Handle, qty: uint32, key: uint32, overlapped: *Overlapped) -> error { EXT }\n\nfn Pread  (fd: int, p: [byte], offset: int64) -> Result<int> { EXT }\n\nfn Process32First  (snapshot: Handle, procEntry: *ProcessEntry32) -> error { EXT }\n\nfn Process32Next  (snapshot: Handle, procEntry: *ProcessEntry32) -> error { EXT }\n\nfn PtraceAttach  (pid: int) -> error { EXT }\n\nfn PtraceCont  (pid: int, signal: int) -> error { EXT }\n\nfn PtraceDetach  (pid: int) -> error { EXT }\n\nfn PtraceGetEventMsg  (pid: int) -> Result<uint> { EXT }\n\nfn PtraceGetRegs  (pid: int, regsout: *PtraceRegs) -> error { EXT }\n\nfn PtracePeekData  (pid: int, addr: uintptr, out: [byte]) -> Result<int> { EXT }\n\nfn PtracePeekText  (pid: int, addr: uintptr, out: [byte]) -> Result<int> { EXT }\n\nfn PtracePokeData  (pid: int, addr: uintptr, data: [byte]) -> Result<int> { EXT }\n\nfn PtracePokeText  (pid: int, addr: uintptr, data: [byte]) -> Result<int> { EXT }\n\nfn PtraceSetOptions  (pid: int, options: int) -> error { EXT }\n\nfn PtraceSetRegs  (pid: int, regs: *PtraceRegs) -> error { EXT }\n\nfn PtraceSingleStep  (pid: int) -> error { EXT }\n\nfn PtraceSyscall  (pid: int, signal: int) -> error { EXT }\n\nfn Pwrite  (fd: int, p: [byte], offset: int64) -> Result<int> { EXT }\n\nfn RawSyscall  (trap: uintptr, a1: uintptr, a2: uintptr, a3: uintptr) -> uintptr { EXT }\n\nfn RawSyscall  (trap: uintptr, a1: uintptr, a2: uintptr, a3: uintptr) -> uintptr { EXT }\n\nfn RawSyscall6  (trap: uintptr, a1: uintptr, a2: uintptr, a3: uintptr, a4: uintptr, a5: uintptr, a6: uintptr) -> uintptr { EXT }\n\nfn RawSyscall6  (trap: uintptr, a1: uintptr, a2: uintptr, a3: uintptr, a4: uintptr, a5: uintptr, a6: uintptr) -> uintptr { EXT }\n\nfn Read  (fd: int, p: [byte]) -> Result<int> { EXT }\n\nfn ReadConsole  (console: Handle, buf: *uint16, toread: uint32, read: *uint32, inputControl: *byte) -> error { EXT }\n\nfn ReadDirectoryChanges  (handle: Handle, buf: *byte, buflen: uint32, watchSubTree: bool, mask: uint32, retlen: *uint32, overlapped: *Overlapped, completionRoutine: uintptr) -> error { EXT }\n\nfn ReadDirent  (fd: int, buf: [byte]) -> Result<int> { EXT }\n\nfn ReadFile  (fd: Handle, p: [byte], done: *uint32, overlapped: *Overlapped) -> error { EXT }\n\nfn Readlink  (path: string, buf: [byte]) -> Result<int> { EXT }\n\nfn Reboot  (cmd: int) -> error { EXT }\n\nfn Recvfrom  (fd: int, p: [byte], flags: int) -> (int, Sockaddr, error) { EXT }\n\nfn Recvmsg  (fd: int, p: [byte], oob: [byte], flags: int) -> (int, int, Sockaddr, error) { EXT }\n\nfn RegCloseKey  (key: Handle) -> error { EXT }\n\nfn RegEnumKeyEx  (key: Handle, index: uint32, name: *uint16, nameLen: *uint32, reserved: *uint32, class: *uint16, classLen: *uint32, lastWriteTime: *Filetime) -> error { EXT }\n\nfn RegOpenKeyEx  (key: Handle, subkey: *uint16, options: uint32, desiredAccess: uint32, result: *Handle) -> error { EXT }\n\nfn RegQueryInfoKey  (key: Handle, class: *uint16, classLen: *uint32, reserved: *uint32, subkeysLen: *uint32, maxSubkeyLen: *uint32, maxClassLen: *uint32, valuesLen: *uint32, maxValueNameLen: *uint32, maxValueLen: *uint32, saLen: *uint32, lastWriteTime: *Filetime) -> error { EXT }\n\nfn RegQueryValueEx  (key: Handle, name: *uint16, reserved: *uint32, valtype: *uint32, buf: *byte, buflen: *uint32) -> error { EXT }\n\nfn Remove  (path: string) -> error { EXT }\n\nfn RemoveDirectory  (path: *uint16) -> error { EXT }\n\nfn Removexattr  (path: string, attr: string) -> error { EXT }\n\nfn Rename  (from: string, to: string) -> error { EXT }\n\nfn Renameat  (olddirfd: int, oldpath: string, newdirfd: int, newpath: string) -> error { EXT }\n\nfn Revoke  (path: string) -> error { EXT }\n\nfn Rmdir  (path: string) -> error { EXT }\n\nfn RouteRIB  (facility: int, param: int) -> Result<[byte]> { EXT }\n\nfn Seek  (fd: int, offset: int64, whence: int) -> Result<int64> { EXT }\n\nfn Select  (n: int, r: *FdSet, w: *FdSet, e: *FdSet, timeout: *Timeval) -> error { EXT }\n\nfn Sendfile  (outfd: int, infd: int, offset: *int64, count: int) -> Result<int> { EXT }\n\nfn Sendmsg  (fd: int, p: [byte], oob: [byte], to: Sockaddr, flags: int) -> error { EXT }\n\nfn SendmsgN  (fd: int, p: [byte], oob: [byte], to: Sockaddr, flags: int) -> Result<int> { EXT }\n\nfn Sendto  (fd: int, p: [byte], flags: int, to: Sockaddr) -> error { EXT }\n\nfn SetBpf  (fd: int, i: [BpfInsn]) -> error { EXT }\n\nfn SetBpfBuflen  (fd: int, l: int) -> Result<int> { EXT }\n\nfn SetBpfDatalink  (fd: int, t: int) -> Result<int> { EXT }\n\nfn SetBpfHeadercmpl  (fd: int, f: int) -> error { EXT }\n\nfn SetBpfImmediate  (fd: int, m: int) -> error { EXT }\n\nfn SetBpfInterface  (fd: int, name: string) -> error { EXT }\n\nfn SetBpfPromisc  (fd: int, m: int) -> error { EXT }\n\nfn SetBpfTimeout  (fd: int, tv: *Timeval) -> error { EXT }\n\nfn SetCurrentDirectory  (path: *uint16) -> error { EXT }\n\nfn SetEndOfFile  (handle: Handle) -> error { EXT }\n\nfn SetEnvironmentVariable  (name: *uint16, value: *uint16) -> error { EXT }\n\nfn SetFileAttributes  (name: *uint16, attrs: uint32) -> error { EXT }\n\nfn SetFileCompletionNotificationModes  (handle: Handle, flags: uint8) -> error { EXT }\n\nfn SetFilePointer  (handle: Handle, lowoffset: int32, highoffsetptr: *int32, whence: uint32) -> Result<uint32> { EXT }\n\nfn SetFileTime  (handle: Handle, ctime: *Filetime, atime: *Filetime, wtime: *Filetime) -> error { EXT }\n\nfn SetHandleInformation  (handle: Handle, mask: uint32, flags: uint32) -> error { EXT }\n\nfn SetKevent  (k: *Kevent_t, fd: int, mode: int, flags: int) -> () { EXT }\n\nfn SetLsfPromisc  (name: string, m: bool) -> error { EXT }\n\nfn SetNonblock  (fd: int, nonblocking: bool) -> error { EXT }\n\nfn SetReadDeadline  (fd: int, t: int64) -> error { EXT }\n\nfn SetWriteDeadline  (fd: int, t: int64) -> error { EXT }\n\nfn Setdomainname  (p: [byte]) -> error { EXT }\n\nfn Setegid  (egid: int) -> error { EXT }\n\nfn Setenv  (key: string, value: string) -> error { EXT }\n\nfn Seteuid  (euid: int) -> error { EXT }\n\nfn Setfsgid  (gid: int) -> error { EXT }\n\nfn Setfsuid  (uid: int) -> error { EXT }\n\nfn Setgid  (gid: int) -> error { EXT }\n\nfn Setgroups  (gids: [int]) -> error { EXT }\n\nfn Sethostname  (p: [byte]) -> error { EXT }\n\nfn Setlogin  (name: string) -> error { EXT }\n\nfn Setpgid  (pid: int, pgid: int) -> error { EXT }\n\nfn Setpriority  (which: int, who: int, prio: int) -> error { EXT }\n\nfn Setprivexec  (flag: int) -> error { EXT }\n\nfn Setregid  (rgid: int, egid: int) -> error { EXT }\n\nfn Setresgid  (rgid: int, egid: int, sgid: int) -> error { EXT }\n\nfn Setresuid  (ruid: int, euid: int, suid: int) -> error { EXT }\n\nfn Setreuid  (ruid: int, euid: int) -> error { EXT }\n\nfn Setrlimit  (resource: int, rlim: *Rlimit) -> error { EXT }\n\nfn Setsid  () -> Result<int> { EXT }\n\nfn Setsockopt  (s: Handle, level: int32, optname: int32, optval: *byte, optlen: int32) -> error { EXT }\n\nfn SetsockoptByte  (fd: int, level: int, opt: int, value: byte) -> error { EXT }\n\nfn SetsockoptICMPv6Filter  (fd: int, level: int, opt: int, filter: *ICMPv6Filter) -> error { EXT }\n\nfn SetsockoptIPMreq  (fd: int, level: int, opt: int, mreq: *IPMreq) -> error { EXT }\n\nfn SetsockoptIPMreqn  (fd: int, level: int, opt: int, mreq: *IPMreqn) -> error { EXT }\n\nfn SetsockoptIPv6Mreq  (fd: int, level: int, opt: int, mreq: *IPv6Mreq) -> error { EXT }\n\nfn SetsockoptInet4Addr  (fd: int, level: int, opt: int, value: [byte]) -> error { EXT }\n\nfn SetsockoptInt  (fd: int, level: int, opt: int, value: int) -> error { EXT }\n\nfn SetsockoptLinger  (fd: int, level: int, opt: int, l: *Linger) -> error { EXT }\n\nfn SetsockoptString  (fd: int, level: int, opt: int, s: string) -> error { EXT }\n\nfn SetsockoptTimeval  (fd: int, level: int, opt: int, tv: *Timeval) -> error { EXT }\n\nfn Settimeofday  (tp: *Timeval) -> error { EXT }\n\nfn Setuid  (uid: int) -> error { EXT }\n\nfn Setxattr  (path: string, attr: string, data: [byte], flags: int) -> error { EXT }\n\nfn Shutdown  (s: int, how: int) -> error { EXT }\n\nfn SlicePtrFromStrings  (ss: [string]) -> Result<[*byte]> { EXT }\n\nfn Socket  (domain: int, typ: int, proto: int) -> Result<int> { EXT }\n\nfn Socket  (domain: int, typ: int, proto: int) -> Result<int> { EXT }\n\nfn Socketpair  (domain: int, typ: int, proto: int) -> Result<[int]> { EXT }\n\nfn Splice  (rfd: int, roff: *int64, wfd: int, woff: *int64, len: int, flags: int) -> Result<int64> { EXT }\n\nfn StartProcess  (argv0: string, argv: [string], attr: *ProcAttr) -> (int, uintptr, error) { EXT }\n\nfn Stat  (path: string, stat: *Stat_t) -> error { EXT }\n\nfn Statfs  (path: string, stat: *Statfs_t) -> error { EXT }\n\nfn StopIO  (fd: int) -> error { EXT }\n\nfn StringBytePtr  (s: string) -> *byte { EXT }\n\nfn StringByteSlice  (s: string) -> [byte] { EXT }\n\nfn StringSlicePtr  (ss: [string]) -> [*byte] { EXT }\n\nfn StringToSid  (s: string) -> Result<*SID> { EXT }\n\nfn StringToUTF16  (s: string) -> [uint16] { EXT }\n\nfn StringToUTF16Ptr  (s: string) -> *uint16 { EXT }\n\nfn Symlink  (path: string, link: string) -> error { EXT }\n\nfn Sync  () -> error { EXT }\n\nfn SyncFileRange  (fd: int, off: int64, n: int64, flags: int) -> error { EXT }\n\nfn Syscall  (trap: uintptr, a1: uintptr, a2: uintptr, a3: uintptr) -> (uintptr, ErrorString) { EXT }\n\nfn Syscall  (trap: uintptr, a1: uintptr, a2: uintptr, a3: uintptr) -> (uintptr, ErrorString) { EXT }\n\nfn Syscall12  (trap: uintptr, nargs: uintptr, a1: uintptr, a2: uintptr, a3: uintptr, a4: uintptr, a5: uintptr, a6: uintptr, a7: uintptr, a8: uintptr, a9: uintptr, a10: uintptr, a11: uintptr, a12: uintptr) -> (uintptr, Errno) { EXT }\n\nfn Syscall15  (trap: uintptr, nargs: uintptr, a1: uintptr, a2: uintptr, a3: uintptr, a4: uintptr, a5: uintptr, a6: uintptr, a7: uintptr, a8: uintptr, a9: uintptr, a10: uintptr, a11: uintptr, a12: uintptr, a13: uintptr, a14: uintptr, a15: uintptr) -> (uintptr, Errno) { EXT }\n\nfn Syscall18  (trap: uintptr, nargs: uintptr, a1: uintptr, a2: uintptr, a3: uintptr, a4: uintptr, a5: uintptr, a6: uintptr, a7: uintptr, a8: uintptr, a9: uintptr, a10: uintptr, a11: uintptr, a12: uintptr, a13: uintptr, a14: uintptr, a15: uintptr, a16: uintptr, a17: uintptr, a18: uintptr) -> (uintptr, Errno) { EXT }\n\nfn Syscall6  (trap: uintptr, a1: uintptr, a2: uintptr, a3: uintptr, a4: uintptr, a5: uintptr, a6: uintptr) -> (uintptr, ErrorString) { EXT }\n\nfn Syscall6  (trap: uintptr, a1: uintptr, a2: uintptr, a3: uintptr, a4: uintptr, a5: uintptr, a6: uintptr) -> (uintptr, ErrorString) { EXT }\n\nfn Syscall9  (trap: uintptr, nargs: uintptr, a1: uintptr, a2: uintptr, a3: uintptr, a4: uintptr, a5: uintptr, a6: uintptr, a7: uintptr, a8: uintptr, a9: uintptr) -> (uintptr, Errno) { EXT }\n\nfn SyscallN  (trap: uintptr, args: VarArgs<uintptr>) -> (uintptr, Errno) { EXT }\n\nfn Sysctl  (key: string) -> Result<string> { EXT }\n\nfn SysctlUint32  (name: string) -> Result<uint32> { EXT }\n\nfn Sysinfo  (info: *Sysinfo_t) -> error { EXT }\n\nfn Tee  (rfd: int, wfd: int, len: int, flags: int) -> Result<int64> { EXT }\n\nfn TerminateProcess  (handle: Handle, exitcode: uint32) -> error { EXT }\n\nfn Tgkill  (tgid: int, tid: int, sig: Signal) -> error { EXT }\n\nfn Time  (t: *Time_t) -> Result<Time_t> { EXT }\n\nfn Times  (tms: *Tms) -> Result<uintptr> { EXT }\n\nfn TimespecToNsec  (ts: Timespec) -> int64 { EXT }\n\nfn TimevalToNsec  (tv: Timeval) -> int64 { EXT }\n\nfn TranslateAccountName  (username: string, from: uint32, to: uint32, initSize: int) -> Result<string> { EXT }\n\nfn TranslateName  (accName: *uint16, accNameFormat: uint32, desiredNameFormat: uint32, translatedName: *uint16, nSize: *uint32) -> error { EXT }\n\nfn TransmitFile  (s: Handle, handle: Handle, bytesToWrite: uint32, bytsPerSend: uint32, overlapped: *Overlapped, transmitFileBuf: *TransmitFileBuffers, flags: uint32) -> error { EXT }\n\nfn Truncate  (path: string, length: int64) -> error { EXT }\n\nfn UTF16FromString  (s: string) -> Result<[uint16]> { EXT }\n\nfn UTF16PtrFromString  (s: string) -> Result<*uint16> { EXT }\n\nfn UTF16ToString  (s: [uint16]) -> string { EXT }\n\nfn Umask  (newmask: int) -> int { EXT }\n\nfn Uname  (buf: *Utsname) -> error { EXT }\n\nfn Undelete  (path: string) -> error { EXT }\n\nfn UnixCredentials  (ucred: *Ucred) -> [byte] { EXT }\n\nfn UnixRights  (fds: VarArgs<int>) -> [byte] { EXT }\n\nfn Unlink  (path: string) -> error { EXT }\n\nfn Unlinkat  (dirfd: int, path: string) -> error { EXT }\n\nfn UnmapViewOfFile  (addr: uintptr) -> error { EXT }\n\nfn UnmarshalDir  (b: [byte]) -> Result<*Dir> { EXT }\n\nfn Unmount  (path: string, flags: int) -> error { EXT }\n\nfn Unsetenv  (key: string) -> error { EXT }\n\nfn Unshare  (flags: int) -> error { EXT }\n\nfn Ustat  (dev: int, ubuf: *Ustat_t) -> error { EXT }\n\nfn Utime  (path: string, buf: *Utimbuf) -> error { EXT }\n\nfn Utimes  (path: string, tv: [Timeval]) -> error { EXT }\n\nfn UtimesNano  (path: string, ts: [Timespec]) -> error { EXT }\n\nfn VirtualLock  (addr: uintptr, length: uintptr) -> error { EXT }\n\nfn VirtualUnlock  (addr: uintptr, length: uintptr) -> error { EXT }\n\nfn WSACleanup  () -> error { EXT }\n\nfn WSAEnumProtocols  (protocols: *int32, protocolBuffer: *WSAProtocolInfo, bufferLength: *uint32) -> Result<int32> { EXT }\n\nfn WSAIoctl  (s: Handle, iocc: uint32, inbuf: *byte, cbif: uint32, outbuf: *byte, cbob: uint32, cbbr: *uint32, overlapped: *Overlapped, completionRoutine: uintptr) -> error { EXT }\n\nfn WSARecv  (s: Handle, bufs: *WSABuf, bufcnt: uint32, recvd: *uint32, flags: *uint32, overlapped: *Overlapped, croutine: *byte) -> error { EXT }\n\nfn WSARecvFrom  (s: Handle, bufs: *WSABuf, bufcnt: uint32, recvd: *uint32, flags: *uint32, from: *RawSockaddrAny, fromlen: *int32, overlapped: *Overlapped, croutine: *byte) -> error { EXT }\n\nfn WSASend  (s: Handle, bufs: *WSABuf, bufcnt: uint32, sent: *uint32, flags: uint32, overlapped: *Overlapped, croutine: *byte) -> error { EXT }\n\nfn WSASendTo  (s: Handle, bufs: *WSABuf, bufcnt: uint32, sent: *uint32, flags: uint32, to: *RawSockaddrAny, tolen: int32, overlapped: *Overlapped, croutine: *byte) -> error { EXT }\n\nfn WSASendto  (s: Handle, bufs: *WSABuf, bufcnt: uint32, sent: *uint32, flags: uint32, to: Sockaddr, overlapped: *Overlapped, croutine: *byte) -> error { EXT }\n\nfn WSAStartup  (verreq: uint32, data: *WSAData) -> error { EXT }\n\nfn Wait4  (pid: int, wstatus: *WaitStatus, options: int, rusage: *Rusage) -> Result<int> { EXT }\n\nfn WaitForSingleObject  (handle: Handle, waitMilliseconds: uint32) -> Result<uint32> { EXT }\n\nfn WaitProcess  (pid: int, w: *Waitmsg) -> error { EXT }\n\nfn Write  (fd: int, p: [byte]) -> Result<int> { EXT }\n\nfn WriteConsole  (console: Handle, buf: *uint16, towrite: uint32, written: *uint32, reserved: *byte) -> error { EXT }\n\nfn WriteFile  (fd: Handle, p: [byte], done: *uint32, overlapped: *Overlapped) -> error { EXT }\n\nfn Wstat  (path: string, edir: [byte]) -> error { EXT }\n\nimpl (self: Cmsghdr) {\n\nfn SetLen  (length: int) -> () { EXT }\n\n}\n\nimpl (self: DLL) {\n\nfn FindProc  (name: string) -> Result<*Proc> { EXT }\n\nfn MustFindProc  (name: string) -> *Proc { EXT }\n\nfn Release  () -> error { EXT }\n\n}\n\nimpl (self: DLLError) {\n\nfn Error  () -> string { EXT }\n\nfn Unwrap  () -> error { EXT }\n\n}\n\nimpl (self: Dir) {\n\nfn Marshal  (b: [byte]) -> Result<int> { EXT }\n\nfn Null  () -> () { EXT }\n\n}\n\nimpl (self: Errno) {\n\nfn Error  () -> string { EXT }\n\nfn Is  (target: error) -> bool { EXT }\n\nfn Temporary  () -> bool { EXT }\n\nfn Timeout  () -> bool { EXT }\n\n}\n\nimpl (self: ErrorString) {\n\nfn Error  () -> string { EXT }\n\nfn Is  (target: error) -> bool { EXT }\n\nfn Temporary  () -> bool { EXT }\n\nfn Timeout  () -> bool { EXT }\n\n}\n\nimpl (self: Filetime) {\n\nfn Nanoseconds  () -> int64 { EXT }\n\n}\n\nimpl (self: Iovec) {\n\nfn SetLen  (length: int) -> () { EXT }\n\n}\n\nimpl (self: LazyDLL) {\n\nfn Handle  () -> uintptr { EXT }\n\nfn Load  () -> error { EXT }\n\nfn NewProc  (name: string) -> *LazyProc { EXT }\n\n}\n\nimpl (self: LazyProc) {\n\nfn Addr  () -> uintptr { EXT }\n\nfn Call  (a: VarArgs<uintptr>) -> Result<uintptr> { EXT }\n\nfn Find  () -> error { EXT }\n\n}\n\nimpl (self: Msghdr) {\n\nfn SetControllen  (length: int) -> () { EXT }\n\n}\n\nimpl (self: Note) {\n\nfn Signal  () -> () { EXT }\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: Proc) {\n\nfn Addr  () -> uintptr { EXT }\n\nfn Call  (a: VarArgs<uintptr>) -> (uintptr, uintptr, error) { EXT }\n\n}\n\nimpl (self: PtraceRegs) {\n\nfn GetEra  () -> uint64 { EXT }\n\nfn PC  () -> uint64 { EXT }\n\nfn SetEra  (era: uint64) -> () { EXT }\n\nfn SetPC  (pc: uint64) -> () { EXT }\n\n}\n\nimpl (self: RawSockaddrAny) {\n\nfn Sockaddr  () -> Result<Sockaddr> { EXT }\n\n}\n\nimpl (self: SID) {\n\nfn Copy  () -> Result<*SID> { EXT }\n\nfn Len  () -> int { EXT }\n\nfn LookupAccount  (system: string) -> (string, uint32, error) { EXT }\n\nfn String  () -> Result<string> { EXT }\n\n}\n\nimpl (self: Signal) {\n\nfn Signal  () -> () { EXT }\n\nfn String  () -> string { EXT }\n\n}\n\nimpl (self: StTimespec_t) {\n\nfn Nano  () -> int64 { EXT }\n\nfn Unix  () -> (int64, int64) { EXT }\n\n}\n\nimpl (self: Timespec) {\n\nfn Nano  () -> int64 { EXT }\n\nfn Unix  () -> (int64, int64) { EXT }\n\n}\n\nimpl (self: Timeval) {\n\nfn Nano  () -> int64 { EXT }\n\nfn Nanoseconds  () -> int64 { EXT }\n\nfn Unix  () -> (int64, int64) { EXT }\n\n}\n\nimpl (self: Token) {\n\nfn Close  () -> error { EXT }\n\nfn GetTokenPrimaryGroup  () -> Result<*Tokenprimarygroup> { EXT }\n\nfn GetTokenUser  () -> Result<*Tokenuser> { EXT }\n\nfn GetUserProfileDirectory  () -> Result<string> { EXT }\n\n}\n\nimpl (self: WaitStatus) {\n\nfn Continued  () -> bool { EXT }\n\nfn CoreDump  () -> bool { EXT }\n\nfn ExitStatus  () -> int { EXT }\n\nfn Exited  () -> bool { EXT }\n\nfn Signal  () -> Signal { EXT }\n\nfn Signaled  () -> bool { EXT }\n\nfn StopSignal  () -> Signal { EXT }\n\nfn Stopped  () -> bool { EXT }\n\nfn TrapCause  () -> int { EXT }\n\n}\n\nimpl (self: Waitmsg) {\n\nfn ExitStatus  () -> int { EXT }\n\nfn Exited  () -> bool { EXT }\n\nfn Signaled  () -> bool { EXT }\n\n}\n\ntype Pointer = *()\n\ntype SockaddrGen = [byte]\n\nstruct Errno(uintptr)\n\nstruct ErrorString(string)\n\nstruct Handle(uintptr)\n\nstruct IpMaskString(IpAddressString)\n\nstruct Note(string)\n\nstruct Signal(int)\n\nstruct Time_t(int64)\n\nstruct Token(Handle)\n\nstruct AddrinfoW{\n  Flags: int32,\n  Family: int32,\n  Socktype: int32,\n  Protocol: int32,\n  Addrlen: uintptr,\n  Canonname: *uint16,\n  Addr: Pointer,\n  Next: *AddrinfoW\n}\n\nstruct BpfHdr{\n  Tstamp: BpfTimeval,\n  Caplen: uint32,\n  Datalen: uint32,\n  Hdrlen: uint16,\n  Pad_cgo_0: [byte]\n}\n\nstruct BpfInsn{\n  Code: uint16,\n  Jt: uint8,\n  Jf: uint8,\n  K: uint32\n}\n\nstruct BpfProgram{\n  Len: uint32,\n  Pad_cgo_0: [byte],\n  Insns: *BpfInsn\n}\n\nstruct BpfStat{\n  Recv: uint64,\n  Drop: uint64,\n  Capt: uint64,\n  Padding: [uint64]\n}\n\nstruct BpfTimeval{\n  Sec: int32,\n  Usec: int32\n}\n\nstruct BpfVersion{\n  Major: uint16,\n  Minor: uint16\n}\n\nstruct BpfZbuf{\n  Bufa: *byte,\n  Bufb: *byte,\n  Buflen: uint64\n}\n\nstruct BpfZbufHeader{\n  Kernel_gen: uint32,\n  Kernel_len: uint32,\n  User_gen: uint32,\n  X_bzh_pad: [uint32]\n}\n\nstruct ByHandleFileInformation{\n  FileAttributes: uint32,\n  CreationTime: Filetime,\n  LastAccessTime: Filetime,\n  LastWriteTime: Filetime,\n  VolumeSerialNumber: uint32,\n  FileSizeHigh: uint32,\n  FileSizeLow: uint32,\n  NumberOfLinks: uint32,\n  FileIndexHigh: uint32,\n  FileIndexLow: uint32\n}\n\nstruct CertChainContext{\n  Size: uint32,\n  TrustStatus: CertTrustStatus,\n  ChainCount: uint32,\n  Chains: **CertSimpleChain,\n  LowerQualityChainCount: uint32,\n  LowerQualityChains: **CertChainContext,\n  HasRevocationFreshnessTime: uint32,\n  RevocationFreshnessTime: uint32\n}\n\nstruct CertChainElement{\n  Size: uint32,\n  CertContext: *CertContext,\n  TrustStatus: CertTrustStatus,\n  RevocationInfo: *CertRevocationInfo,\n  IssuanceUsage: *CertEnhKeyUsage,\n  ApplicationUsage: *CertEnhKeyUsage,\n  ExtendedErrorInfo: *uint16\n}\n\nstruct CertChainPara{\n  Size: uint32,\n  RequestedUsage: CertUsageMatch,\n  RequstedIssuancePolicy: CertUsageMatch,\n  URLRetrievalTimeout: uint32,\n  CheckRevocationFreshnessTime: uint32,\n  RevocationFreshnessTime: uint32,\n  CacheResync: *Filetime\n}\n\nstruct CertChainPolicyPara{\n  Size: uint32,\n  Flags: uint32,\n  ExtraPolicyPara: Pointer\n}\n\nstruct CertChainPolicyStatus{\n  Size: uint32,\n  Error: uint32,\n  ChainIndex: uint32,\n  ElementIndex: uint32,\n  ExtraPolicyStatus: Pointer\n}\n\nstruct CertContext{\n  EncodingType: uint32,\n  EncodedCert: *byte,\n  Length: uint32,\n  CertInfo: *CertInfo,\n  Store: Handle\n}\n\nstruct CertEnhKeyUsage{\n  Length: uint32,\n  UsageIdentifiers: **byte\n}\n\nstruct CertInfo{\n\n}\n\nstruct CertRevocationCrlInfo{\n\n}\n\nstruct CertRevocationInfo{\n  Size: uint32,\n  RevocationResult: uint32,\n  RevocationOid: *byte,\n  OidSpecificInfo: Pointer,\n  HasFreshnessTime: uint32,\n  FreshnessTime: uint32,\n  CrlInfo: *CertRevocationCrlInfo\n}\n\nstruct CertSimpleChain{\n  Size: uint32,\n  TrustStatus: CertTrustStatus,\n  NumElements: uint32,\n  Elements: **CertChainElement,\n  TrustListInfo: *CertTrustListInfo,\n  HasRevocationFreshnessTime: uint32,\n  RevocationFreshnessTime: uint32\n}\n\nstruct CertTrustListInfo{\n\n}\n\nstruct CertTrustStatus{\n  ErrorStatus: uint32,\n  InfoStatus: uint32\n}\n\nstruct CertUsageMatch{\n  Type: uint32,\n  Usage: CertEnhKeyUsage\n}\n\nstruct Cmsghdr{\n  Len: uint32,\n  Level: int32,\n  Type: int32\n}\n\ninterface Conn {\n\n  fn SyscallConn () -> Result<RawConn>\n}\n\nstruct Credential{\n  Uid: uint32,\n  Gid: uint32,\n  Groups: [uint32],\n  NoSetGroups: bool\n}\n\nstruct DLL{\n  Name: string,\n  Handle: Handle\n}\n\nstruct DLLError{\n  Err: error,\n  ObjName: string,\n  Msg: string\n}\n\nstruct DNSMXData{\n  NameExchange: *uint16,\n  Preference: uint16,\n  Pad: uint16\n}\n\nstruct DNSPTRData{\n  Host: *uint16\n}\n\nstruct DNSRecord{\n  Next: *DNSRecord,\n  Name: *uint16,\n  Type: uint16,\n  Length: uint16,\n  Dw: uint32,\n  Ttl: uint32,\n  Reserved: uint32,\n  Data: [byte]\n}\n\nstruct DNSSRVData{\n  Target: *uint16,\n  Priority: uint16,\n  Weight: uint16,\n  Port: uint16,\n  Pad: uint16\n}\n\nstruct DNSTXTData{\n  StringCount: uint16,\n  StringArray: [*uint16]\n}\n\nstruct Dir{\n  Type: uint16,\n  Dev: uint32,\n  Qid: Qid,\n  Mode: uint32,\n  Atime: uint32,\n  Mtime: uint32,\n  Length: int64,\n  Name: string,\n  Uid: string,\n  Gid: string,\n  Muid: string\n}\n\nstruct Dirent{\n  Ino: uint64,\n  Off: int64,\n  Reclen: uint16,\n  Name: [int8],\n  Pad_cgo_0: [byte]\n}\n\nstruct EpollEvent{\n  Events: uint32,\n  Fd: int32,\n  Pad: int32\n}\n\nstruct Fbootstraptransfer_t{\n  Offset: int64,\n  Length: uint64,\n  Buffer: *byte\n}\n\nstruct FdSet{\n  Bits: [int64]\n}\n\nstruct FileNotifyInformation{\n  NextEntryOffset: uint32,\n  Action: uint32,\n  FileNameLength: uint32,\n  FileName: uint16\n}\n\nstruct Filetime{\n  LowDateTime: uint32,\n  HighDateTime: uint32\n}\n\nstruct Flock_t{\n  Type: int16,\n  Whence: int16,\n  Pad_cgo_0: [byte],\n  Start: int64,\n  Len: int64,\n  Sysid: int32,\n  Pid: int32,\n  Pad: [int64]\n}\n\nstruct Fsid{\n  Val: [int32]\n}\n\nstruct Fsid64_t{\n  Val: [uint64]\n}\n\nstruct Fstore_t{\n  Flags: uint32,\n  Posmode: int32,\n  Offset: int64,\n  Length: int64,\n  Bytesalloc: int64\n}\n\nstruct GUID{\n  Data1: uint32,\n  Data2: uint16,\n  Data3: uint16,\n  Data4: [byte]\n}\n\nstruct Hostent{\n  Name: *byte,\n  Aliases: **byte,\n  AddrType: uint16,\n  Length: uint16,\n  AddrList: **byte\n}\n\nstruct ICMPv6Filter{\n  X__icmp6_filt: [uint32]\n}\n\nstruct IPMreq{\n  Multiaddr: [byte],\n  Interface: [byte]\n}\n\nstruct IPMreqn{\n  Multiaddr: [byte],\n  Address: [byte],\n  Ifindex: int32\n}\n\nstruct IPv6MTUInfo{\n  Addr: RawSockaddrInet6,\n  Mtu: uint32\n}\n\nstruct IPv6Mreq{\n  Multiaddr: [byte],\n  Interface: uint32\n}\n\nstruct IfAddrmsg{\n  Family: uint8,\n  Prefixlen: uint8,\n  Flags: uint8,\n  Scope: uint8,\n  Index: uint32\n}\n\nstruct IfAnnounceMsghdr{\n  Msglen: uint16,\n  Version: uint8,\n  Type: uint8,\n  Hdrlen: uint16,\n  Index: uint16,\n  What: uint16,\n  Name: [int8]\n}\n\nstruct IfData{\n  Type: uint8,\n  Addrlen: uint8,\n  Hdrlen: uint8,\n  Pad_cgo_0: [byte],\n  Mtu: uint32,\n  Metric: uint32,\n  Baudrate: uint32,\n  Ipackets: uint32,\n  Ierrors: uint32,\n  Opackets: uint32,\n  Oerrors: uint32,\n  Collisions: uint32,\n  Ibytes: uint32,\n  Obytes: uint32,\n  Imcasts: uint32,\n  Omcasts: uint32,\n  Iqdrops: uint32,\n  Noproto: uint32,\n  Lastchange: Timeval32\n}\n\nstruct IfInfomsg{\n  Family: uint8,\n  Type: uint16,\n  Index: int32,\n  Flags: uint32,\n  Change: uint32\n}\n\nstruct IfMsgHdr{\n  Msglen: uint16,\n  Version: uint8,\n  Type: uint8,\n  Addrs: int32,\n  Flags: int32,\n  Index: uint16,\n  Addrlen: uint8,\n  Pad_cgo_0: [byte]\n}\n\nstruct IfMsghdr{\n  Msglen: uint16,\n  Version: uint8,\n  Type: uint8,\n  Addrs: int32,\n  Flags: int32,\n  Index: uint16,\n  Pad_cgo_0: [byte],\n  Data: IfData\n}\n\nstruct IfaMsghdr{\n  Msglen: uint16,\n  Version: uint8,\n  Type: uint8,\n  Addrs: int32,\n  Flags: int32,\n  Index: uint16,\n  Pad_cgo_0: [byte],\n  Metric: int32\n}\n\nstruct IfmaMsghdr{\n  Msglen: uint16,\n  Version: uint8,\n  Type: uint8,\n  Addrs: int32,\n  Flags: int32,\n  Index: uint16,\n  Pad_cgo_0: [byte]\n}\n\nstruct IfmaMsghdr2{\n  Msglen: uint16,\n  Version: uint8,\n  Type: uint8,\n  Addrs: int32,\n  Flags: int32,\n  Index: uint16,\n  Pad_cgo_0: [byte],\n  Refcount: int32\n}\n\nstruct Inet4Pktinfo{\n  Ifindex: int32,\n  Spec_dst: [byte],\n  Addr: [byte]\n}\n\nstruct Inet6Pktinfo{\n  Addr: [byte],\n  Ifindex: uint32\n}\n\nstruct InotifyEvent{\n  Wd: int32,\n  Mask: uint32,\n  Cookie: uint32,\n  Len: uint32\n}\n\nstruct InterfaceAddrMessage{\n  Header: IfaMsghdr,\n  Data: [byte]\n}\n\nstruct InterfaceAnnounceMessage{\n  Header: IfAnnounceMsghdr\n}\n\nstruct InterfaceInfo{\n  Flags: uint32,\n  Address: SockaddrGen,\n  BroadcastAddress: SockaddrGen,\n  Netmask: SockaddrGen\n}\n\nstruct InterfaceMessage{\n  Header: IfMsghdr,\n  Data: [byte]\n}\n\nstruct InterfaceMulticastAddrMessage{\n  Header: IfmaMsghdr,\n  Data: [byte]\n}\n\nstruct Iovec{\n  Base: *int8,\n  Len: uint64\n}\n\nstruct IpAdapterInfo{\n  Next: *IpAdapterInfo,\n  ComboIndex: uint32,\n  AdapterName: [byte],\n  Description: [byte],\n  AddressLength: uint32,\n  Address: [byte],\n  Index: uint32,\n  Type: uint32,\n  DhcpEnabled: uint32,\n  CurrentIpAddress: *IpAddrString,\n  IpAddressList: IpAddrString,\n  GatewayList: IpAddrString,\n  DhcpServer: IpAddrString,\n  HaveWins: bool,\n  PrimaryWinsServer: IpAddrString,\n  SecondaryWinsServer: IpAddrString,\n  LeaseObtained: int64,\n  LeaseExpires: int64\n}\n\nstruct IpAddrString{\n  Next: *IpAddrString,\n  IpAddress: IpAddressString,\n  IpMask: IpMaskString,\n  Context: uint32\n}\n\nstruct IpAddressString{\n  String: [byte]\n}\n\nstruct Kevent_t{\n  Ident: uint64,\n  Filter: int16,\n  Flags: uint16,\n  Fflags: uint32,\n  Data: int64,\n  Udata: *byte\n}\n\nstruct LazyDLL{\n  Name: string\n}\n\nstruct LazyProc{\n  Name: string\n}\n\nstruct Linger{\n  Onoff: int32,\n  Linger: int32\n}\n\nstruct Log2phys_t{\n  Flags: uint32,\n  Contigbytes: int64,\n  Devoffset: int64\n}\n\nstruct Mclpool{\n\n}\n\nstruct MibIfRow{\n  Name: [uint16],\n  Index: uint32,\n  Type: uint32,\n  Mtu: uint32,\n  Speed: uint32,\n  PhysAddrLen: uint32,\n  PhysAddr: [byte],\n  AdminStatus: uint32,\n  OperStatus: uint32,\n  LastChange: uint32,\n  InOctets: uint32,\n  InUcastPkts: uint32,\n  InNUcastPkts: uint32,\n  InDiscards: uint32,\n  InErrors: uint32,\n  InUnknownProtos: uint32,\n  OutOctets: uint32,\n  OutUcastPkts: uint32,\n  OutNUcastPkts: uint32,\n  OutDiscards: uint32,\n  OutErrors: uint32,\n  OutQLen: uint32,\n  DescrLen: uint32,\n  Descr: [byte]\n}\n\nstruct Msghdr{\n  Name: *byte,\n  Namelen: uint32,\n  Pad_cgo_0: [byte],\n  Iov: *Iovec,\n  Iovlen: int32,\n  Pad_cgo_1: [byte],\n  Accrights: *int8,\n  Accrightslen: int32,\n  Pad_cgo_2: [byte]\n}\n\nstruct NetlinkMessage{\n  Header: NlMsghdr,\n  Data: [byte]\n}\n\nstruct NetlinkRouteAttr{\n  Attr: RtAttr,\n  Value: [byte]\n}\n\nstruct NetlinkRouteRequest{\n  Header: NlMsghdr,\n  Data: RtGenmsg\n}\n\nstruct NlAttr{\n  Len: uint16,\n  Type: uint16\n}\n\nstruct NlMsgerr{\n  Error: int32,\n  Msg: NlMsghdr\n}\n\nstruct NlMsghdr{\n  Len: uint32,\n  Type: uint16,\n  Flags: uint16,\n  Seq: uint32,\n  Pid: uint32\n}\n\nstruct Overlapped{\n  Internal: uintptr,\n  InternalHigh: uintptr,\n  Offset: uint32,\n  OffsetHigh: uint32,\n  HEvent: Handle\n}\n\nstruct Proc{\n  Dll: *DLL,\n  Name: string\n}\n\nstruct ProcAttr{\n  Dir: string,\n  Env: [string],\n  Files: [uintptr],\n  Sys: *SysProcAttr\n}\n\nstruct ProcessEntry32{\n  Size: uint32,\n  Usage: uint32,\n  ProcessID: uint32,\n  DefaultHeapID: uintptr,\n  ModuleID: uint32,\n  Threads: uint32,\n  ParentProcessID: uint32,\n  PriClassBase: int32,\n  Flags: uint32,\n  ExeFile: [uint16]\n}\n\nstruct ProcessInformation{\n  Process: Handle,\n  Thread: Handle,\n  ProcessId: uint32,\n  ThreadId: uint32\n}\n\nstruct Protoent{\n  Name: *byte,\n  Aliases: **byte,\n  Proto: uint16\n}\n\nstruct PtraceFpregs{\n  Fpc: uint32,\n  Fprs: [float64]\n}\n\nstruct PtracePer{\n  Control_regs: [uint64],\n  Starting_addr: uint64,\n  Ending_addr: uint64,\n  Perc_atmid: uint16,\n  Address: uint64,\n  Access_id: uint8\n}\n\nstruct PtracePsw{\n  Mask: uint64,\n  Addr: uint64\n}\n\nstruct PtraceRegs{\n  Psw: PtracePsw,\n  Gprs: [uint64],\n  Acrs: [uint32],\n  Orig_gpr2: uint64,\n  Fp_regs: PtraceFpregs,\n  Per_info: PtracePer,\n  Ieee_instruction_pointer: uint64\n}\n\nstruct Qid{\n  Path: uint64,\n  Vers: uint32,\n  Type: uint8\n}\n\nstruct Radvisory_t{\n  Offset: int64,\n  Count: int32,\n  Pad_cgo_0: [byte]\n}\n\ninterface RawConn {\n\n  fn Control (f: fn (fd: uintptr) -> ()) -> error\n  fn Read (f: fn (fd: uintptr) -> bool) -> error\n  fn Write (f: fn (fd: uintptr) -> bool) -> error\n}\n\nstruct RawSockaddr{\n  Family: uint16,\n  Data: [int8]\n}\n\nstruct RawSockaddrAny{\n  Addr: RawSockaddr,\n  Pad: [int8]\n}\n\nstruct RawSockaddrDatalink{\n  Family: uint16,\n  Index: uint16,\n  Type: uint8,\n  Nlen: uint8,\n  Alen: uint8,\n  Slen: uint8,\n  Data: [int8]\n}\n\nstruct RawSockaddrInet4{\n  Family: uint16,\n  Port: uint16,\n  Addr: [byte],\n  Zero: [int8]\n}\n\nstruct RawSockaddrInet6{\n  Family: uint16,\n  Port: uint16,\n  Flowinfo: uint32,\n  Addr: [byte],\n  Scope_id: uint32,\n  X__sin6_src_id: uint32\n}\n\nstruct RawSockaddrLinklayer{\n  Family: uint16,\n  Protocol: uint16,\n  Ifindex: int32,\n  Hatype: uint16,\n  Pkttype: uint8,\n  Halen: uint8,\n  Addr: [uint8]\n}\n\nstruct RawSockaddrNetlink{\n  Family: uint16,\n  Pad: uint16,\n  Pid: uint32,\n  Groups: uint32\n}\n\nstruct RawSockaddrUnix{\n  Family: uint16,\n  Path: [int8]\n}\n\nstruct Rlimit{\n  Cur: uint64,\n  Max: uint64\n}\n\nstruct RouteMessage{\n  Header: RtMsghdr,\n  Data: [byte]\n}\n\ninterface RoutingMessage {\n\n\n}\n\nstruct RtAttr{\n  Len: uint16,\n  Type: uint16\n}\n\nstruct RtGenmsg{\n  Family: uint8\n}\n\nstruct RtMetrics{\n  Locks: uint32,\n  Mtu: uint32,\n  Hopcount: uint32,\n  Expire: uint32,\n  Recvpipe: uint32,\n  Sendpipe: uint32,\n  Ssthresh: uint32,\n  Rtt: uint32,\n  Rttvar: uint32,\n  Pksent: uint32\n}\n\nstruct RtMsg{\n  Family: uint8,\n  Dst_len: uint8,\n  Src_len: uint8,\n  Tos: uint8,\n  Table: uint8,\n  Protocol: uint8,\n  Scope: uint8,\n  Type: uint8,\n  Flags: uint32\n}\n\nstruct RtMsghdr{\n  Msglen: uint16,\n  Version: uint8,\n  Type: uint8,\n  Index: uint16,\n  Pad_cgo_0: [byte],\n  Flags: int32,\n  Addrs: int32,\n  Pid: int32,\n  Seq: int32,\n  Errno: int32,\n  Use: int32,\n  Inits: uint32,\n  Rmx: RtMetrics\n}\n\nstruct RtNexthop{\n  Len: uint16,\n  Flags: uint8,\n  Hops: uint8,\n  Ifindex: int32\n}\n\nstruct Rusage{\n  Utime: Timeval,\n  Stime: Timeval,\n  Maxrss: int64,\n  Ixrss: int64,\n  Idrss: int64,\n  Isrss: int64,\n  Minflt: int64,\n  Majflt: int64,\n  Nswap: int64,\n  Inblock: int64,\n  Oublock: int64,\n  Msgsnd: int64,\n  Msgrcv: int64,\n  Nsignals: int64,\n  Nvcsw: int64,\n  Nivcsw: int64\n}\n\nstruct SID{\n\n}\n\nstruct SIDAndAttributes{\n  Sid: *SID,\n  Attributes: uint32\n}\n\nstruct SSLExtraCertChainPolicyPara{\n  Size: uint32,\n  AuthType: uint32,\n  Checks: uint32,\n  ServerName: *uint16\n}\n\nstruct SecurityAttributes{\n  Length: uint32,\n  SecurityDescriptor: uintptr,\n  InheritHandle: uint32\n}\n\nstruct Servent{\n  Name: *byte,\n  Aliases: **byte,\n  Proto: *byte,\n  Port: uint16\n}\n\nstruct SockFilter{\n  Code: uint16,\n  Jt: uint8,\n  Jf: uint8,\n  K: uint32\n}\n\nstruct SockFprog{\n  Len: uint16,\n  Filter: *SockFilter\n}\n\ninterface Sockaddr {\n\n\n}\n\nstruct SockaddrDatalink{\n  Family: uint16,\n  Index: uint16,\n  Type: uint8,\n  Nlen: uint8,\n  Alen: uint8,\n  Slen: uint8,\n  Data: [int8]\n}\n\nstruct SockaddrInet4{\n  Port: int,\n  Addr: [byte]\n}\n\nstruct SockaddrInet6{\n  Port: int,\n  ZoneId: uint32,\n  Addr: [byte]\n}\n\nstruct SockaddrLinklayer{\n  Protocol: uint16,\n  Ifindex: int,\n  Hatype: uint16,\n  Pkttype: uint8,\n  Halen: uint8,\n  Addr: [byte]\n}\n\nstruct SockaddrNetlink{\n  Family: uint16,\n  Pad: uint16,\n  Pid: uint32,\n  Groups: uint32\n}\n\nstruct SockaddrUnix{\n  Name: string\n}\n\nstruct SocketControlMessage{\n  Header: Cmsghdr,\n  Data: [byte]\n}\n\nstruct StTimespec_t{\n  Sec: int64,\n  Nsec: int32,\n  Pad_cgo_0: [byte]\n}\n\nstruct StartupInfo{\n  Cb: uint32,\n  Desktop: *uint16,\n  Title: *uint16,\n  X: uint32,\n  Y: uint32,\n  XSize: uint32,\n  YSize: uint32,\n  XCountChars: uint32,\n  YCountChars: uint32,\n  FillAttribute: uint32,\n  Flags: uint32,\n  ShowWindow: uint16,\n  StdInput: Handle,\n  StdOutput: Handle,\n  StdErr: Handle\n}\n\nstruct Stat_t{\n  Dev: uint64,\n  Ino: uint64,\n  Mode: uint32,\n  Nlink: uint32,\n  Uid: uint32,\n  Gid: uint32,\n  Rdev: uint64,\n  Size: int64,\n  Atim: Timespec,\n  Mtim: Timespec,\n  Ctim: Timespec,\n  Blksize: int32,\n  Pad_cgo_0: [byte],\n  Blocks: int64,\n  Fstype: [int8]\n}\n\nstruct Statfs_t{\n  F_flags: uint32,\n  F_bsize: uint32,\n  F_iosize: uint32,\n  F_blocks: uint64,\n  F_bfree: uint64,\n  F_bavail: int64,\n  F_files: uint64,\n  F_ffree: uint64,\n  F_favail: int64,\n  F_syncwrites: uint64,\n  F_syncreads: uint64,\n  F_asyncwrites: uint64,\n  F_asyncreads: uint64,\n  F_fsid: Fsid,\n  F_namemax: uint32,\n  F_owner: uint32,\n  F_ctime: uint64,\n  F_fstypename: [int8],\n  F_mntonname: [int8],\n  F_mntfromname: [int8],\n  F_mntfromspec: [int8],\n  Pad_cgo_0: [byte],\n  Mount_info: [byte]\n}\n\nstruct SysProcAttr{\n\n}\n\nstruct SysProcIDMap{\n  ContainerID: int,\n  HostID: int,\n  Size: int\n}\n\nstruct Sysctlnode{\n  Flags: uint32,\n  Num: int32,\n  Name: [int8],\n  Ver: uint32,\n  X__rsvd: uint32,\n  Un: [byte],\n  X_sysctl_size: [byte],\n  X_sysctl_func: [byte],\n  X_sysctl_parent: [byte],\n  X_sysctl_desc: [byte]\n}\n\nstruct Sysinfo_t{\n  Uptime: int64,\n  Loads: [uint64],\n  Totalram: uint64,\n  Freeram: uint64,\n  Sharedram: uint64,\n  Bufferram: uint64,\n  Totalswap: uint64,\n  Freeswap: uint64,\n  Procs: uint16,\n  Pad: uint16,\n  Totalhigh: uint64,\n  Freehigh: uint64,\n  Unit: uint32\n}\n\nstruct Systemtime{\n  Year: uint16,\n  Month: uint16,\n  DayOfWeek: uint16,\n  Day: uint16,\n  Hour: uint16,\n  Minute: uint16,\n  Second: uint16,\n  Milliseconds: uint16\n}\n\nstruct TCPInfo{\n  State: uint8,\n  Ca_state: uint8,\n  Retransmits: uint8,\n  Probes: uint8,\n  Backoff: uint8,\n  Options: uint8,\n  Rto: uint32,\n  Ato: uint32,\n  Snd_mss: uint32,\n  Rcv_mss: uint32,\n  Unacked: uint32,\n  Sacked: uint32,\n  Lost: uint32,\n  Retrans: uint32,\n  Fackets: uint32,\n  Last_data_sent: uint32,\n  Last_ack_sent: uint32,\n  Last_data_recv: uint32,\n  Last_ack_recv: uint32,\n  Pmtu: uint32,\n  Rcv_ssthresh: uint32,\n  Rtt: uint32,\n  Rttvar: uint32,\n  Snd_ssthresh: uint32,\n  Snd_cwnd: uint32,\n  Advmss: uint32,\n  Reordering: uint32,\n  Rcv_rtt: uint32,\n  Rcv_space: uint32,\n  Total_retrans: uint32\n}\n\nstruct TCPKeepalive{\n  OnOff: uint32,\n  Time: uint32,\n  Interval: uint32\n}\n\nstruct Termios{\n  Iflag: uint32,\n  Oflag: uint32,\n  Cflag: uint32,\n  Lflag: uint32,\n  Cc: [uint8],\n  Pad_cgo_0: [byte]\n}\n\nstruct Timespec{\n  Sec: int64,\n  Nsec: int64\n}\n\nstruct Timeval{\n  Sec: int64,\n  Usec: int64\n}\n\nstruct Timeval32{\n  Sec: int32,\n  Usec: int32\n}\n\nstruct Timex{\n  Modes: uint32,\n  Offset: int64,\n  Freq: int64,\n  Maxerror: int64,\n  Esterror: int64,\n  Status: int32,\n  Constant: int64,\n  Precision: int64,\n  Tolerance: int64,\n  Time: Timeval,\n  Tick: int64,\n  Ppsfreq: int64,\n  Jitter: int64,\n  Shift: int32,\n  Stabil: int64,\n  Jitcnt: int64,\n  Calcnt: int64,\n  Errcnt: int64,\n  Stbcnt: int64,\n  Tai: int32\n}\n\nstruct Timezone{\n  Minuteswest: int32,\n  Dsttime: int32\n}\n\nstruct Timezoneinformation{\n  Bias: int32,\n  StandardName: [uint16],\n  StandardDate: Systemtime,\n  StandardBias: int32,\n  DaylightName: [uint16],\n  DaylightDate: Systemtime,\n  DaylightBias: int32\n}\n\nstruct Tms{\n  Utime: int64,\n  Stime: int64,\n  Cutime: int64,\n  Cstime: int64\n}\n\nstruct Tokenprimarygroup{\n  PrimaryGroup: *SID\n}\n\nstruct Tokenuser{\n  User: SIDAndAttributes\n}\n\nstruct TransmitFileBuffers{\n  Head: uintptr,\n  HeadLength: uint32,\n  Tail: uintptr,\n  TailLength: uint32\n}\n\nstruct Ucred{\n  Pid: int32,\n  Uid: uint32,\n  Gid: uint32\n}\n\nstruct UserInfo10{\n  Name: *uint16,\n  Comment: *uint16,\n  UsrComment: *uint16,\n  FullName: *uint16\n}\n\nstruct Ustat_t{\n  Tfree: int32,\n  Tinode: uint64,\n  Fname: [uint8],\n  Fpack: [uint8]\n}\n\nstruct Utimbuf{\n  Actime: int64,\n  Modtime: int64\n}\n\nstruct Utsname{\n  Sysname: [uint8],\n  Nodename: [uint8],\n  Release: [uint8],\n  Version: [uint8],\n  Machine: [uint8],\n  Domainname: [uint8]\n}\n\nstruct WSABuf{\n  Len: uint32,\n  Buf: *byte\n}\n\nstruct WSAData{\n  Version: uint16,\n  HighVersion: uint16,\n  MaxSockets: uint16,\n  MaxUdpDg: uint16,\n  VendorInfo: *byte,\n  Description: [byte],\n  SystemStatus: [byte]\n}\n\nstruct WSAProtocolChain{\n  ChainLen: int32,\n  ChainEntries: [uint32]\n}\n\nstruct WSAProtocolInfo{\n  ServiceFlags1: uint32,\n  ServiceFlags2: uint32,\n  ServiceFlags3: uint32,\n  ServiceFlags4: uint32,\n  ProviderFlags: uint32,\n  ProviderId: GUID,\n  CatalogEntryId: uint32,\n  ProtocolChain: WSAProtocolChain,\n  Version: int32,\n  AddressFamily: int32,\n  MaxSockAddr: int32,\n  MinSockAddr: int32,\n  SocketType: int32,\n  Protocol: int32,\n  ProtocolMaxOffset: int32,\n  NetworkByteOrder: int32,\n  SecurityScheme: int32,\n  MessageSize: uint32,\n  ProviderReserved: uint32,\n  ProtocolName: [uint16]\n}\n\nstruct WaitStatus{\n  ExitCode: uint32\n}\n\nstruct Waitmsg{\n  Pid: int,\n  Time: [uint32],\n  Msg: string\n}\n\nstruct Win32FileAttributeData{\n  FileAttributes: uint32,\n  CreationTime: Filetime,\n  LastAccessTime: Filetime,\n  LastWriteTime: Filetime,\n  FileSizeHigh: uint32,\n  FileSizeLow: uint32\n}\n\nstruct Win32finddata{\n  FileAttributes: uint32,\n  CreationTime: Filetime,\n  LastAccessTime: Filetime,\n  LastWriteTime: Filetime,\n  FileSizeHigh: uint32,\n  FileSizeLow: uint32,\n  Reserved0: uint32,\n  Reserved1: uint32,\n  FileName: [uint16],\n  AlternateFileName: [uint16]\n}"}}