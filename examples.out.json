[{"title":"Basics","code":"fn borgo_main() {\n    // Int\n    (1 + 1).inspect();\n\n    // String\n    \"Hello world\".inspect();\n\n    // Bool\n    (true || false).inspect();\n\n    // Char\n    'a'.inspect();\n\n    // List\n    [1, 2, 3].inspect();\n\n    // Sequence\n    [1, 2, 3].seq().map(|x| x * 3).inspect();\n\n    // Map\n    Map::new()\n        .insert(\"foo\", 1)\n        .insert(\"bar\", 2)\n        .insert(\"baz\", 3)\n        .inspect();\n\n    // Set\n    Set::new().insert(1).insert(1).inspect();\n\n    // Option\n    [1, 2, 3].seq().first().inspect();\n\n    // Result\n    None.ok_or(\"that's an error\").inspect();\n\n    // Tuples\n    (1, \"a\", true).inspect();\n\n    ()\n}\n"},{"title":"Custom types","code":"enum User {\n    Verified(String),\n    NotVerified,\n}\n\nfn is_verified(u: User) -> Bool {\n    match u {\n        User::Verified(_) => true,\n        User::NotVerified => false,\n    }\n}\n\nstruct Point {\n    x: Int,\n    y: Float,\n}\n\nfn borgo_main() {\n    let alice = User::Verified(\"alice\");\n    let a_point = Point { x: 1, y: 5.2 };\n\n    Debug::assert_eq(is_verified(alice), true);\n\n    // equivalent to above\n    alice.is_verified().assert_eq(true);\n\n    Debug::inspect(alice);\n    a_point.inspect();\n\n    ()\n}\n"},{"title":"Collections","code":"// All collections are immutable\n\nfn borgo_main() {\n    // List\n    let xs = [7, 8, 9];\n\n    xs.get(0).assert_eq(Some(7));\n    xs.get(1).assert_eq(Some(8));\n    xs.get(4).assert_eq(None);\n\n    \"New list:\".inspect();\n    xs.push(10).inspect();\n    \"Original:\".inspect();\n    xs.inspect();\n\n    // Map\n    let m = Map::new().insert(\"b\", 1).insert(\"c\", 2);\n\n    m.get(\"b\").assert_eq(Some(1));\n    m.get(\"missing\").assert_eq(None);\n\n    \"New map:\".inspect();\n    m.insert(\"d\", 3).inspect();\n    \"Original:\".inspect();\n    m.inspect();\n\n    // Set\n    \"Set:\".inspect();\n    Set::new().insert(55).insert(22).insert(55).inspect();\n\n    ()\n}\n"},{"title":"Sequences","code":"// `Seq<T>` represents a lazy sequence.\n\nfn borgo_main() {\n    let xs = [1, 2, 3, 4, 5];\n\n    let s = xs.seq().map(|n| n + 1).inspect();\n\n    // Turn a Seq back into a list\n    let xs2 = s.to_list();\n\n    ()\n}\n"},{"title":"AoC 2022 #1","code":"// Advent of Code 2022 - Day 01\n\nconst input: String = \"1000\n2000\n3000\n\n4000\n\n5000\n6000\n\n7000\n8000\n9000\n\n10000\";\n\nfn borgo_main() {\n    let solution = input\n        .split(\"\\n\\n\")\n        .map(|group| {\n            group\n                .split(\"\\n\")\n                .map(|x| String::parse_int(x).unwrap())\n                .sum()\n        })\n        .max_by(Int::cmp)\n        .unwrap();\n\n    solution.inspect();\n    solution.assert_eq(24000);\n}\n"},{"title":"AoC 2022 #2","code":"// Advent of Code 2022 - Day 02\n\nconst input: String = \"A Y\nB X\nC Z\";\n\nenum Hand {\n    Rock,\n    Paper,\n    Scissors,\n}\n\nenum GameResult {\n    Win,\n    Lose,\n    Draw,\n}\n\nimpl Hand {\n    fn parse(s: String) -> Option<Hand> {\n        match s {\n            \"A\" => Some(Rock),\n            \"X\" => Some(Rock),\n            \"B\" => Some(Paper),\n            \"Y\" => Some(Paper),\n            \"C\" => Some(Scissors),\n            \"Z\" => Some(Scissors),\n            _ => None,\n        }\n    }\n\n    fn play_against(self, other: Hand) -> GameResult {\n        match (self, other) {\n            (Rock, Scissors) => Win,\n            (Rock, Paper) => Lose,\n            (Scissors, Paper) => Win,\n            (Scissors, Rock) => Lose,\n            (Paper, Rock) => Win,\n            (Paper, Scissors) => Lose,\n            _ => Draw,\n        }\n    }\n\n    fn value(self) -> Int {\n        match self {\n            Rock => 1,\n            Paper => 2,\n            Scissors => 3,\n        }\n    }\n\n    fn score_against(self, other: Hand) -> Int {\n        let score = match self.play_against(other) {\n            Win => 6,\n            Draw => 3,\n            Lose => 0,\n        };\n\n        self.value() + score\n    }\n}\n\nfn borgo_main() {\n    let total = input\n        .split(\"\\n\")\n        .map(|turn| {\n            let hands = turn.split(\" \");\n            let a = Hand::parse(hands.get(0).unwrap()).unwrap();\n            let b = Hand::parse(hands.get(1).unwrap()).unwrap();\n\n            a.score_against(b)\n        })\n        .sum();\n\n    total.inspect().assert_eq(15);\n}\n"},{"title":"AoC 2022 #3","code":"// Advent of Code 2022 - Day 03\n\nconst input: String = \"vJrwpWtwJgWrhcsFMMfFFhFp\njqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL\nPmmdzqPrVvPwwTWBwg\nwMqvLMZHhHMvwLHjbvcjnnSBnvTQFn\nttgJtRGJQctTZtZT\nCrZsJsPPZsGzwwsLwLmpwMDw\";\n\nfn borgo_main() {\n    let a = 'a'.to_int() - 1;\n    let z = 'z'.to_int();\n    let big_a = 'A'.to_int() - 1;\n\n    let result = input\n        .split(\"\\n\")\n        .map(|line| {\n            let items = line.chars();\n            let (fst_half, snd_half) = items.split_at(items.len() / 2);\n            let items_in_rucksack = fst_half.to_set();\n\n            let common = snd_half\n                .find_map(|c| {\n                    if items_in_rucksack.contains(c) {\n                        return Some(c.to_int());\n                    }\n\n                    None\n                })\n                .unwrap();\n\n            if common >= a && common <= z {\n                common - a\n            } else {\n                common - big_a + 26\n            }\n        })\n        .sum();\n\n    result.inspect().assert_eq(157);\n    ()\n}\n"},{"title":"AoC 2022 #4","code":"// Advent of Code 2022 - Day 04\n\nconst input: String = \"2-4,6-8\n2-3,4-5\n5-7,7-9\n2-8,3-7\n6-6,4-6\n2-6,4-8\";\n\nstruct Part {\n    start: Int,\n    end: Int,\n}\n\nimpl Part {\n    fn parse(s: String) -> Part {\n        let parts = s.split(\"-\");\n\n        Part {\n            start: parts.get(0).and_then(String::parse_int).unwrap(),\n            end: parts.get(1).and_then(String::parse_int).unwrap(),\n        }\n    }\n\n    fn contains(self, other: Part) -> Bool {\n        self.start <= other.start && self.end >= other.end\n    }\n}\n\nfn borgo_main() {\n    let result = input\n        .split(\"\\n\")\n        .map(|line| {\n            let parts = line.split(\",\");\n            let first = Part::parse(parts.get(0).unwrap());\n            let second = Part::parse(parts.get(1).unwrap());\n            (first, second)\n        })\n        .reduce(0, |acc, (first, second)| {\n            if first.contains(second) || second.contains(first) {\n                acc + 1\n            } else {\n                acc\n            }\n        });\n\n    result.inspect().assert_eq(2);\n    ()\n}\n"},{"title":"AoC 2022 #5","code":"// Advent of Code 2022 - Day 05\n\nconst input: String = \"    [D]    \n[N] [C]    \n[Z] [M] [P]\n 1   2   3 \n\nmove 1 from 2 to 1\nmove 3 from 1 to 3\nmove 2 from 2 to 1\nmove 1 from 1 to 2\";\n\nstruct Cmd {\n    count: Int,\n    from: Int,\n    to: Int,\n}\n\nfn parse_stacks(s: String) -> Map<Int, List<Char>> {\n    let rows = s.split(\"\\n\");\n    let rows = rows\n        .take(rows.len() - 1)\n        .map(|row| {\n            row.chars()\n                .chunks(4)\n                .filter_map(|chars| chars.filter(|c| c != '[' && c != ']').first())\n        })\n        .reverse();\n\n    let mut m = Map::new();\n\n    for row in rows {\n        for (index, c) in row.enumerate() {\n            if c != ' ' {\n                m = m.update(index + 1, [], |stack| stack.push(c));\n            }\n        }\n    }\n\n    m\n}\n\nfn parse_commands(s: String) -> Seq<Cmd> {\n    s.split(\"\\n\").map(|row| {\n        let parts = row.split(\" \");\n\n        fn parse(index: Int) -> Int {\n            parts.get(index).and_then(String::parse_int).unwrap()\n        }\n\n        let count = parse(1);\n        let from = parse(3);\n        let to = parse(5);\n        Cmd { count, from, to }\n    })\n}\n\nfn run_commands(stacks: Map<Int, List<Char>>, cmds: Seq<Cmd>) -> Map<Int, List<Char>> {\n    cmds.reduce(stacks, |mut new_stacks, cmd| {\n        let mut remaining = cmd.count;\n\n        loop {\n            if remaining == 0 {\n                break;\n            }\n\n            let from = new_stacks.get(cmd.from).unwrap();\n            let to = new_stacks.get(cmd.to).unwrap();\n            let item = from.seq().last().unwrap();\n\n            new_stacks = new_stacks\n                .insert(cmd.from, from.pop())\n                .insert(cmd.to, to.push(item));\n\n            remaining = remaining - 1;\n        }\n\n        return new_stacks;\n    })\n}\n\nfn borgo_main() {\n    let parts = input.split(\"\\n\\n\").to_list();\n\n    let stacks = parse_stacks(parts.get(0).unwrap());\n    let commands = parse_commands(parts.get(1).unwrap());\n    let result = run_commands(stacks, commands)\n        .seq_values()\n        .map(|stack| stack.seq().last().unwrap())\n        .to_list();\n\n    result.inspect().assert_eq(['C', 'M', 'Z']);\n}\n"},{"title":"AoC 2022 #6","code":"// Advent of Code 2022 - Day 06\n\nfn solve(input: String, n_different: Int) -> Int {\n    let target = input\n        .chars()\n        .map(|c| c.to_unquoted_string())\n        .windows(n_different)\n        .filter(find_different)\n        .first()\n        .unwrap();\n\n    input.index_of(target.join(\"\")).unwrap() + n_different\n}\n\nfn find_different(chunk: Seq<String>) -> Bool {\n    let unique = chunk.to_set();\n    unique.len() == chunk.len()\n}\n\nfn borgo_main() {\n    solve(\"bvwbjplbgvbhsrlpgdmjqwftvncz\", 4)\n        .inspect()\n        .assert_eq(5);\n\n    solve(\"nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg\", 4)\n        .inspect()\n        .assert_eq(10);\n}\n"},{"title":"AoC 2022 #7","code":"// Advent of Code 2022 - Day 07\n\nconst input: String = \"$ cd /\n$ ls\ndir a\n14848514 b.txt\n8504156 c.dat\ndir d\n$ cd a\n$ ls\ndir e\n29116 f\n2557 g\n62596 h.lst\n$ cd e\n$ ls\n584 i\n$ cd ..\n$ cd ..\n$ cd d\n$ ls\n4060174 j\n8033020 d.log\n5626152 d.ext\n7214296 k\";\n\nfn borgo_main() {\n    let mut sizes = Map::new();\n    let mut stack = [];\n\n    for line in input.split(\"\\n\") {\n        if line.starts_with(\"$ ls\") || line.starts_with(\"dir\") {\n            continue;\n        }\n\n        if line.starts_with(\"$ cd\") {\n            let folder = line.slice(5, 10);\n\n            if folder == \"..\" {\n                stack = stack.pop();\n            } else if stack.is_empty() {\n                stack = stack.push(folder);\n            } else {\n                let path = stack.seq().last().unwrap().append(\"/\").append(folder);\n                stack = stack.push(path);\n            }\n\n            continue;\n        }\n\n        let size = line.split(\" \").get(0).and_then(String::parse_int).unwrap();\n\n        for path in stack.seq() {\n            sizes = sizes.update(path, 0, |n| n + size);\n        }\n    }\n\n    let result = sizes.seq_values().filter(|n| n < 100000).sum();\n    result.inspect().assert_eq(95437);\n}\n"},{"title":"AoC 2022 #10","code":"// Advent of Code 2022 - Day 10\n\nenum Cmd {\n    Noop,\n    AddX(Int),\n}\n\nimpl Cmd {\n    fn parse(s: String) -> Cmd {\n        if s == \"noop\" {\n            return Cmd::Noop;\n        }\n\n        if s.starts_with(\"addx\") {\n            let n = String::parse_int(s.slice(5, 10)).unwrap();\n            return Cmd::AddX(n);\n        };\n\n        unreachable!();\n    }\n}\n\nfn count_cycles(cmds: Seq<Cmd>, targets: Set<Int>) -> Int {\n    let mut cycle = 0;\n    let mut result = [];\n    let mut register = 1;\n\n    fn bump() {\n        cycle = cycle + 1;\n\n        if targets.contains(cycle) {\n            let strength = cycle * register;\n            result = result.push(strength);\n        }\n    }\n\n    for cmd in cmds {\n        match cmd {\n            Cmd::Noop => bump(),\n            Cmd::AddX(n) => {\n                bump();\n                bump();\n                register = register + n;\n            }\n        }\n    }\n\n    result.seq().sum()\n}\n\nfn borgo_main() {\n    let cmds = input.split(\"\\n\").map(Cmd::parse);\n    let targets = [20, 60, 100, 140, 180, 220];\n\n    let res = count_cycles(cmds, targets.seq().to_set());\n    res.inspect().assert_eq(13140);\n}\n\nconst input: String = \"addx 15\naddx -11\naddx 6\naddx -3\naddx 5\naddx -1\naddx -8\naddx 13\naddx 4\nnoop\naddx -1\naddx 5\naddx -1\naddx 5\naddx -1\naddx 5\naddx -1\naddx 5\naddx -1\naddx -35\naddx 1\naddx 24\naddx -19\naddx 1\naddx 16\naddx -11\nnoop\nnoop\naddx 21\naddx -15\nnoop\nnoop\naddx -3\naddx 9\naddx 1\naddx -3\naddx 8\naddx 1\naddx 5\nnoop\nnoop\nnoop\nnoop\nnoop\naddx -36\nnoop\naddx 1\naddx 7\nnoop\nnoop\nnoop\naddx 2\naddx 6\nnoop\nnoop\nnoop\nnoop\nnoop\naddx 1\nnoop\nnoop\naddx 7\naddx 1\nnoop\naddx -13\naddx 13\naddx 7\nnoop\naddx 1\naddx -33\nnoop\nnoop\nnoop\naddx 2\nnoop\nnoop\nnoop\naddx 8\nnoop\naddx -1\naddx 2\naddx 1\nnoop\naddx 17\naddx -9\naddx 1\naddx 1\naddx -3\naddx 11\nnoop\nnoop\naddx 1\nnoop\naddx 1\nnoop\nnoop\naddx -13\naddx -19\naddx 1\naddx 3\naddx 26\naddx -30\naddx 12\naddx -1\naddx 3\naddx 1\nnoop\nnoop\nnoop\naddx -9\naddx 18\naddx 1\naddx 2\nnoop\nnoop\naddx 9\nnoop\nnoop\nnoop\naddx -1\naddx 2\naddx -37\naddx 1\naddx 3\nnoop\naddx 15\naddx -21\naddx 22\naddx -6\naddx 1\nnoop\naddx 2\naddx 1\nnoop\naddx -10\nnoop\nnoop\naddx 20\naddx 1\naddx 2\naddx 2\naddx -6\naddx -11\nnoop\nnoop\nnoop\";\n"}]