enum Result<T, E> {
    Ok(T),
    Err(E),
}

extern "native/Result" {
    fn unwrap<T, E>(self: Result<T, E>) -> T;
}

enum Option<T> {
    Some(T),
    None,
}

extern "native/Option" {
    fn unwrap<T>(self: Option<T>) -> T;
}

impl<T> Option<T> {
    fn is_some(self) -> Bool {
        match self {
            Some(_) => true,
            None => false,
        }
    }

    fn is_none(self) -> Bool {
        !self.is_some()
    }

    fn map<Y>(self, f: fn(x: T) -> Y) -> Option<Y> {
        match self {
            None => None,
            Some(x) => Some(f(x)),
        }
    }

    fn and_then<Y>(self, f: fn(x: T) -> Option<Y>) -> Option<Y> {
        match self {
            None => None,
            Some(x) => f(x),
        }
    }

    fn unwrap_or(self, def: T) -> T {
        match self {
            Some(x) => x,
            None => def,
        }
    }

    fn unwrap_or_else(self, f: fn() -> T) -> T {
        match self {
            Some(x) => x,
            None => f(),
        }
    }

    fn ok_or<E>(self, e: E) -> Result<T, E> {
        match self {
            Some(x) => Ok(x),
            None => Err(e),
        }
    }
}

struct Tuple2<T, Y> {
    first: T,
    second: Y,
}

struct Tuple3<T, Y, Z> {
    first: T,
    second: Y,
    third: Z,
}

extern "native/List" {
    fn len<T>(xs: List<T>) -> Int;
    fn push<T>(xs: List<T>, x: T) -> List<T>;
    fn pop<T>(xs: List<T>) -> List<T>;
    fn get<T>(xs: List<T>, index: Int) -> Option<T>;
    fn seq<T>(xs: List<T>) -> Seq<T>;
}

impl<T> List<T> {
    fn is_empty(self) -> Bool {
        self.len() == 0
    }

    fn to_string<T: to_string>(self) -> String {
        let body = self
            .seq()
            .reduce([], |acc, item| acc.push(item.to_string()));

        "[".append(body.seq().join(", ")).append("]")
    }
}

extern "native/String" {
    fn len(s: String) -> Int;
    fn append(s: String, other: String) -> String;
    fn split(s: String, sep: String) -> Seq<String>;
    fn slice(s: String, start: Int, end: Int) -> String;
    fn chars(s: String) -> Seq<Char>;
    fn contains(s: String, needle: String) -> Bool;
    fn starts_with(s: String, needle: String) -> Bool;
    fn ends_with(s: String, needle: String) -> Bool;
    fn index_of(s: String, needle: String) -> Option<Int>;
    fn parse_int(s: String) -> Option<Int>;
    fn parse_float(s: String) -> Option<Float>;
}

impl String {
    fn is_empty(self) -> Bool {
        self.len() == 0
    }
}

extern "native/Debug" {
    fn inspect<T: to_string>(x: T) -> T;
    fn unreachable();
    fn todo();
    fn assert_eq<T>(a: T, b: T);
}

enum Seq<T> {
    Nil,
    Cons(T, fn() -> Seq<T>),
}

impl<T> Seq<T> {
    fn map<Y>(self, f: fn(x: T) -> Y) -> Seq<Y> {
        match self {
            Seq::Nil => Seq::Nil,
            Seq::Cons(x, cont) => Seq::Cons(f(x), || Seq::map(cont(), f)),
        }
    }

    fn filter_map<Y>(self, f: fn(x: T) -> Option<Y>) -> Seq<Y> {
        self.reduce(Seq::Nil, |acc, item| match f(item) {
            Some(x) => acc.append(Seq::once(x)),
            None => acc,
        })
    }

    fn filter(self, f: fn(x: T) -> Bool) -> Seq<T> {
        self.filter_map(|x| if f(x) { Some(x) } else { None })
    }

    fn reduce<Y>(self, mut acc: Y, f: fn(acc: Y, item: T) -> Y) -> Y {
        for x in self {
            acc = f(acc, x)
        }

        return acc;
    }

    fn to_list(self) -> List<T> {
        self.reduce([], |acc, item| acc.push(item))
    }

    fn len(self) -> Int {
        self.reduce(0, |acc, _| acc + 1)
    }

    fn first(self) -> Option<T> {
        match self {
            Seq::Nil => None,
            Seq::Cons(x, _) => Some(x),
        }
    }

    fn last(self) -> Option<T> {
        self.reduce(None, |_, item| Some(item))
    }

    fn get(self, n: Int) -> Option<T> {
        self.drop(n).first()
    }

    fn cycle(self) -> Seq<T> {
        match self {
            Seq::Nil => Seq::Nil,
            Seq::Cons(first, cont) => Seq::Cons(first, || Seq::append(cont(), Seq::cycle(self))),
        }
    }

    fn append(self, other: Seq<T>) -> Seq<T> {
        match self {
            Seq::Nil => other,
            Seq::Cons(first, cont) => Seq::Cons(first, || Seq::append(cont(), other)),
        }
    }

    fn infinite(start: T, f: fn(prev: T) -> T) -> Seq<T> {
        Seq::Cons(start, || Seq::infinite(f(start), f))
    }

    fn zip<Y>(self, other: Seq<Y>) -> Seq<(T, Y)> {
        match (self, other) {
            (Seq::Nil, _) => Seq::Nil,
            (_, Seq::Nil) => Seq::Nil,

            (Seq::Cons(x, cont_x), Seq::Cons(y, cont_y)) => {
                Seq::Cons((x, y), || Seq::zip(cont_x(), cont_y()))
            }
        }
    }

    fn enumerate(self) -> Seq<(Int, T)> {
        Seq::infinite(0, |n| n + 1).zip(self)
    }

    fn reverse(self) -> Seq<T> {
        self.reduce(Seq::Nil, |acc, item| Seq::Cons(item, || acc))
    }

    fn chunks(self, n: Int) -> Seq<Seq<T>> {
        let parts = self.split_at(n);

        match parts.0 {
            Seq::Nil => Seq::Nil,
            Seq::Cons(_, _) => Seq::Cons(parts.0, || Seq::chunks(parts.1, n)),
        }
    }

    // same as chunks, but elements overlap
    fn windows(self, n: Int) -> Seq<Seq<T>> {
        let current = self.take(n);

        // if shorter than desired size, drop the last elements
        if current.len() < n {
            return Seq::Nil;
        }

        Seq::Cons(current, || Seq::windows(self.drop(1), n))
    }

    fn split_at(self, mut n: Int) -> (Seq<T>, Seq<T>) {
        let mut first = [];
        let mut remaining = self;

        loop {
            if n <= 0 {
                break;
            }

            match remaining {
                Seq::Nil => break,
                Seq::Cons(x, cont) => {
                    n = n - 1;
                    first = first.push(x);
                    remaining = cont();
                }
            }
        }

        (first.seq(), remaining)
    }

    fn take(self, n: Int) -> Seq<T> {
        self.split_at(n).0;
    }

    fn drop(self, n: Int) -> Seq<T> {
        self.split_at(n).1
    }

    fn find_map<Y>(self, f: fn(x: T) -> Option<Y>) -> Option<Y> {
        let mut ret = None;

        for x in self {
            ret = f(x);
            if ret.is_some() {
                break;
            }
        }

        return ret;
    }

    fn once(x: T) -> Seq<T> {
        Seq::Cons(x, || Seq::Nil)
    }

    fn chain(self, other: Seq<T>) -> Seq<T> {
        match self {
            Seq::Nil => other,
            Seq::Cons(x, cont) => Seq::Cons(x, || cont().chain(other)),
        }
    }

    fn for_each(self, f: fn(x: T) -> ()) {
        self.reduce((), |_, item| f(item))
    }

    fn max_by(self, f: fn(x: T, y: T) -> Ordering) -> Option<T> {
        self.reduce(None, |acc, item| {
            if acc.is_none() {
                return Some(item);
            }

            if f(item, acc.unwrap()) == Ordering::Greater {
                return Some(item);
            }

            return acc;
        })
    }

    fn interleave(self, sep: T) -> Seq<T> {
        self.reduce([], |acc, x| acc.push(sep).push(x))
            .seq()
            .drop(1)
    }

    fn to_string<T: to_string>(self) -> String {
        // Realize the first N elements
        self.take(30).to_list().to_string()
    }
}

struct Map<K, V> {}

extern "native/Map" {
    fn new<K, V>() -> Map<K, V>;
    fn insert<K: to_hash, V>(m: Map<K, V>, key: K, value: V) -> Map<K, V>;
    fn get<K, V>(m: Map<K, V>, key: K) -> Option<V>;
    fn seq<K, V>(m: Map<K, V>) -> Seq<(K, V)>;
    fn delete<K, V>(m: Map<K, V>, key: K) -> Map<K, V>;
    fn len<K, V>(m: Map<K, V>) -> Int;
}

impl<K, V> Map<K, V> {
    fn seq_keys(self) -> Seq<K> {
        self.seq().map(|(k, _)| k)
    }

    fn seq_values(self) -> Seq<V> {
        self.seq().map(|(_, v)| v)
    }

    fn update<K: to_hash>(self, key: K, def: V, f: fn(existing: V) -> V) -> Map<K, V> {
        let existing = self.get(key).unwrap_or(def);
        let updated = f(existing);
        self.insert(key, updated)
    }

    fn to_string<K: to_string, V: to_string>(self) -> String {
        let body = self.seq().reduce([], |acc, item| {
            let key = item.0.to_string();
            let val = item.1.to_string();
            acc.push(key.append(" => ").append(val))
        });

        "{ ".append(body.seq().join(", ")).append(" }")
    }
}

fn to_map<K: to_hash, V>(s: Seq<(K, V)>) -> Map<K, V> {
    s.reduce(Map::new(), |acc, item| acc.insert(item.0, item.1))
}

struct Set<K> {
    m: Map<K, Bool>,
}

impl<K> Set<K> {
    fn new() -> Set<K> {
        Set { m: Map::new() }
    }

    fn insert<K: to_hash>(self, k: K) -> Set<K> {
        Set {
            m: self.m.insert(k, true),
        }
    }

    fn delete<K>(self, k: K) -> Set<K> {
        Set {
            m: self.m.delete(k),
        }
    }

    fn contains<K>(self, k: K) -> Bool {
        self.m.get(k).is_some()
    }

    fn len(self) -> Int {
        self.m.len()
    }

    fn to_string<K: to_string>(self) -> String {
        self.m.seq_keys().to_list().to_string()
    }
}

fn to_set<K: to_hash>(s: Seq<K>) -> Set<K> {
    s.reduce(Set::new(), |acc, item| acc.insert(item))
}

struct Ref<T> {}

extern "effect/Ref" {
    fn ref_new<T>(value: T) -> Ref<T>;
    fn ref_set<T>(r: Ref<T>, value: T);
    fn ref_get<T>(r: Ref<T>) -> T;
}

impl<T> Ref<T> {
    fn to_ref<T>(value: T) -> Ref<T> {
        ref_new(value);
    }

    fn get(r: Ref<T>) -> T {
        ref_get(r)
    }

    fn mutate(r: Ref<T>, f: fn(value: T) -> T) {
        let current = ref_get(r);
        ref_set(r, f(current));
    }

    fn to_string<T: to_string>(self) -> String {
        "<ref> ".append(self.get().to_string())
    }
}

struct Channel<T> {}
struct Receiver<T> {}
struct Sender<T> {}

extern "effect/Channel" {
    fn channel_new<T>() -> Channel<T>;
    fn channel_recv<T>(self: Receiver<T>) -> Option<T>;
    fn channel_send<T>(self: Sender<T>, value: T);
}

impl<T> Channel<T> {
    fn new() -> (Sender<T>, Receiver<T>) {
        let ch = channel_new();
        (Internal::unsafe_coerce(ch), Internal::unsafe_coerce(ch))
    }
}

impl<T> Receiver<T> {
    fn recv(self) -> Option<T> {
        channel_recv(self)
    }
}

impl<T> Sender<T> {
    // TODO this needs a return type?
    fn send(self, value: T) {
        channel_send(self, value)
    }
}

enum ChannelOp<T> {
    Recv(Receiver<T>, Option<T>),
    Send(Sender<T>, T),
}

struct Internal {}

extern "native/Internal" {
    fn unsafe_coerce<T, Y>(x: T) -> Y;
}

impl Int {
    fn abs(n: Int) -> Int {
        if n < 0 {
            return -n;
        }

        n
    }

    fn cmp(a: Int, b: Int) -> Ordering {
        if a == b {
            Ordering::Equal
        } else if a > b {
            Ordering::Greater
        } else {
            Ordering::Less
        }
    }
}

enum Ordering {
    Less,
    Equal,
    Greater,
}

extern "native/Char" {
    fn to_int(self: Char) -> Int;
    fn to_unquoted_string(self: Char) -> String;
}

impl Seq<Int> {
    fn sum(self) -> Int {
        self.reduce(0, |a, b| a + b)
    }
}

impl Seq<String> {
    fn join(self, sep: String) -> String {
        self.interleave(sep)
            .reduce("", |acc, item| acc.append(item))
    }
}

extern "overload" {
    fn equals<T>(x: T, y: T) -> Bool;
    fn to_hash<T>(x: T) -> Int;
    fn to_string<T>(x: T) -> String;
}

impl Unit {
    fn to_string(self) -> String {
        "()"
    }
}

impl<T, Y> Tuple2<T, Y> {
    fn to_string<T: to_string, Y: to_string>(self) -> String {
        "(".append(self.first.to_string())
            .append(", ")
            .append(self.second.to_string())
            .append(")")
    }
}

impl<T, Y, Z> Tuple3<T, Y, Z> {
    fn to_string<T: to_string, Y: to_string, Z: to_string>(self) -> String {
        "(".append(self.first.to_string())
            .append(", ")
            .append(self.second.to_string())
            .append(", ")
            .append(self.third.to_string())
            .append(")")
    }
}
