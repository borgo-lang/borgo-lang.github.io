<!DOCTYPE html>
<html>
<head>
  <title>Borgo Programming Language</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <header>
    <h1>Borgo Programming Language</h1>
  </header>

  <main>
    <div class="links-pane">
      <section id="examples">
                  <a
            href="#intro"
            onClick="Borgo.selectExample('intro')">
              Intro          </a>
                  <a
            href="#primitive-types"
            onClick="Borgo.selectExample('primitive-types')">
              Primitive Types          </a>
                  <a
            href="#control-flow"
            onClick="Borgo.selectExample('control-flow')">
              Control flow          </a>
                  <a
            href="#union-types-and-pattern-matching"
            onClick="Borgo.selectExample('union-types-and-pattern-matching')">
              Union types and pattern matching          </a>
                  <a
            href="#structs"
            onClick="Borgo.selectExample('structs')">
              Structs          </a>
                  <a
            href="#result-and-option"
            onClick="Borgo.selectExample('result-and-option')">
              Result and Option          </a>
                  <a
            href="#interoperability-with-go"
            onClick="Borgo.selectExample('interoperability-with-go')">
              Interoperability with Go          </a>
                  <a
            href="#package-definitions"
            onClick="Borgo.selectExample('package-definitions')">
              Package definitions          </a>
                  <a
            href="#pointers-and-references"
            onClick="Borgo.selectExample('pointers-and-references')">
              Pointers and References          </a>
                  <a
            href="#methods"
            onClick="Borgo.selectExample('methods')">
              Methods          </a>
                  <a
            href="#interfaces-traits"
            onClick="Borgo.selectExample('interfaces-traits')">
              Interfaces (traits)          </a>
                  <a
            href="#error-handling"
            onClick="Borgo.selectExample('error-handling')">
              Error handling          </a>
              </section>
    </div>

    <section id="content" class="content-pane">
                  <article data-slug="intro">
            <h2>
              Intro            </h2>

            <div>
              <p><strong>Borgo</strong> is a programming language that targets Go.</p>

<p>Imagine Go had:</p>

<ul>
<li>Rust syntax</li>
<li>Union types</li>
<li><code>Option&lt;T&gt;</code> instead of <code>nil</code></li>
<li><code>Result&lt;T&gt;</code> instead of <code>T, error</code></li>
<li>Error handling with <code>?</code> operator</li>
</ul>

<p>Borgo is still early in development, but should be usable!</p>
            </div>

            <pre data-example>use fmt;

fn main() {
    fmt.Println("hi")
}
</pre>
          </article>
                  <article data-slug="primitive-types">
            <h2>
              Primitive Types            </h2>

            <div>
              <p>Primitive types are the same as in Go.</p>

<p>Collections like slices and maps can be used without specifying the type of the
values.</p>

<p>For example, a slice of int elements would be declared as <code>[]int{1,2,3}</code> in Go,
whereas Borgo doesn&#39;t need type information, so you can just write <code>[1, 2, 3]</code>.</p>

<p>Functions like <code>append()</code> and <code>len()</code> are available as methods.</p>

<p>Maps are initialized with the <code>Map::new()</code> function, which under the hood
compiles to a <code>map[K]V{}</code> expression, with the <code>K</code> and <code>V</code> types helpfully
filled in for you.</p>

<p>Borgo also has tuples! They work exactly like in Rust.</p>
            </div>

            <pre data-example>use fmt;

fn main() {
    let n = 1;
    let s = "hello";
    let b = false;

    fmt.Println("primitives: ", n, s, b);

    let mut xs = [1, 2, 3];
    fmt.Println("slice:", xs);

    xs = xs.append(10);
    fmt.Println("len after append:", xs.len());

    let mut m = Map::new();
    m.insert(1, "alice");
    m.insert(2, "bob");

    fmt.Println("map:", m);

    let pair = ("hey", true);
    fmt.Println("second element in tuple:", pair.1);
}
</pre>
          </article>
                  <article data-slug="control-flow">
            <h2>
              Control flow            </h2>

            <div>
              <p>Like in Go, the only values that can be iterated over are slices, maps, channels
and strings.</p>

<p>However, loops always iterate over a single value, which is the element in the
slice (contrary to Go, where using a single iteration variable gives you the
index of the element).</p>

<p>To iterate over <code>(index, element)</code> pairs call the <code>.enumerate()</code> method on
slices. This has no runtime cost, it just aids the compiler in generating the
correct code.</p>

<p>When iterating over maps, you should always destructure values with
<code>(key, value)</code> pairs instead of a single value.</p>

<p>Like in Rust, infinite loops use the <code>loop {}</code> construct whereas loops with
conditions use <code>while {}</code>.</p>

<p>Expressions like <code>if</code>, <code>match</code> and blocks return a value, so you can assign
their result to a variable.</p>
            </div>

            <pre data-example>use fmt;
use math::rand;

fn main() {
    let xs = ["a", "b", "c"];

    fmt.Println("For loop over slices");
    for letter in xs {
        fmt.Println(letter);
    }

    fmt.Println("Indexed for loop");
    for (index, letter) in xs.enumerate() {
        fmt.Println(index, letter);
    }

    let m = Map::new();
    m.insert(1, "alice");
    m.insert(2, "bob");

    fmt.Println("For loop over maps");
    for (key, value) in m {
        fmt.Println(key, value);
    }

    fmt.Println("Loop with no condition");
    loop {
        let n = rand.Float64();
        fmt.Println("looping...", n);

        if n > 0.75 {
            break;
        }
    }

    fmt.Println("While loop");

    let mut count = 0;
    while (count < 5) {
        fmt.Println(count);
        count = count + 1;
    }

    fmt.Println("using if statements as expressions");
    fmt.Println(if 5 > 3 { "ok" } else { "nope" });

    let block_result = {
        let a = 1;
        let b = 2;
        a + b
    };

    fmt.Println("block result:", block_result);
}
</pre>
          </article>
                  <article data-slug="union-types-and-pattern-matching">
            <h2>
              Union types and pattern matching            </h2>

            <div>
              <p>Union types work pretty much like in Rust.</p>

<p>Pattern matches must be exhaustive, meaning the compiler will return an error
when a case is missing (try removing any case statement from the example and see
what happens!).</p>

<p>Check the
<a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">Rust book chapter on enums</a>
if you want to learn more.</p>

<blockquote class="hint"><p>For now, variants can only be defined as tuples and not as structs.</p>
</blockquote>            </div>

            <pre data-example>use fmt;
use strings;

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> int {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

enum IpAddr {
    V4(uint8, uint8, uint8, uint8),
    V6(string),
}

fn is_private(ip: IpAddr) -> bool {
    match ip {
        IpAddr::V4(a, b, _, _) => {
            if a == 10 {
                return true;
            }

            if a == 172 && b >= 16 && b <= 31 {
                return true;
            }

            if a == 192 && b == 168 {
                return true;
            }

            false
        }

        IpAddr::V6(s) => strings.HasPrefix(s, "fc00::"),
    }
}

fn main() {
    let cents = value_in_cents(Coin::Nickel);
    fmt.Println("cents:", cents);

    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6("::1");
    fmt.Println("home ip is private: ", home, is_private(home));
    fmt.Println("loopback: ", loopback);
}
</pre>
          </article>
                  <article data-slug="structs">
            <h2>
              Structs            </h2>

            <div>
              <p>Defining and instantiating structs is similar to Rust.</p>

<p>Fields in structs can be modified only if the variable is declared as mutable
(<code>let mut</code> keyword).</p>
            </div>

            <pre data-example>use fmt;

struct Person {
    name: string,
    hobbies: [Hobby],
}

enum Hobby {
    SkyDiving,
    StaringAtWall,
    Other(string),
}

fn main() {
    let mut p = Person {
        name: "bob",
        hobbies: [Hobby::StaringAtWall, Hobby::Other("sleep")],
    };

    fmt.Println("person:", p);

    p.hobbies = p.hobbies.append(Hobby::SkyDiving);
    fmt.Println("with more hobbies:", p);
}
</pre>
          </article>
                  <article data-slug="result-and-option">
            <h2>
              Result and Option            </h2>

            <div>
              <p>Sometimes it&#39;s helpful to deal with values that may or may not be there. This is
the idea behind the <code>Option&lt;T&gt;</code> type.</p>

<p>For example, to get an element out of a slice or a map, you can use the
<code>.get(index)</code> method that will force you to handle the case where the element
isn&#39;t there.</p>

<p>Other times you may want to return a value <em>or</em> an error. In those cases use
<code>Result&lt;T, E&gt;</code> to let the caller know that a function may return an error.</p>

<p>When you&#39;re sure that a value is <em>definitely</em> there, you can call <code>.unwrap()</code>.
Like in Rust, this is an unsafe operation and will panic.</p>

<p>A lot of methods are missing from both <code>Result</code> and <code>Option</code>, contributions to
the stdlib are welcome!</p>
            </div>

            <pre data-example>use fmt;

struct Person {
    name: string,
    age: int,
}

fn validate(name: string, age: int) -> Result<Person, string> {
    if (age < 18) {
        return Err("too young");
    }

    if (age > 98) {
        return Err("too old");
    }

    Ok(Person { name, age })
}

fn main() {
    let xs = ["a", "b", "c"];
    let element = xs.get(2); // Option<string>

    match element {
        Some(s) => fmt.Println("ok, the element was found:", s),
        None => fmt.Println("element not found"),
    }

    let result = validate("alice", 33); // Result<Person, string>

    match result {
        Ok(p) => fmt.Println("got a person:", p),
        Err(e) => fmt.Println("couldn't validate:", e),
    }
}
</pre>
          </article>
                  <article data-slug="interoperability-with-go">
            <h2>
              Interoperability with Go            </h2>

            <div>
              <p>One ambitious goal of this project is to be fully compatible with the existing
Go ecosystem.</p>

<p>You&#39;ve already seen how the <code>fmt</code> package was used in previous examples, but how
do we deal with functions that return multiple values?</p>

<p>This is where our trusty <code>Option</code> and <code>Result</code> types come in! The compiler will
handle the conversion <em>automatically</em> for you :)</p>

<p>A good mental model is to think of return types in Go functions as:</p>

<pre><code>when return type is    (T, bool)
it becomes             Option&lt;T&gt;

when return type is    (T, error)
it becomes             Result&lt;T, E&gt;
</code></pre>

<p>Let&#39;s take the <a href="https://pkg.go.dev/os#LookupEnv">os.LookupEnv</a> function as an
example:</p>

<pre><code>Go definition:
  func LookupEnv(key string) (string, bool)

becomes:
  fn LookupEnv(key: string) -&gt; Option&lt;string&gt;
</code></pre>

<p>Or the <a href="https://pkg.go.dev/os#Stat">os.Stat</a> function from the same package:</p>

<pre><code>Go definition:
  func Stat(name string) (FileInfo, error)

becomes:
  fn Stat(name: string) -&gt; Result&lt;FileInfo&gt;
</code></pre>

<blockquote class="hint"><p><code>Result&lt;T&gt;</code> is short-hand for <code>Result&lt;T, error&gt;</code> where <code>error</code> is the standard
Go interface.</p>
</blockquote>
<p>With this simple convention, pretty much any Go package can be used in Borgo
code! All is needed is a package declaration, which is discussed in the next
section.</p>
            </div>

            <pre data-example>use fmt;
use io::fs; // TODO there should be no need of importing this
use os;

fn main() {
    let key = os.LookupEnv("HOME");

    match key {
        // Option<T>
        Some(s) => fmt.Println("home dir:", s),
        None => fmt.Println("Not found in env"),
    }

    let info = os.Stat("file-does-not-exist");

    match info {
        // Result<T, E>
        Ok(_) => fmt.Println("The file exists"),
        Err(err) => fmt.Println("Got error reading file", err),
    }
}
</pre>
          </article>
                  <article data-slug="package-definitions">
            <h2>
              Package definitions            </h2>

            <div>
              <p>In order to use existing Go packages, Borgo needs to know what types and
functions they contain.</p>

<p>You can see these bindings in the
<a href="https://github.com/borgo-lang/borgo/tree/main/std">std/</a> folder.</p>

<p>The example on the right uses the <code>regexp</code> package from the Go standard library.
That&#39;s only possible because of the bindings at <code>std/regexp/regexp.rgb</code>, which
look like this:</p>

<pre><code>struct Regexp { }

fn Compile  (expr: string) -&gt; Result&lt;&amp;Regexp&gt; { EXT }

fn CompilePOSIX  (expr: string) -&gt; Result&lt;&amp;Regexp&gt; { EXT }

fn MustCompile  (str: string) -&gt; &amp;Regexp { EXT }

fn MustCompilePOSIX  (str: string) -&gt; &amp;Regexp { EXT }

fn Match  (pattern: string, b: [byte]) -&gt; Result&lt;bool&gt; { EXT }

// ... other stuff
</code></pre>

<p>Right now the stdlib comes with very few bindings to the actual Go stdlib, just
a few functions here and there for testing purposes.</p>

<p>Writing such declarations by hand is a pain! There&#39;s no reason why this process
couldn&#39;t be automated though. The compiler comes with an <code>importer</code> tool that
parses a Go package and generates corresponding bindings to be used in Borgo.</p>

<p>So if bindings to the <code>regexp</code> package didn&#39;t exist, you could generate them by
running the following:</p>

<pre><code>just run-importer -folder /usr/local/go/src/regexp &gt; std/regexp/regexp.brg
</code></pre>
            </div>

            <pre data-example>use fmt;
use regexp;

fn main() {
    let validID = regexp.MustCompile(r"^[a-z]+\[[0-9]+\]$");

    fmt.Println(validID.MatchString("adam[23]"));
    fmt.Println(validID.MatchString("eve[7]"));
}
</pre>
          </article>
                  <article data-slug="pointers-and-references">
            <h2>
              Pointers and References            </h2>

            <div>
              <p><strong>NOTE</strong> Right now this is more wishful thinking than anything :D I plan to
implement an extra pass in the compiler pipeline that can check if references
are handed out correctly, but <strong>right now you can pass around references of any
type and not get an error</strong>.</p>

<p>Borgo dosn&#39;t have a borrow checker: all memory is managed by the Go runtime.
That&#39;s one of the main benefits of compiling to Go after all!</p>

<p>Despite that, when handing out a <em>reference</em> of a value to a function, it is
still useful to be explicit about whether the reference is <em>mutable</em> or
<em>immutable</em>.</p>

<p>Borgo distinguishes between:</p>

<ul>
<li><code>&amp;mut T</code> references, which allow modification of the underlying value</li>
<li><code>&amp;T</code> references, which are read-only and ensure no changes will occur</li>
</ul>

<p>So for example, a function that computes the sum of a slice of ints, has no need
to mutate it. It makes sense to accept a read-only reference.</p>

<pre><code>fn sum(xs: &amp;[int]) -&gt; int {
  // ...
}
</code></pre>

<p>Whereas if we wanted to add elements to it, then we&#39;d need a mutable reference.</p>

<pre><code>fn add_number(xs: &amp;mut [int], n: int) {
  // ...
}
</code></pre>

<p>When generating Go code, this makes no difference, it&#39;s all pointers under the
hood!</p>

<blockquote class="hint"><p>Because there&#39;s no borrow checker involved, it makes less sense to talk about
<em>exclusive</em> and <em>shared</em> references. It&#39;s perfectly valid to have multiple
mutable references live at the same point, something that would not be permitted
by Rust&#39;s ownership rules.</p>
</blockquote>            </div>

            <pre data-example>// example missing,

fn main() {}
</pre>
          </article>
                  <article data-slug="methods">
            <h2>
              Methods            </h2>

            <div>
              <p>To define methods on types, you can use <code>impl {}</code> blocks.</p>

<p>Methods need a <code>self</code> receiver, like in Rust. If the receiver is <code>&amp;mut self</code> or
<code>&amp;self</code> then the generated method will be a pointer receiver <code>(self *T)</code>.</p>

<p>It&#39;s also possible to declare static methods: they will compile to normal
functions namespaced with the type name (ie. <code>Person_new()</code>).</p>
            </div>

            <pre data-example>use fmt;

struct Person {
    name: string,
    hours_slept: int,
}

impl Person {
    fn new(name: string) -> Person {
        Person {
            name,
            hours_slept: 0,
        }
    }

    // Needs mutable reference because modifies structure
    fn sleep(&mut self) {
        self.hours_slept = self.hours_slept + 1;
    }

    // Ok with read-only reference
    fn ready_for_work(&self) -> bool {
        self.hours_slept > 5
    }

    fn ready_to_party(&self) -> bool {
        self.hours_slept > 10
    }
}

fn main() {
    let mut p = Person::new("alice");

    p.sleep();
    p.sleep();

    fmt.Println("is ready:", p.ready_for_work());
}
</pre>
          </article>
                  <article data-slug="interfaces-traits">
            <h2>
              Interfaces (traits)            </h2>

            <div>
              <p>Interfaces in Borgo work the same as in Go, it&#39;s all duck typing.</p>

<p>If a type implements the methods declared by the interface, then the type is an
instance of that interface.</p>

<p>Embedded interfaces are also supported, just list out the other interfaces
<em>implied</em> by the one being defined. For example, the <code>ReadWriter</code> interface from
the <code>io</code> package can be defined as:</p>

<pre><code>trait ReadWriter: Reader + Writer {}
</code></pre>

<p>One possibly confusing detail is that Borgo uses the <code>trait</code> keyword to define
interfaces ^_^&#39;.</p>

<p>This is because the underlying parser is looking for Rust syntax. In the future
we&#39;ll have our own parser (or more realistically just a fork) and this will no
longer be a problem!</p>

<blockquote class="hint"><p>Borgo doesn&#39;t support <a href="https://go.dev/ref/spec#General_interfaces">type sets</a>,
you can only define methods in interfaces. Constraints still work, but they will
only be checked by the Go compiler.</p>
</blockquote>            </div>

            <pre data-example>use fmt;
use math;

trait geometry {
    fn area() -> float64;
    fn perim() -> float64;
}

struct rect {
    width: float64,
    height: float64,
}

impl rect {
    fn area(self) -> float64 {
        self.width * self.height
    }

    fn perim(self) -> float64 {
        2 * self.width + 2 * self.height
    }
}

struct circle {
    radius: float64,
}

impl circle {
    fn area(self) -> float64 {
        math.Pi * self.radius * self.radius
    }

    fn perim(self) -> float64 {
        2 * math.Pi * self.radius
    }
}

fn measure(g: geometry) {
    fmt.Println(g);
    fmt.Println(g.area());
    fmt.Println(g.perim());
}

fn main() {
    let r = rect {
        width: 3,
        height: 4,
    };
    let c = circle { radius: 5 };

    measure(r);
    measure(c);
}
</pre>
          </article>
                  <article data-slug="error-handling">
            <h2>
              Error handling            </h2>

            <div>
              <p>In functions that return a <code>Result</code>, it&#39;s possible to propagate errors with the
<code>?</code> operator.</p>

<p>This is similar to what happens in Rust, refer to the section on
<a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors">Propagating errors</a>
in the Rust book .</p>

<p>Currently the <code>?</code> operator only works with <code>Result</code>, but it will be extended to
also work with <code>Option</code>.</p>
            </div>

            <pre data-example>use fmt;
use io;
use os;

fn copy_file(src: string, dst: string) -> Result<(), error> {
    let stat = os.Stat(src)?;

    if !stat.Mode().IsRegular() {
        return Err(fmt.Errorf("%s is not a regular file", src));
    }

    let source = os.Open(src)?;
    defer!(source.Close());

    let destination = os.Create(dst)?;
    defer!(destination.Close());

    // ignore number of bytes copied
    let _ = io.Copy(destination, source)?;

    Ok(())
}

fn main() {
    match copy_file("go.mod", "asdf") {
        Ok(_) => fmt.Println("file copied"),
        Err(e) => fmt.Println("error copying:", e),
    }
}
</pre>
          </article>
            </section>

    <section class="editor-pane">
      <div class="actions">
        <button onclick="Borgo.compile()" title="Shift + Enter">Run</button>
      </div>

      <div id="editor">
        <div>
          Loading compiler &amp; stdlib...
        </div>

        <textarea style="display: none;">/// Start editing
    use fmt;
    fn main() {
      fmt.Println("Hello world");
    }</textarea>
      </div>

      <pre id="output"></pre>

      <pre id="errors"></pre>
    </section>
  </main>

  <footer>
    <p><a href="https://github.com/borgo-lang/borgo">Borgo on Github</a>
    </p>
  </footer>
  <script src="/bundle.js"></script> 
  <script type="module">
    // Rust compiler
    import { default as initRust, compile_wasm } from "/pkg/wasm.js";

    initRust().then(() => window.Borgo.compiler_ready())

    window.Borgo.compile_wasm = compile_wasm

    window.Borgo.main()
  </script>
</body>
</html>
