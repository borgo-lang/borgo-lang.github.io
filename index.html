<!DOCTYPE html>
<html>
<head>
  <title>Borgo Programming Language</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <header>
    <h1>Borgo Programming Language</h1>
  </header>

  <main>
    <div class="links-pane">
      <section id="examples">
      </section>
    </div>

    <section class="content-pane">
      <h2 id="section-title">
      </h2>

      <div id="section-description">
      </div>
    </section>

    <section class="editor-pane">
      <div class="actions">
        <button onclick="Borgo.compile()" title="Shift + Enter">Run</button>
      </div>

      <div id="editor">
        <div>
          Loading compiler & stdlib...
        </div>

        <textarea style="display: none;">/// Start editing
    use fmt;
    fn main() {
      fmt.Println("Hello world");
    }</textarea>
      </div>

      <pre id="output"></pre>

      <pre id="errors"></pre>
    </section>
  </main>

  <footer>
    <p><a href="https://github.com/borgo-lang/borgo">Borgo on Github</a>
    </p>
  </footer>
  <script src="/bundle.js"></script> 
  <script type="module">

    const EXAMPLES = [{"slug":"intro","title":"Intro","description":"<p><strong>Borgo</strong> is a programming language that targets Go.</p>\n\n<p>Imagine Go had:</p>\n\n<ul>\n<li>Rust syntax</li>\n<li>Union types</li>\n<li><code>Option&lt;T&gt;</code> instead of <code>nil</code></li>\n<li><code>Result&lt;T&gt;</code> instead of <code>T, error</code></li>\n<li>Error handling with <code>?</code> operator</li>\n</ul>\n\n<p>Borgo is still early in development, but should be usable!</p>\n","code":"use fmt;\n\nfn main() {\n    fmt.Println(\"hi\")\n}\n"},{"slug":"primitive-types","title":"Primitive Types","description":"<p>Primitive types are the same as in Go.</p>\n\n<p>Collections like slices and maps can be used without specifying the type of the\nvalues.</p>\n\n<p>For example, a slice of int elements would be declared as <code>[]int{1,2,3}</code> in Go,\nwhereas Borgo doesn&#39;t need type information, so you can just write <code>[1, 2, 3]</code>.</p>\n\n<p>Functions like <code>append()</code> and <code>len()</code> are available as methods.</p>\n\n<p>Maps are initialized with the <code>Map::new()</code> function, which under the hood\ncompiles to a <code>map[K]V{}</code> expression, with the <code>K</code> and <code>V</code> types helpfully\nfilled in for you.</p>\n\n<p>Borgo also has tuples! They work exactly like in Rust.</p>\n","code":"use fmt;\n\nfn main() {\n    let n = 1;\n    let s = \"hello\";\n    let b = false;\n\n    fmt.Println(\"primitives: \", n, s, b);\n\n    let mut xs = [1, 2, 3];\n    fmt.Println(\"slice:\", xs);\n\n    xs = xs.append(10);\n    fmt.Println(\"len after append:\", xs.len());\n\n    let mut m = Map::new();\n    m.insert(1, \"alice\");\n    m.insert(2, \"bob\");\n\n    fmt.Println(\"map:\", m);\n\n    let pair = (\"hey\", true);\n    fmt.Println(\"second element in tuple:\", pair.1);\n}\n"},{"slug":"control-flow","title":"Control flow","description":"<p>Like in Go, the only values that can be iterated over are slices, maps, channels\nand strings.</p>\n\n<p>However, loops always iterate over a single value, which is the element in the\nslice (contrary to Go, where using a single iteration variable gives you the\nindex of the element).</p>\n\n<p>To iterate over <code>(index, element)</code> pairs call the <code>.enumerate()</code> method on\nslices. This has no runtime cost, it just aids the compiler in generating the\ncorrect code.</p>\n\n<p>When iterating over maps, you should always destructure values with\n<code>(key, value)</code> pairs instead of a single value.</p>\n\n<p>Like in Rust, infinite loops use the <code>loop {}</code> construct whereas loops with\nconditions use <code>while {}</code>.</p>\n\n<p>Expressions like <code>if</code>, <code>match</code> and blocks return a value, so you can assign\ntheir result to a variable.</p>\n","code":"use fmt;\nuse math::rand;\n\nfn main() {\n    let xs = [\"a\", \"b\", \"c\"];\n\n    fmt.Println(\"For loop over slices\");\n    for letter in xs {\n        fmt.Println(letter);\n    }\n\n    fmt.Println(\"Indexed for loop\");\n    for (index, letter) in xs.enumerate() {\n        fmt.Println(index, letter);\n    }\n\n    let m = Map::new();\n    m.insert(1, \"alice\");\n    m.insert(2, \"bob\");\n\n    fmt.Println(\"For loop over maps\");\n    for (key, value) in m {\n        fmt.Println(key, value);\n    }\n\n    fmt.Println(\"Loop with no condition\");\n    loop {\n        let n = rand.Float64();\n        fmt.Println(\"looping...\", n);\n\n        if n > 0.75 {\n            break;\n        }\n    }\n\n    fmt.Println(\"While loop\");\n\n    let mut count = 0;\n    while (count < 5) {\n        fmt.Println(count);\n        count = count + 1;\n    }\n\n    fmt.Println(\"using if statements as expressions\");\n    fmt.Println(if 5 > 3 { \"ok\" } else { \"nope\" });\n\n    let block_result = {\n        let a = 1;\n        let b = 2;\n        a + b\n    };\n\n    fmt.Println(\"block result:\", block_result);\n}\n"},{"slug":"union-types-and-pattern-matching","title":"Union types and pattern matching","description":"<p>Union types work pretty much like in Rust.</p>\n\n<p>Pattern matches must be exhaustive, meaning the compiler will return an error\nwhen a case is missing (try removing any case statement from the example and see\nwhat happens!).</p>\n\n<p>Check the\n<a href=\"https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html\">Rust book chapter on enums</a>\nif you want to learn more.</p>\n\n<blockquote class=\"hint\"><p>For now, variants can only be defined as tuples and not as structs.</p>\n</blockquote>","code":"use fmt;\nuse strings;\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> int {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n\nenum IpAddr {\n    V4(uint8, uint8, uint8, uint8),\n    V6(string),\n}\n\nfn is_private(ip: IpAddr) -> bool {\n    match ip {\n        IpAddr::V4(a, b, _, _) => {\n            if a == 10 {\n                return true;\n            }\n\n            if a == 172 && b >= 16 && b <= 31 {\n                return true;\n            }\n\n            if a == 192 && b == 168 {\n                return true;\n            }\n\n            false\n        }\n\n        IpAddr::V6(s) => strings.HasPrefix(s, \"fc00::\"),\n    }\n}\n\nfn main() {\n    let cents = value_in_cents(Coin::Nickel);\n    fmt.Println(\"cents:\", cents);\n\n    let home = IpAddr::V4(127, 0, 0, 1);\n    let loopback = IpAddr::V6(\"::1\");\n    fmt.Println(\"home ip is private: \", home, is_private(home));\n    fmt.Println(\"loopback: \", loopback);\n}\n"},{"slug":"structs","title":"Structs","description":"<p>Defining and instantiating structs is similar to Rust.</p>\n\n<p>Fields in structs can be modified only if the variable is declared as mutable\n(<code>let mut</code> keyword).</p>\n","code":"use fmt;\n\nstruct Person {\n    name: string,\n    hobbies: [Hobby],\n}\n\nenum Hobby {\n    SkyDiving,\n    StaringAtWall,\n    Other(string),\n}\n\nfn main() {\n    let mut p = Person {\n        name: \"bob\",\n        hobbies: [Hobby::StaringAtWall, Hobby::Other(\"sleep\")],\n    };\n\n    fmt.Println(\"person:\", p);\n\n    p.hobbies = p.hobbies.append(Hobby::SkyDiving);\n    fmt.Println(\"with more hobbies:\", p);\n}\n"},{"slug":"result-and-option","title":"Result and Option","description":"<p>Sometimes it&#39;s helpful to deal with values that may or may not be there. This is\nthe idea behind the <code>Option&lt;T&gt;</code> type.</p>\n\n<p>For example, to get an element out of a slice or a map, you can use the\n<code>.get(index)</code> method that will force you to handle the case where the element\nisn&#39;t there.</p>\n\n<p>Other times you may want to return a value <em>or</em> an error. In those cases use\n<code>Result&lt;T, E&gt;</code> to let the caller know that a function may return an error.</p>\n\n<p>When you&#39;re sure that a value is <em>definitely</em> there, you can call <code>.unwrap()</code>.\nLike in Rust, this is an unsafe operation and will panic.</p>\n\n<p>A lot of methods are missing from both <code>Result</code> and <code>Option</code>, contributions to\nthe stdlib are welcome!</p>\n","code":"use fmt;\n\nstruct Person {\n    name: string,\n    age: int,\n}\n\nfn validate(name: string, age: int) -> Result<Person, string> {\n    if (age < 18) {\n        return Err(\"too young\");\n    }\n\n    if (age > 98) {\n        return Err(\"too old\");\n    }\n\n    Ok(Person { name, age })\n}\n\nfn main() {\n    let xs = [\"a\", \"b\", \"c\"];\n    let element = xs.get(2); // Option<string>\n\n    match element {\n        Some(s) => fmt.Println(\"ok, the element was found:\", s),\n        None => fmt.Println(\"element not found\"),\n    }\n\n    let result = validate(\"alice\", 33); // Result<Person, string>\n\n    match result {\n        Ok(p) => fmt.Println(\"got a person:\", p),\n        Err(e) => fmt.Println(\"couldn't validate:\", e),\n    }\n}\n"},{"slug":"interoperability-with-go","title":"Interoperability with Go","description":"<p>One ambitious goal of this project is to be fully compatible with the existing\nGo ecosystem.</p>\n\n<p>You&#39;ve already seen how the <code>fmt</code> package was used in previous examples, but how\ndo we deal with functions that return multiple values?</p>\n\n<p>This is where our trusty <code>Option</code> and <code>Result</code> types come in! The compiler will\nhandle the conversion <em>automatically</em> for you :)</p>\n\n<p>A good mental model is to think of return types in Go functions as:</p>\n\n<pre><code>when return type is    (T, bool)\nit becomes             Option&lt;T&gt;\n\nwhen return type is    (T, error)\nit becomes             Result&lt;T, E&gt;\n</code></pre>\n\n<p>Let&#39;s take the <a href=\"https://pkg.go.dev/os#LookupEnv\">os.LookupEnv</a> function as an\nexample:</p>\n\n<pre><code>Go definition:\n  func LookupEnv(key string) (string, bool)\n\nbecomes:\n  fn LookupEnv(key: string) -&gt; Option&lt;string&gt;\n</code></pre>\n\n<p>Or the <a href=\"https://pkg.go.dev/os#Stat\">os.Stat</a> function from the same package:</p>\n\n<pre><code>Go definition:\n  func Stat(name string) (FileInfo, error)\n\nbecomes:\n  fn Stat(name: string) -&gt; Result&lt;FileInfo&gt;\n</code></pre>\n\n<blockquote class=\"hint\"><p><code>Result&lt;T&gt;</code> is short-hand for <code>Result&lt;T, error&gt;</code> where <code>error</code> is the standard\nGo interface.</p>\n</blockquote>\n<p>With this simple convention, pretty much any Go package can be used in Borgo\ncode! All is needed is a package declaration, which is discussed in the next\nsection.</p>\n","code":"use fmt;\nuse io::fs; // TODO there should be no need of importing this\nuse os;\n\nfn main() {\n    let key = os.LookupEnv(\"HOME\");\n\n    match key {\n        // Option<T>\n        Some(s) => fmt.Println(\"home dir:\", s),\n        None => fmt.Println(\"Not found in env\"),\n    }\n\n    let info = os.Stat(\"file-does-not-exist\");\n\n    match info {\n        // Result<T, E>\n        Ok(_) => fmt.Println(\"The file exists\"),\n        Err(err) => fmt.Println(\"Got error reading file\", err),\n    }\n}\n"},{"slug":"package-definitions","title":"Package definitions","description":"<p>In order to use existing Go packages, Borgo needs to know what types and\nfunctions they contain.</p>\n\n<p>You can see these bindings in the\n<a href=\"https://github.com/borgo-lang/borgo/tree/main/std\">std/</a> folder.</p>\n\n<p>The example on the right uses the <code>regexp</code> package from the Go standard library.\nThat&#39;s only possible because of the bindings at <code>std/regexp/regexp.rgb</code>, which\nlook like this:</p>\n\n<pre><code>struct Regexp { }\n\nfn Compile  (expr: string) -&gt; Result&lt;&amp;Regexp&gt; { EXT }\n\nfn CompilePOSIX  (expr: string) -&gt; Result&lt;&amp;Regexp&gt; { EXT }\n\nfn MustCompile  (str: string) -&gt; &amp;Regexp { EXT }\n\nfn MustCompilePOSIX  (str: string) -&gt; &amp;Regexp { EXT }\n\nfn Match  (pattern: string, b: [byte]) -&gt; Result&lt;bool&gt; { EXT }\n\n// ... other stuff\n</code></pre>\n\n<p>Right now the stdlib comes with very few bindings to the actual Go stdlib, just\na few functions here and there for testing purposes.</p>\n\n<p>Writing such declarations by hand is a pain! There&#39;s no reason why this process\ncouldn&#39;t be automated though. The compiler comes with an <code>importer</code> tool that\nparses a Go package and generates corresponding bindings to be used in Borgo.</p>\n\n<p>So if bindings to the <code>regexp</code> package didn&#39;t exist, you could generate them by\nrunning the following:</p>\n\n<pre><code>just run-importer -folder /usr/local/go/src/regexp &gt; std/regexp/regexp.brg\n</code></pre>\n","code":"use fmt;\nuse regexp;\n\nfn main() {\n    let validID = regexp.MustCompile(r\"^[a-z]+\\[[0-9]+\\]$\");\n\n    fmt.Println(validID.MatchString(\"adam[23]\"));\n    fmt.Println(validID.MatchString(\"eve[7]\"));\n}\n"},{"slug":"pointers-and-references","title":"Pointers and References","description":"<p><strong>NOTE</strong> Right now this is more wishful thinking than anything :D I plan to\nimplement an extra pass in the compiler pipeline that can check if references\nare handed out correctly, but <strong>right now you can pass around references of any\ntype and not get an error</strong>.</p>\n\n<p>Borgo dosn&#39;t have a borrow checker: all memory is managed by the Go runtime.\nThat&#39;s one of the main benefits of compiling to Go after all!</p>\n\n<p>Despite that, when handing out a <em>reference</em> of a value to a function, it is\nstill useful to be explicit about whether the reference is <em>mutable</em> or\n<em>immutable</em>.</p>\n\n<p>Borgo distinguishes between:</p>\n\n<ul>\n<li><code>&amp;mut T</code> references, which allow modification of the underlying value</li>\n<li><code>&amp;T</code> references, which are read-only and ensure no changes will occur</li>\n</ul>\n\n<p>So for example, a function that computes the sum of a slice of ints, has no need\nto mutate it. It makes sense to accept a read-only reference.</p>\n\n<pre><code>fn sum(xs: &amp;[int]) -&gt; int {\n  // ...\n}\n</code></pre>\n\n<p>Whereas if we wanted to add elements to it, then we&#39;d need a mutable reference.</p>\n\n<pre><code>fn add_number(xs: &amp;mut [int], n: int) {\n  // ...\n}\n</code></pre>\n\n<p>When generating Go code, this makes no difference, it&#39;s all pointers under the\nhood!</p>\n\n<blockquote class=\"hint\"><p>Because there&#39;s no borrow checker involved, it makes less sense to talk about\n<em>exclusive</em> and <em>shared</em> references. It&#39;s perfectly valid to have multiple\nmutable references live at the same point, something that would not be permitted\nby Rust&#39;s ownership rules.</p>\n</blockquote>","code":"// example missing,\n\nfn main() {}\n"},{"slug":"methods","title":"Methods","description":"<p>To define methods on types, you can use <code>impl {}</code> blocks.</p>\n\n<p>Methods need a <code>self</code> receiver, like in Rust. If the receiver is <code>&amp;mut self</code> or\n<code>&amp;self</code> then the generated method will be a pointer receiver <code>(self *T)</code>.</p>\n\n<p>It&#39;s also possible to declare static methods: they will compile to normal\nfunctions namespaced with the type name (ie. <code>Person_new()</code>).</p>\n","code":"use fmt;\n\nstruct Person {\n    name: string,\n    hours_slept: int,\n}\n\nimpl Person {\n    fn new(name: string) -> Person {\n        Person {\n            name,\n            hours_slept: 0,\n        }\n    }\n\n    // Needs mutable reference because modifies structure\n    fn sleep(&mut self) {\n        self.hours_slept = self.hours_slept + 1;\n    }\n\n    // Ok with read-only reference\n    fn ready_for_work(&self) -> bool {\n        self.hours_slept > 5\n    }\n\n    fn ready_to_party(&self) -> bool {\n        self.hours_slept > 10\n    }\n}\n\nfn main() {\n    let mut p = Person::new(\"alice\");\n\n    p.sleep();\n    p.sleep();\n\n    fmt.Println(\"is ready:\", p.ready_for_work());\n}\n"},{"slug":"interfaces-traits","title":"Interfaces (traits)","description":"<p>Interfaces in Borgo work the same as in Go, it&#39;s all duck typing.</p>\n\n<p>If a type implements the methods declared by the interface, then the type is an\ninstance of that interface.</p>\n\n<p>Embedded interfaces are also supported, just list out the other interfaces\n<em>implied</em> by the one being defined. For example, the <code>ReadWriter</code> interface from\nthe <code>io</code> package can be defined as:</p>\n\n<pre><code>trait ReadWriter: Reader + Writer {}\n</code></pre>\n\n<p>One possibly confusing detail is that Borgo uses the <code>trait</code> keyword to define\ninterfaces ^_^&#39;.</p>\n\n<p>This is because the underlying parser is looking for Rust syntax. In the future\nwe&#39;ll have our own parser (or more realistically just a fork) and this will no\nlonger be a problem!</p>\n\n<blockquote class=\"hint\"><p>Borgo doesn&#39;t support <a href=\"https://go.dev/ref/spec#General_interfaces\">type sets</a>,\nyou can only define methods in interfaces. Constraints still work, but they will\nonly be checked by the Go compiler.</p>\n</blockquote>","code":"use fmt;\nuse math;\n\ntrait geometry {\n    fn area() -> float64;\n    fn perim() -> float64;\n}\n\nstruct rect {\n    width: float64,\n    height: float64,\n}\n\nimpl rect {\n    fn area(self) -> float64 {\n        self.width * self.height\n    }\n\n    fn perim(self) -> float64 {\n        2 * self.width + 2 * self.height\n    }\n}\n\nstruct circle {\n    radius: float64,\n}\n\nimpl circle {\n    fn area(self) -> float64 {\n        math.Pi * self.radius * self.radius\n    }\n\n    fn perim(self) -> float64 {\n        2 * math.Pi * self.radius\n    }\n}\n\nfn measure(g: geometry) {\n    fmt.Println(g);\n    fmt.Println(g.area());\n    fmt.Println(g.perim());\n}\n\nfn main() {\n    let r = rect {\n        width: 3,\n        height: 4,\n    };\n    let c = circle { radius: 5 };\n\n    measure(r);\n    measure(c);\n}\n"},{"slug":"error-handling","title":"Error handling","description":"<p>In functions that return a <code>Result</code>, it&#39;s possible to propagate errors with the\n<code>?</code> operator.</p>\n\n<p>This is similar to what happens in Rust, refer to the section on\n<a href=\"https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors\">Propagating errors</a>\nin the Rust book .</p>\n\n<p>Currently the <code>?</code> operator only works with <code>Result</code>, but it will be extended to\nalso work with <code>Option</code>.</p>\n","code":"use fmt;\nuse io;\nuse os;\n\nfn copy_file(src: string, dst: string) -> Result<(), error> {\n    let stat = os.Stat(src)?;\n\n    if !stat.Mode().IsRegular() {\n        return Err(fmt.Errorf(\"%s is not a regular file\", src));\n    }\n\n    let source = os.Open(src)?;\n    defer!(source.Close());\n\n    let destination = os.Create(dst)?;\n    defer!(destination.Close());\n\n    // ignore number of bytes copied\n    let _ = io.Copy(destination, source)?;\n\n    Ok(())\n}\n\nfn main() {\n    match copy_file(\"go.mod\", \"asdf\") {\n        Ok(_) => fmt.Println(\"file copied\"),\n        Err(e) => fmt.Println(\"error copying:\", e),\n    }\n}\n"}]

    // Rust compiler
    import { default as initRust, compile_wasm } from "/pkg/wasm.js";

    initRust().then(() => window.Borgo.compiler_ready())

    window.Borgo.compile_wasm = compile_wasm

    window.Borgo.main(EXAMPLES)
  </script>
</body>
</html>
