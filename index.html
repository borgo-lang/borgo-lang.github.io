<!DOCTYPE html>
<html>
<head>
  <title>Borgo Programming Language</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <header>
    <h1>Borgo Programming Language</h1>
  </header>

  <main>
    <div class="links-pane">
      <section id="examples">
                  <a
            href="#intro"
            onClick="Borgo.selectExample('intro')"
          >
              Intro          </a>
                  <a
            href="#primitive-types"
            onClick="Borgo.selectExample('primitive-types')"
          >
              Primitive Types          </a>
                  <a
            href="#control-flow"
            onClick="Borgo.selectExample('control-flow')"
          >
              Control flow          </a>
                  <a
            href="#algebraic-data-types-and-pattern-matching"
            onClick="Borgo.selectExample('algebraic-data-types-and-pattern-matching')"
          >
              Algebraic data types and pattern matching          </a>
                  <a
            href="#structs"
            onClick="Borgo.selectExample('structs')"
          >
              Structs          </a>
                  <a
            href="#result-and-option"
            onClick="Borgo.selectExample('result-and-option')"
          >
              Result and Option          </a>
                  <a
            href="#interoperability-with-go"
            onClick="Borgo.selectExample('interoperability-with-go')"
          >
              Interoperability with Go          </a>
                  <a
            href="#package-definitions"
            onClick="Borgo.selectExample('package-definitions')"
          >
              Package definitions          </a>
                  <a
            href="#pointers-and-references"
            onClick="Borgo.selectExample('pointers-and-references')"
          >
              Pointers and References          </a>
                  <a
            href="#methods"
            onClick="Borgo.selectExample('methods')"
          >
              Methods          </a>
                  <a
            href="#interfaces"
            onClick="Borgo.selectExample('interfaces')"
          >
              Interfaces          </a>
                  <a
            href="#error-handling"
            onClick="Borgo.selectExample('error-handling')"
          >
              Error handling          </a>
                  <a
            href="#zero-values-and-nil"
            onClick="Borgo.selectExample('zero-values-and-nil')"
          >
              Zero values and nil          </a>
                  <a
            href="#concurrency-goroutines"
            onClick="Borgo.selectExample('concurrency-goroutines')"
          >
              Concurrency (goroutines)          </a>
                  <a
            href="#channels"
            onClick="Borgo.selectExample('channels')"
          >
              Channels          </a>
                  <a
            href="#select-statements"
            onClick="Borgo.selectExample('select-statements')"
          >
              Select statements          </a>
              </section>
    </div>

    <section id="content" class="content-pane">
                  <article data-slug="intro">
            <h2>
              Intro            </h2>

            <div>
              <p><img src="https://raw.githubusercontent.com/borgo-lang/borgo-lang.github.io/main/borgo.jpg" alt="Borgo sits between Go and Rust"></p>

<p>Borgo is a new programming language that compiles to Go.</p>

<p>For a high-level overview of the features and instructions on running the
compiler locally, check the
<a href="https://github.com/borgo-lang/borgo#readme">README</a>.</p>

<p>This playground runs the compiler as a wasm binary and then sends the transpiled
go output to the official Go playground for execution.</p>
            </div>

            <pre data-example="&quot;use fmt\n\nenum NetworkState&lt;T&gt; {\n    Loading,\n    Failed(int),\n    Success(T),\n}\n\nstruct Response {\n    title: string,\n    duration: int,\n}\n\nfn main() {\n    let res = Response {\n        title: \&quot;Hello world\&quot;,\n        duration: 0,\n    }\n\n    let state = NetworkState.Success(res)\n\n    let msg = match state {\n        NetworkState.Loading =&gt; \&quot;still loading\&quot;,\n        NetworkState.Failed(code) =&gt; fmt.Sprintf(\&quot;Got error code: %d\&quot;, code),\n        NetworkState.Success(res) =&gt; res.title,\n    }\n\n    fmt.Println(msg)\n}&quot;">use fmt

enum NetworkState&lt;T&gt; {
    Loading,
    Failed(int),
    Success(T),
}

struct Response {
    title: string,
    duration: int,
}

fn main() {
    let res = Response {
        title: &quot;Hello world&quot;,
        duration: 0,
    }

    let state = NetworkState.Success(res)

    let msg = match state {
        NetworkState.Loading =&gt; &quot;still loading&quot;,
        NetworkState.Failed(code) =&gt; fmt.Sprintf(&quot;Got error code: %d&quot;, code),
        NetworkState.Success(res) =&gt; res.title,
    }

    fmt.Println(msg)
}</pre>
          </article>
                  <article data-slug="primitive-types">
            <h2>
              Primitive Types            </h2>

            <div>
              <p>Primitive types are the same as in Go.</p>

<p>Collections like slices and maps can be used without specifying the type of the
values.</p>

<p>For example, a slice of int elements would be declared as <code>[]int{1,2,3}</code> in Go,
whereas Borgo relies on type inference to determine the type, so you can just
write <code>[1, 2, 3]</code>.</p>

<p>Functions like <code>append()</code> and <code>len()</code> are available as methods.</p>

<p>Maps are initialized with the <code>Map.new()</code> function, which under the hood
compiles to a <code>map[K]V{}</code> expression, with the <code>K</code> and <code>V</code> types helpfully
filled in for you.</p>

<p>Borgo also has tuples! They work exactly like in Rust.</p>

<p>Multiline strings are defined by prefixing each line with <code>\\</code> like in Zig. This
has the benefit that no character needs escaping and allows more control over
whitespace.</p>
            </div>

            <pre data-example="&quot;use fmt\n\nfn main() {\n    let n = 1\n    let s = \&quot;hello\&quot;\n    let b = false\n\n    fmt.Println(\&quot;primitives: \&quot;, n, s, b)\n\n    let mut xs = [1,2,3]\n    fmt.Println(\&quot;slice:\&quot;, xs)\n\n    xs = xs.Append(10)\n    fmt.Println(\&quot;len after append:\&quot;, xs.Len())\n\n    let mut m = Map.new()\n    m.Insert(1, \&quot;alice\&quot;)\n    m.Insert(2, \&quot;bob\&quot;)\n\n    fmt.Println(\&quot;map:\&quot;, m)\n\n    let pair = (\&quot;hey\&quot;, true)\n    fmt.Println(\&quot;second element in tuple:\&quot;, pair.1)\n\n    let multi = \\\\a multi line\n        \\\\  string with unescaped \&quot;quotes\&quot;\n        \\\\ that ends here\n\n    fmt.Println(\&quot;multiline string:\&quot;, multi)\n}&quot;">use fmt

fn main() {
    let n = 1
    let s = &quot;hello&quot;
    let b = false

    fmt.Println(&quot;primitives: &quot;, n, s, b)

    let mut xs = [1,2,3]
    fmt.Println(&quot;slice:&quot;, xs)

    xs = xs.Append(10)
    fmt.Println(&quot;len after append:&quot;, xs.Len())

    let mut m = Map.new()
    m.Insert(1, &quot;alice&quot;)
    m.Insert(2, &quot;bob&quot;)

    fmt.Println(&quot;map:&quot;, m)

    let pair = (&quot;hey&quot;, true)
    fmt.Println(&quot;second element in tuple:&quot;, pair.1)

    let multi = \\a multi line
        \\  string with unescaped &quot;quotes&quot;
        \\ that ends here

    fmt.Println(&quot;multiline string:&quot;, multi)
}</pre>
          </article>
                  <article data-slug="control-flow">
            <h2>
              Control flow            </h2>

            <div>
              <p>Like in Go, the only values that can be iterated over are slices, maps, channels
and strings.</p>

<p>However, loops always iterate over a single value, which is the element in the
slice (contrary to Go, where using a single iteration variable gives you the
index of the element).</p>

<p>To iterate over <code>(index, element)</code> pairs call the <code>.enumerate()</code> method on
slices. This has no runtime cost, it just aids the compiler in generating the
correct code.</p>

<p>When iterating over maps, you should always destructure values with
<code>(key, value)</code> pairs instead of a single value.</p>

<p>Like in Rust, infinite loops use the <code>loop {}</code> construct whereas loops with
conditions use <code>while {}</code>.</p>

<p>Expressions like <code>if</code>, <code>match</code> and blocks return a value, so you can assign
their result to a variable.</p>
            </div>

            <pre data-example="&quot;use fmt\nuse math.rand\n\nfn main() {\n    let xs = [\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;]\n\n    fmt.Println(\&quot;For loop over slices\&quot;)\n    for letter in xs {\n        fmt.Println(letter)\n    }\n\n    fmt.Println(\&quot;Indexed for loop\&quot;)\n    for (index, letter) in xs.Enumerate() {\n        fmt.Println(index, letter)\n    }\n\n    let m = Map.new()\n    m.Insert(1, \&quot;alice\&quot;)\n    m.Insert(2, \&quot;bob\&quot;)\n\n    fmt.Println(\&quot;For loop over maps\&quot;)\n    for (key, value) in m {\n        fmt.Println(key, value)\n    }\n\n    fmt.Println(\&quot;Loop with no condition\&quot;)\n    loop {\n        let n = rand.Float64()\n        fmt.Println(\&quot;looping...\&quot;, n)\n\n        if n &gt; 0.75 {\n            break\n        }\n    }\n\n    fmt.Println(\&quot;While loop\&quot;)\n\n    let mut count = 0\n    while (count &lt; 5) {\n        fmt.Println(count)\n        count = count + 1\n    }\n\n    fmt.Println(\&quot;using if statements as expressions\&quot;)\n    fmt.Println(if 5 &gt; 3 { \&quot;ok\&quot; } else { \&quot;nope\&quot; })\n\n    let block_result = {\n        let a = 1\n        let b = 2\n        a + b\n    }\n\n    fmt.Println(\&quot;block result:\&quot;, block_result)\n}&quot;">use fmt
use math.rand

fn main() {
    let xs = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

    fmt.Println(&quot;For loop over slices&quot;)
    for letter in xs {
        fmt.Println(letter)
    }

    fmt.Println(&quot;Indexed for loop&quot;)
    for (index, letter) in xs.Enumerate() {
        fmt.Println(index, letter)
    }

    let m = Map.new()
    m.Insert(1, &quot;alice&quot;)
    m.Insert(2, &quot;bob&quot;)

    fmt.Println(&quot;For loop over maps&quot;)
    for (key, value) in m {
        fmt.Println(key, value)
    }

    fmt.Println(&quot;Loop with no condition&quot;)
    loop {
        let n = rand.Float64()
        fmt.Println(&quot;looping...&quot;, n)

        if n &gt; 0.75 {
            break
        }
    }

    fmt.Println(&quot;While loop&quot;)

    let mut count = 0
    while (count &lt; 5) {
        fmt.Println(count)
        count = count + 1
    }

    fmt.Println(&quot;using if statements as expressions&quot;)
    fmt.Println(if 5 &gt; 3 { &quot;ok&quot; } else { &quot;nope&quot; })

    let block_result = {
        let a = 1
        let b = 2
        a + b
    }

    fmt.Println(&quot;block result:&quot;, block_result)
}</pre>
          </article>
                  <article data-slug="algebraic-data-types-and-pattern-matching">
            <h2>
              Algebraic data types and pattern matching            </h2>

            <div>
              <p>You can define algebraic data types with the <code>enum</code> keyword (pretty much like
Rust).</p>

<p>Pattern matches must be exhaustive, meaning the compiler will return an error
when a case is missing (try removing any case statement from the example and see
what happens!).</p>

<blockquote class="hint"><p>For now, variants can only be defined as tuples and not as structs.</p>
</blockquote>            </div>

            <pre data-example="&quot;use fmt\nuse strings\n\n\nenum IpAddr {\n    V4(uint8, uint8, uint8, uint8),\n    V6(string),\n}\n\nfn isPrivate(ip: IpAddr) -&gt; bool {\n  match ip {\n    IpAddr.V4(a, b, _, _) =&gt; {\n        if a == 10 {\n            return true\n        }\n\n        if a == 172 &amp;&amp; b &gt;= 16 &amp;&amp; b &lt;= 31 {\n            return true\n        }\n\n        if a == 192 &amp;&amp; b == 168 {\n            return true\n        }\n\n        false\n    }\n\n    IpAddr.V6(s) =&gt; strings.HasPrefix(s, \&quot;fc00::\&quot;)\n  }\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn valueInCents(coin: Coin) -&gt; int {\n    match coin {\n        Coin.Penny =&gt; 1,\n        Coin.Nickel =&gt; 5,\n        Coin.Dime =&gt; 10,\n        Coin.Quarter =&gt; 25,\n    }\n}\n\nfn main() {\n    let home = IpAddr.V4(127, 0, 0, 1)\n    let loopback = IpAddr.V6(\&quot;::1\&quot;)\n    fmt.Println(\&quot;home ip is private: \&quot;, home, isPrivate(home))\n    fmt.Println(\&quot;loopback: \&quot;, loopback)\n\n    let cents = valueInCents(Coin.Nickel)\n    fmt.Println(\&quot;cents:\&quot;, cents)\n\n}&quot;">use fmt
use strings


enum IpAddr {
    V4(uint8, uint8, uint8, uint8),
    V6(string),
}

fn isPrivate(ip: IpAddr) -&gt; bool {
  match ip {
    IpAddr.V4(a, b, _, _) =&gt; {
        if a == 10 {
            return true
        }

        if a == 172 &amp;&amp; b &gt;= 16 &amp;&amp; b &lt;= 31 {
            return true
        }

        if a == 192 &amp;&amp; b == 168 {
            return true
        }

        false
    }

    IpAddr.V6(s) =&gt; strings.HasPrefix(s, &quot;fc00::&quot;)
  }
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valueInCents(coin: Coin) -&gt; int {
    match coin {
        Coin.Penny =&gt; 1,
        Coin.Nickel =&gt; 5,
        Coin.Dime =&gt; 10,
        Coin.Quarter =&gt; 25,
    }
}

fn main() {
    let home = IpAddr.V4(127, 0, 0, 1)
    let loopback = IpAddr.V6(&quot;::1&quot;)
    fmt.Println(&quot;home ip is private: &quot;, home, isPrivate(home))
    fmt.Println(&quot;loopback: &quot;, loopback)

    let cents = valueInCents(Coin.Nickel)
    fmt.Println(&quot;cents:&quot;, cents)

}</pre>
          </article>
                  <article data-slug="structs">
            <h2>
              Structs            </h2>

            <div>
              <p>Defining and instantiating structs is similar to Rust.</p>

<p>Contrary to Go, all struct fields must be initialized. See the section on <code>nil</code>
and zero values for more information.</p>
            </div>

            <pre data-example="&quot;use fmt\n\nstruct Person {\n    name: string,\n    hobbies: [Hobby],\n}\n\nenum Hobby {\n    SkyDiving,\n    StaringAtWall,\n    Other(string),\n}\n\nfn main() {\n    let mut p = Person {\n        name: \&quot;bob\&quot;,\n        hobbies: [Hobby.StaringAtWall, Hobby.Other(\&quot;sleep\&quot;)],\n    }\n\n    fmt.Println(\&quot;person:\&quot;, p)\n\n    p.hobbies = p.hobbies.Append(Hobby.SkyDiving)\n    fmt.Println(\&quot;with more hobbies:\&quot;, p)\n}&quot;">use fmt

struct Person {
    name: string,
    hobbies: [Hobby],
}

enum Hobby {
    SkyDiving,
    StaringAtWall,
    Other(string),
}

fn main() {
    let mut p = Person {
        name: &quot;bob&quot;,
        hobbies: [Hobby.StaringAtWall, Hobby.Other(&quot;sleep&quot;)],
    }

    fmt.Println(&quot;person:&quot;, p)

    p.hobbies = p.hobbies.Append(Hobby.SkyDiving)
    fmt.Println(&quot;with more hobbies:&quot;, p)
}</pre>
          </article>
                  <article data-slug="result-and-option">
            <h2>
              Result and Option            </h2>

            <div>
              <p>Sometimes it&#39;s helpful to deal with values that may or may not be there. This is
the idea behind the <code>Option&lt;T&gt;</code> type.</p>

<p>For example, to get an element out of a slice or a map, you can use the
<code>.get(index)</code> method that will force you to handle the case where the element
isn&#39;t there.</p>

<p>Other times you may want to return a value <em>or</em> an error. In those cases use
<code>Result&lt;T, E&gt;</code> to let the caller know that a function may return an error.</p>

<p>When you&#39;re sure that a value is <em>definitely</em> there, you can call <code>.unwrap()</code>.
Like in Rust, this is an unsafe operation and will panic.</p>

<p>A lot of methods are missing from both <code>Result</code> and <code>Option</code>, contributions to
the stdlib are welcome!</p>
            </div>

            <pre data-example="&quot;use fmt\n\nstruct Person {\n    name: string,\n    age: int\n}\n\nfn validate(name: string, age: int) -&gt; Result&lt;Person, string&gt; {\n    if (age &lt; 18) {\n        return Err(\&quot;too young\&quot;)\n    }\n\n    if (age &gt; 98) {\n        return Err(\&quot;too old\&quot;)\n    }\n\n    Ok(Person { name, age })\n}\n\nfn main() {\n    let xs = [\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;]\n    let element = xs.Get(2) // Option&lt;string&gt;\n\n    match element {\n        Some(s) =&gt; fmt.Println(\&quot;ok, the element was found:\&quot;, s),\n        None =&gt; fmt.Println(\&quot;element not found\&quot;),\n    }\n\n    let result = validate(\&quot;alice\&quot;, 33) // Result&lt;Person, string&gt;\n\n    match result {\n        Ok(p) =&gt; fmt.Println(\&quot;got a person:\&quot;, p),\n        Err(e) =&gt; fmt.Println(\&quot;couldn&#39;t validate:\&quot;, e),\n    }\n}&quot;">use fmt

struct Person {
    name: string,
    age: int
}

fn validate(name: string, age: int) -&gt; Result&lt;Person, string&gt; {
    if (age &lt; 18) {
        return Err(&quot;too young&quot;)
    }

    if (age &gt; 98) {
        return Err(&quot;too old&quot;)
    }

    Ok(Person { name, age })
}

fn main() {
    let xs = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
    let element = xs.Get(2) // Option&lt;string&gt;

    match element {
        Some(s) =&gt; fmt.Println(&quot;ok, the element was found:&quot;, s),
        None =&gt; fmt.Println(&quot;element not found&quot;),
    }

    let result = validate(&quot;alice&quot;, 33) // Result&lt;Person, string&gt;

    match result {
        Ok(p) =&gt; fmt.Println(&quot;got a person:&quot;, p),
        Err(e) =&gt; fmt.Println(&quot;couldn&#39;t validate:&quot;, e),
    }
}</pre>
          </article>
                  <article data-slug="interoperability-with-go">
            <h2>
              Interoperability with Go            </h2>

            <div>
              <p>One ambitious goal of this project is to be fully compatible with the existing
Go ecosystem.</p>

<p>You&#39;ve already seen how the <code>fmt</code> package was used in previous examples, but how
do we deal with functions that return multiple values?</p>

<p>This is where our trusty <code>Option</code> and <code>Result</code> types come in! The compiler will
handle the conversion <em>automatically</em> for you :)</p>

<p>A good mental model is to think of return types in Go functions as:</p>

<pre><code>when return type is    (T, bool)
it becomes             Option&lt;T&gt;

when return type is    (T, error)
it becomes             Result&lt;T, E&gt;
</code></pre>

<p>Let&#39;s take the <a href="https://pkg.go.dev/os#LookupEnv">os.LookupEnv</a> function as an
example:</p>

<pre><code>Go definition:
  func LookupEnv(key string) (string, bool)

becomes:
  fn LookupEnv(key: string) -&gt; Option&lt;string&gt;
</code></pre>

<p>Or the <a href="https://pkg.go.dev/os#Stat">os.Stat</a> function from the same package:</p>

<pre><code>Go definition:
  func Stat(name string) (FileInfo, error)

becomes:
  fn Stat(name: string) -&gt; Result&lt;FileInfo&gt;
</code></pre>

<blockquote class="hint"><p><code>Result&lt;T&gt;</code> is short-hand for <code>Result&lt;T, error&gt;</code> where <code>error</code> is the standard
Go interface.</p>
</blockquote>
<p>With this simple convention, pretty much any Go package can be used in Borgo
code! All is needed is a package declaration, which is discussed in the next
section.</p>
            </div>

            <pre data-example="&quot;use fmt\nuse os\n\nfn main() {\n    let key = os.LookupEnv(\&quot;HOME\&quot;)\n\n    match key {\n        // Option&lt;T&gt;\n        Some(s) =&gt; fmt.Println(\&quot;home dir:\&quot;, s),\n        None =&gt; fmt.Println(\&quot;Not found in env\&quot;),\n    }\n\n    let info = os.Stat(\&quot;file-does-not-exist\&quot;)\n\n    match info {\n        // Result&lt;T, E&gt;\n        Ok(_) =&gt; fmt.Println(\&quot;The file exists\&quot;),\n        Err(err) =&gt; fmt.Println(\&quot;Got error reading file\&quot;, err),\n    }\n}&quot;">use fmt
use os

fn main() {
    let key = os.LookupEnv(&quot;HOME&quot;)

    match key {
        // Option&lt;T&gt;
        Some(s) =&gt; fmt.Println(&quot;home dir:&quot;, s),
        None =&gt; fmt.Println(&quot;Not found in env&quot;),
    }

    let info = os.Stat(&quot;file-does-not-exist&quot;)

    match info {
        // Result&lt;T, E&gt;
        Ok(_) =&gt; fmt.Println(&quot;The file exists&quot;),
        Err(err) =&gt; fmt.Println(&quot;Got error reading file&quot;, err),
    }
}</pre>
          </article>
                  <article data-slug="package-definitions">
            <h2>
              Package definitions            </h2>

            <div>
              <p>In order to use existing Go packages, Borgo needs to know what types and
functions they contain. This is done in declaration files, which serve a similar
purpose to what you might see in Typescript with <code>d.ts</code> files.</p>

<p>Only a small part of the Go stdlib is currently available for use in Borgo --
check the <a href="https://github.com/borgo-lang/borgo/tree/main/std">std/</a> folder for
more information.</p>

<p>The example on the right uses the <code>regexp</code> package from the Go standard library.
The relevant bindings are defined in <code>std/regexp/regexp.brg</code> (here&#39;s a snippet):</p>

<pre><code>struct Regexp { }

fn Compile  (expr: string) -&gt; Result&lt;*Regexp&gt; { EXT }

fn CompilePOSIX  (expr: string) -&gt; Result&lt;*Regexp&gt; { EXT }

fn MustCompile  (str: string) -&gt; *Regexp { EXT }

fn MustCompilePOSIX  (str: string) -&gt; *Regexp { EXT }

fn Match  (pattern: string, b: [byte]) -&gt; Result&lt;bool&gt; { EXT }

// ... other stuff
</code></pre>

<p>Writing such declarations by hand is a pain! There&#39;s no reason why this process
couldn&#39;t be automated though. The compiler comes with an <code>importer</code> tool that
parses a Go package and generates corresponding bindings to be used in Borgo.</p>
            </div>

            <pre data-example="&quot;use fmt\nuse regexp\n\nfn main() {\n    let validID = regexp.MustCompile(\&quot;^[a-z]+[[0-9]+]$\&quot;)\n\n    fmt.Println(validID.MatchString(\&quot;adam[23]\&quot;))\n    fmt.Println(validID.MatchString(\&quot;eve[7]\&quot;))\n}&quot;">use fmt
use regexp

fn main() {
    let validID = regexp.MustCompile(&quot;^[a-z]+[[0-9]+]$&quot;)

    fmt.Println(validID.MatchString(&quot;adam[23]&quot;))
    fmt.Println(validID.MatchString(&quot;eve[7]&quot;))
}</pre>
          </article>
                  <article data-slug="pointers-and-references">
            <h2>
              Pointers and References            </h2>

            <div>
              <p>Pointers and References work the same as in Go.</p>

<p>To dereference a pointer, use <code>foo.*</code> instead of <code>*foo</code> (like in Zig).</p>
            </div>

            <pre data-example="&quot;use fmt\n\nstruct Foo {\n    bar: int\n}\n\nstruct Bar {\n    foo: *Foo\n}\n\nfn main() {\n    let mut f = Foo { bar: 0 }\n    let b = Bar { foo: &amp;f }\n\n    f.bar = 99\n\n    fmt.Println(b.foo)\n\n    // pointer dereference\n    // In Go, this would be:   *b.foo = ...\n    b.foo.* = Foo { bar: 23 }\n\n    fmt.Println(b.foo)\n}&quot;">use fmt

struct Foo {
    bar: int
}

struct Bar {
    foo: *Foo
}

fn main() {
    let mut f = Foo { bar: 0 }
    let b = Bar { foo: &amp;f }

    f.bar = 99

    fmt.Println(b.foo)

    // pointer dereference
    // In Go, this would be:   *b.foo = ...
    b.foo.* = Foo { bar: 23 }

    fmt.Println(b.foo)
}</pre>
          </article>
                  <article data-slug="methods">
            <h2>
              Methods            </h2>

            <div>
              <p>To define methods on types, you can use <code>impl {}</code> blocks.</p>

<p>In Go, the method receiver must be specified at each function declaration. In
Borgo, this is specified only once at the beginning of the <code>impl</code> block
(<code>p: *Person</code>). All functions within the block will have that receiver.</p>

<p>It&#39;s also possible to declare static methods: functions can be declared with
dots in their name, so you can define a <code>Person.new</code> function like in the
example.</p>
            </div>

            <pre data-example="&quot;use fmt\n\nstruct Person {\n    name: string,\n    hours_slept: int,\n}\n\nfn Person.new(name: string) -&gt; Person {\n    Person {\n        name,\n        hours_slept: 0,\n    }\n}\n\nimpl (p: *Person) {\n    fn sleep() {\n        p.hours_slept = p.hours_slept + 1 \n    }\n\n    fn ready_for_work() -&gt; bool {\n        p.hours_slept &gt; 5\n    }\n\n    fn ready_to_party() -&gt; bool {\n        p.hours_slept &gt; 10\n    }\n}\n\nfn main() {\n    let mut p = Person.new(\&quot;alice\&quot;)\n\n    p.sleep()\n    p.sleep()\n\n    fmt.Println(\&quot;is ready:\&quot;, p.ready_for_work())\n}&quot;">use fmt

struct Person {
    name: string,
    hours_slept: int,
}

fn Person.new(name: string) -&gt; Person {
    Person {
        name,
        hours_slept: 0,
    }
}

impl (p: *Person) {
    fn sleep() {
        p.hours_slept = p.hours_slept + 1 
    }

    fn ready_for_work() -&gt; bool {
        p.hours_slept &gt; 5
    }

    fn ready_to_party() -&gt; bool {
        p.hours_slept &gt; 10
    }
}

fn main() {
    let mut p = Person.new(&quot;alice&quot;)

    p.sleep()
    p.sleep()

    fmt.Println(&quot;is ready:&quot;, p.ready_for_work())
}</pre>
          </article>
                  <article data-slug="interfaces">
            <h2>
              Interfaces            </h2>

            <div>
              <p>Interfaces in Borgo work the same as in Go, it&#39;s all duck typing.</p>

<p>If a type implements the methods declared by the interface, then the type is an
instance of that interface.</p>

<p>Embedded interfaces are also supported, just list out the other interfaces
<em>implied</em> by the one being defined (prefixed by <code>impl</code>). For example, the
<code>ReadWriter</code> interface from the <code>io</code> package can be defined as:</p>

<pre><code>interface ReadWriter {
    impl Reader
    impl Writer
}
</code></pre>

<blockquote class="hint"><p><a href="https://go.dev/ref/spec#General_interfaces">type sets</a> are not supported.</p>
</blockquote>            </div>

            <pre data-example="&quot;use fmt\nuse math\n\ninterface geometry {\n    fn area() -&gt; float64\n    fn perim() -&gt; float64\n}\n\nstruct rect {\n    width: float64,\n    height: float64,\n}\n\nimpl (r: rect) {\n    fn area() -&gt; float64 {\n        r.width * r.height\n    }\n\n    fn perim() -&gt; float64 {\n        2 * r.width + 2 * r.height\n    }\n}\n\nstruct circle {\n    radius: float64,\n}\n\nimpl (c: circle) {\n    fn area() -&gt; float64 {\n        math.Pi * c.radius * c.radius\n    }\n\n    fn perim() -&gt; float64 {\n        2 * math.Pi * c.radius\n    }\n}\n\nfn measure(g: geometry) {\n    fmt.Println(g)\n    fmt.Println(g.area())\n    fmt.Println(g.perim())\n}\n\nfn main() {\n    let r = rect {\n        width: 3,\n        height: 4,\n    }\n\n    let c = circle { radius: 5 }\n\n    measure(r)\n    measure(c)\n}&quot;">use fmt
use math

interface geometry {
    fn area() -&gt; float64
    fn perim() -&gt; float64
}

struct rect {
    width: float64,
    height: float64,
}

impl (r: rect) {
    fn area() -&gt; float64 {
        r.width * r.height
    }

    fn perim() -&gt; float64 {
        2 * r.width + 2 * r.height
    }
}

struct circle {
    radius: float64,
}

impl (c: circle) {
    fn area() -&gt; float64 {
        math.Pi * c.radius * c.radius
    }

    fn perim() -&gt; float64 {
        2 * math.Pi * c.radius
    }
}

fn measure(g: geometry) {
    fmt.Println(g)
    fmt.Println(g.area())
    fmt.Println(g.perim())
}

fn main() {
    let r = rect {
        width: 3,
        height: 4,
    }

    let c = circle { radius: 5 }

    measure(r)
    measure(c)
}</pre>
          </article>
                  <article data-slug="error-handling">
            <h2>
              Error handling            </h2>

            <div>
              <p>In functions that return a <code>Result</code>, it&#39;s possible to propagate errors with the
<code>?</code> operator.</p>

<p>This is similar to what happens in Rust, refer to the section on
<a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors">Propagating errors</a>
in the Rust book .</p>

<p>Currently the <code>?</code> operator only works with <code>Result</code>, but it will be extended to
also work with <code>Option</code>.</p>
            </div>

            <pre data-example="&quot;use fmt\nuse io\nuse os\n\nfn copy_file(src: string, dst: string) -&gt; Result&lt;(), error&gt; {\n    let stat = os.Stat(src)?\n\n    if !stat.Mode().IsRegular() {\n        return Err(fmt.Errorf(\&quot;%s is not a regular file\&quot;, src))\n    }\n\n    let source = os.Open(src)?\n    defer source.Close()\n\n    let destination = os.Create(dst)?\n    defer destination.Close()\n\n    // ignore number of bytes copied\n    let _ = io.Copy(destination, source)?\n\n    Ok(())\n}\n\nfn copy_all_files(folder: string) -&gt; Result&lt;int, error&gt; {\n    let mut n = 0\n\n    for f in os.ReadDir(folder)? {\n        if !f.IsDir() {\n            let original = f.Name()\n            let new_name = fmt.Sprintf(\&quot;%s-copy\&quot;, original)\n\n            fmt.Println(\&quot;copying\&quot;, original, \&quot;to\&quot;, new_name)\n\n            copy_file(original, new_name)?\n            n = n + 1\n        }\n    }\n\n    Ok(n)\n}\n\nfn main() {\n    match copy_all_files(\&quot;.\&quot;) {\n        Ok(n) =&gt; fmt.Println(n, \&quot;files copied\&quot;),\n        Err(err) =&gt; fmt.Println(\&quot;Got error:\&quot;, err),\n    }\n}&quot;">use fmt
use io
use os

fn copy_file(src: string, dst: string) -&gt; Result&lt;(), error&gt; {
    let stat = os.Stat(src)?

    if !stat.Mode().IsRegular() {
        return Err(fmt.Errorf(&quot;%s is not a regular file&quot;, src))
    }

    let source = os.Open(src)?
    defer source.Close()

    let destination = os.Create(dst)?
    defer destination.Close()

    // ignore number of bytes copied
    let _ = io.Copy(destination, source)?

    Ok(())
}

fn copy_all_files(folder: string) -&gt; Result&lt;int, error&gt; {
    let mut n = 0

    for f in os.ReadDir(folder)? {
        if !f.IsDir() {
            let original = f.Name()
            let new_name = fmt.Sprintf(&quot;%s-copy&quot;, original)

            fmt.Println(&quot;copying&quot;, original, &quot;to&quot;, new_name)

            copy_file(original, new_name)?
            n = n + 1
        }
    }

    Ok(n)
}

fn main() {
    match copy_all_files(&quot;.&quot;) {
        Ok(n) =&gt; fmt.Println(n, &quot;files copied&quot;),
        Err(err) =&gt; fmt.Println(&quot;Got error:&quot;, err),
    }
}</pre>
          </article>
                  <article data-slug="zero-values-and-nil">
            <h2>
              Zero values and nil            </h2>

            <div>
              <p>In Borgo, you can&#39;t create <code>nil</code> values.</p>

<p>The concept of <code>null</code> references (or <code>nil</code> in this case) is being referred to as
&quot;The billion dollar mistake&quot; and modern languages are moving away from it with
types like <code>Option&lt;T&gt;</code>. Borgo tries to do the same.</p>

<p>You can still end up with null pointers if you&#39;re calling into existing Go code,
which is unfortunate. That should be solvable by writing better bindings, so
that functions that could return a null pointer, will instead return an
<code>Option&lt;*T&gt;</code>, forcing you to handle all cases.</p>

<p>In Go, it&#39;s common to see types not needing to be initialized, as their <em>zero
value</em> is ready to be used (ie. <code>sync.Mutex</code> or <code>sync.WaitGroup</code>). Borgo goes in
the opposite direction, requiring that all values are explicitely initialized.</p>

<p>You can use the built-in function <code>zeroValue()</code> whenever you need the <em>zero
value</em> of a type. While you won&#39;t need to provide a type annotation in all cases
(as the type can be inferred), it&#39;s probably clearer to annotate variables that
are initialized with <code>zeroValue()</code>.</p>

<p>As mentioned in a previous section, this also applies to struct fields, which
always need to be initialized.</p>
            </div>

            <pre data-example="&quot;use sync\nuse bytes\nuse fmt\n\nfn main() {\n     // in Go:\n     // var wg sync.WaitGroup\n     let wg: sync.WaitGroup = zeroValue()\n\n     // in Go:\n     // var b bytes.Buffer\n     let b: bytes.Buffer = zeroValue()\n\n     fmt.Println(\&quot;variables are initialized:\&quot;, wg, b)\n}&quot;">use sync
use bytes
use fmt

fn main() {
     // in Go:
     // var wg sync.WaitGroup
     let wg: sync.WaitGroup = zeroValue()

     // in Go:
     // var b bytes.Buffer
     let b: bytes.Buffer = zeroValue()

     fmt.Println(&quot;variables are initialized:&quot;, wg, b)
}</pre>
          </article>
                  <article data-slug="concurrency-goroutines">
            <h2>
              Concurrency (goroutines)            </h2>

            <div>
              <p>Borgo aims to support all concurrency primitives available in Go.</p>

<p>Use the <code>spawn</code> keyword (instead of <code>go</code>) to start a goroutine. The parameter
needs to be a function call.</p>

<p>Channels and <code>select {}</code> statements are discussed next.</p>
            </div>

            <pre data-example="&quot;use sync\nuse fmt\n\nstruct Counter {\n    count: int,\n    mu: sync.Mutex,\n}\n\nfn Counter.new() -&gt; Counter {\n    Counter { count: 0, mu: zeroValue() }\n}\n\nimpl (c: *Counter) {\n    fn Inc() {\n       c.mu.Lock() \n       c.count = c.count + 1\n       c.mu.Unlock() \n    }\n}\n\nfn main() {\n    let desired = 1000\n    let counter = Counter.new()\n\n    let wg: sync.WaitGroup = zeroValue()\n    wg.Add(desired)\n\n    let mut i = 0\n\n    while (i &lt; desired) {\n\n        // equivalent to:   go func() { ... }()\n        spawn (|| {\n            counter.Inc()\n            wg.Done()\n        })()\n\n        i = i + 1\n    }\n\n    wg.Wait()\n\n    fmt.Println(\&quot;Counter value:\&quot;, counter.count)\n}&quot;">use sync
use fmt

struct Counter {
    count: int,
    mu: sync.Mutex,
}

fn Counter.new() -&gt; Counter {
    Counter { count: 0, mu: zeroValue() }
}

impl (c: *Counter) {
    fn Inc() {
       c.mu.Lock() 
       c.count = c.count + 1
       c.mu.Unlock() 
    }
}

fn main() {
    let desired = 1000
    let counter = Counter.new()

    let wg: sync.WaitGroup = zeroValue()
    wg.Add(desired)

    let mut i = 0

    while (i &lt; desired) {

        // equivalent to:   go func() { ... }()
        spawn (|| {
            counter.Inc()
            wg.Done()
        })()

        i = i + 1
    }

    wg.Wait()

    fmt.Println(&quot;Counter value:&quot;, counter.count)
}</pre>
          </article>
                  <article data-slug="channels">
            <h2>
              Channels            </h2>

            <div>
              <p>Borgo doesn&#39;t provide any extra syntax to send/receive from channels.</p>

<p>You use <code>Channel.new()</code> to create a <code>Sender&lt;T&gt;</code> and <code>Receiver&lt;T&gt;</code>.These are
roughly equivalent to send-only and receive-only channels in Go and will compile
to raw channels in the final Go output.</p>

<p>With a <code>Sender&lt;T&gt;</code> you can call <code>send(value: T)</code> to send a value. With a
<code>Receiver&lt;T&gt;</code> you can call <code>recv() -&gt; T</code> to receive a value.</p>

<p>This design is somewhat inspired by the <code>sync::mspc::channel</code> module in the Rust
standard library.</p>
            </div>

            <pre data-example="&quot;use fmt\n\nfn main() {\n    let (sender, receiver) = Channel.new()\n\n    spawn (|| {\n        sender.Send(1)\n    })()\n\n    spawn (|| {\n        sender.Send(2)\n    })()\n\n    let msg = receiver.Recv()\n    let msg2 = receiver.Recv()\n\n    fmt.Println(msg + msg2)\n}&quot;">use fmt

fn main() {
    let (sender, receiver) = Channel.new()

    spawn (|| {
        sender.Send(1)
    })()

    spawn (|| {
        sender.Send(2)
    })()

    let msg = receiver.Recv()
    let msg2 = receiver.Recv()

    fmt.Println(msg + msg2)
}</pre>
          </article>
                  <article data-slug="select-statements">
            <h2>
              Select statements            </h2>

            <div>
              <p>There&#39;s no first class support for <code>select {}</code> statements yet. still use them
with a bit of a hacky workaround.</p>

<p>You can get around this by using <code>rawgo</code> which lets you embed raw Go code.
First-class support for <code>select</code> statements will be available soon.</p>
            </div>

            <pre data-example="&quot;use fmt\nuse time\n\nfn main() {\n    let (tx1, rx1) = Channel.new()\n    let (tx2, rx2) = Channel.new()\n\n    spawn (|| {\n        tx1.Send(\&quot;a\&quot;)\n    })()\n\n    spawn (|| {\n        time.Sleep(2 * time.Second)\n        tx2.Send(\&quot;b\&quot;)\n    })()\n\n    @rawgo (\n        \\\\ select {\n        \\\\   case a := &lt;-rx1:\n        \\\\     fmt.Println(\&quot;got\&quot;, a)\n        \\\\   case b := &lt;-rx2:\n        \\\\     fmt.Println(\&quot;got\&quot;, b)\n        \\\\ }\n    )\n}&quot;">use fmt
use time

fn main() {
    let (tx1, rx1) = Channel.new()
    let (tx2, rx2) = Channel.new()

    spawn (|| {
        tx1.Send(&quot;a&quot;)
    })()

    spawn (|| {
        time.Sleep(2 * time.Second)
        tx2.Send(&quot;b&quot;)
    })()

    @rawgo (
        \\ select {
        \\   case a := &lt;-rx1:
        \\     fmt.Println(&quot;got&quot;, a)
        \\   case b := &lt;-rx2:
        \\     fmt.Println(&quot;got&quot;, b)
        \\ }
    )
}</pre>
          </article>
            </section>

    <section class="editor-pane">
      <div class="actions">
        <button onclick="Borgo.compile()" title="Shift + Enter">Run</button>
      </div>

      <div id="editor">
        <div>
          Loading compiler &amp; stdlib...
        </div>

        <textarea style="display: none;">/// Start editing
    use fmt;
    fn main() {
      fmt.Println("Hello world");
    }</textarea>
      </div>

      <pre id="output"></pre>

      <pre id="errors"></pre>
    </section>
  </main>

  <footer>
    <p><a href="https://github.com/borgo-lang/borgo">Borgo on Github</a>
    </p>
  </footer>
  <script type="module">document.documentElement.classList.add("has-js");</script>
  <script src="/bundle.js"></script> 
  <script type="module">
    // Rust compiler
    import { default as initRust, compile_wasm } from "/pkg/wasm.js";

    initRust().then(() => window.Borgo.compiler_ready())

    window.Borgo.compile_wasm = compile_wasm

    window.Borgo.main()
  </script>
</body>
</html>
