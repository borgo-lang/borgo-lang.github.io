<!DOCTYPE html>
<html>
<head>
  <title>Borgo Programming Language</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <header>
    <h1>Borgo Programming Language</h1>
  </header>

  <main>
    <div class="links-pane">
      <section id="examples">
                  <a
            href="#intro"
            onClick="Borgo.selectExample('intro')"
          >
              Intro          </a>
                  <a
            href="#primitive-types"
            onClick="Borgo.selectExample('primitive-types')"
          >
              Primitive Types          </a>
                  <a
            href="#control-flow"
            onClick="Borgo.selectExample('control-flow')"
          >
              Control flow          </a>
                  <a
            href="#union-types-and-pattern-matching"
            onClick="Borgo.selectExample('union-types-and-pattern-matching')"
          >
              Union types and pattern matching          </a>
                  <a
            href="#structs"
            onClick="Borgo.selectExample('structs')"
          >
              Structs          </a>
                  <a
            href="#result-and-option"
            onClick="Borgo.selectExample('result-and-option')"
          >
              Result and Option          </a>
                  <a
            href="#interoperability-with-go"
            onClick="Borgo.selectExample('interoperability-with-go')"
          >
              Interoperability with Go          </a>
                  <a
            href="#package-definitions"
            onClick="Borgo.selectExample('package-definitions')"
          >
              Package definitions          </a>
                  <a
            href="#pointers-and-references"
            onClick="Borgo.selectExample('pointers-and-references')"
          >
              Pointers and References          </a>
                  <a
            href="#methods"
            onClick="Borgo.selectExample('methods')"
          >
              Methods          </a>
                  <a
            href="#interfaces-traits"
            onClick="Borgo.selectExample('interfaces-traits')"
          >
              Interfaces (traits)          </a>
                  <a
            href="#error-handling"
            onClick="Borgo.selectExample('error-handling')"
          >
              Error handling          </a>
              </section>
    </div>

    <section id="content" class="content-pane">
                  <article data-slug="intro">
            <h2>
              Intro            </h2>

            <div>
              <p><strong>Borgo</strong> is a programming language that targets Go.</p>

<p>Imagine Go had:</p>

<ul>
<li>Rust syntax</li>
<li>Union types</li>
<li><code>Option&lt;T&gt;</code> instead of <code>nil</code></li>
<li><code>Result&lt;T&gt;</code> instead of <code>T, error</code></li>
<li>Error handling with <code>?</code> operator</li>
</ul>

<p>Borgo is still early in development, but should be usable!</p>

<p>This playground runs the compiler as a wasm binary and then sends the transpiled
go output to the official Go playground for execution.</p>

<p>Check the README for instructions on how to run the compiler locally.</p>
            </div>

            <pre data-example="&quot;use fmt;\n\nfn main() {\n    fmt.Println(\&quot;hi\&quot;)\n}\n&quot;">use fmt;

fn main() {
    fmt.Println(&quot;hi&quot;)
}
</pre>
          </article>
                  <article data-slug="primitive-types">
            <h2>
              Primitive Types            </h2>

            <div>
              <p>Primitive types are the same as in Go.</p>

<p>Collections like slices and maps can be used without specifying the type of the
values.</p>

<p>For example, a slice of int elements would be declared as <code>[]int{1,2,3}</code> in Go,
whereas Borgo doesn&#39;t need type information, so you can just write <code>[1, 2, 3]</code>.</p>

<p>Functions like <code>append()</code> and <code>len()</code> are available as methods.</p>

<p>Maps are initialized with the <code>Map::new()</code> function, which under the hood
compiles to a <code>map[K]V{}</code> expression, with the <code>K</code> and <code>V</code> types helpfully
filled in for you.</p>

<p>Borgo also has tuples! They work exactly like in Rust.</p>
            </div>

            <pre data-example="&quot;use fmt;\n\nfn main() {\n    let n = 1;\n    let s = \&quot;hello\&quot;;\n    let b = false;\n\n    fmt.Println(\&quot;primitives: \&quot;, n, s, b);\n\n    let mut xs = [1, 2, 3];\n    fmt.Println(\&quot;slice:\&quot;, xs);\n\n    xs = xs.append(10);\n    fmt.Println(\&quot;len after append:\&quot;, xs.len());\n\n    let mut m = Map::new();\n    m.insert(1, \&quot;alice\&quot;);\n    m.insert(2, \&quot;bob\&quot;);\n\n    fmt.Println(\&quot;map:\&quot;, m);\n\n    let pair = (\&quot;hey\&quot;, true);\n    fmt.Println(\&quot;second element in tuple:\&quot;, pair.1);\n}\n&quot;">use fmt;

fn main() {
    let n = 1;
    let s = &quot;hello&quot;;
    let b = false;

    fmt.Println(&quot;primitives: &quot;, n, s, b);

    let mut xs = [1, 2, 3];
    fmt.Println(&quot;slice:&quot;, xs);

    xs = xs.append(10);
    fmt.Println(&quot;len after append:&quot;, xs.len());

    let mut m = Map::new();
    m.insert(1, &quot;alice&quot;);
    m.insert(2, &quot;bob&quot;);

    fmt.Println(&quot;map:&quot;, m);

    let pair = (&quot;hey&quot;, true);
    fmt.Println(&quot;second element in tuple:&quot;, pair.1);
}
</pre>
          </article>
                  <article data-slug="control-flow">
            <h2>
              Control flow            </h2>

            <div>
              <p>Like in Go, the only values that can be iterated over are slices, maps, channels
and strings.</p>

<p>However, loops always iterate over a single value, which is the element in the
slice (contrary to Go, where using a single iteration variable gives you the
index of the element).</p>

<p>To iterate over <code>(index, element)</code> pairs call the <code>.enumerate()</code> method on
slices. This has no runtime cost, it just aids the compiler in generating the
correct code.</p>

<p>When iterating over maps, you should always destructure values with
<code>(key, value)</code> pairs instead of a single value.</p>

<p>Like in Rust, infinite loops use the <code>loop {}</code> construct whereas loops with
conditions use <code>while {}</code>.</p>

<p>Expressions like <code>if</code>, <code>match</code> and blocks return a value, so you can assign
their result to a variable.</p>
            </div>

            <pre data-example="&quot;use fmt;\nuse math::rand;\n\nfn main() {\n    let xs = [\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;];\n\n    fmt.Println(\&quot;For loop over slices\&quot;);\n    for letter in xs {\n        fmt.Println(letter);\n    }\n\n    fmt.Println(\&quot;Indexed for loop\&quot;);\n    for (index, letter) in xs.enumerate() {\n        fmt.Println(index, letter);\n    }\n\n    let m = Map::new();\n    m.insert(1, \&quot;alice\&quot;);\n    m.insert(2, \&quot;bob\&quot;);\n\n    fmt.Println(\&quot;For loop over maps\&quot;);\n    for (key, value) in m {\n        fmt.Println(key, value);\n    }\n\n    fmt.Println(\&quot;Loop with no condition\&quot;);\n    loop {\n        let n = rand.Float64();\n        fmt.Println(\&quot;looping...\&quot;, n);\n\n        if n &gt; 0.75 {\n            break;\n        }\n    }\n\n    fmt.Println(\&quot;While loop\&quot;);\n\n    let mut count = 0;\n    while (count &lt; 5) {\n        fmt.Println(count);\n        count = count + 1;\n    }\n\n    fmt.Println(\&quot;using if statements as expressions\&quot;);\n    fmt.Println(if 5 &gt; 3 { \&quot;ok\&quot; } else { \&quot;nope\&quot; });\n\n    let block_result = {\n        let a = 1;\n        let b = 2;\n        a + b\n    };\n\n    fmt.Println(\&quot;block result:\&quot;, block_result);\n}\n&quot;">use fmt;
use math::rand;

fn main() {
    let xs = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];

    fmt.Println(&quot;For loop over slices&quot;);
    for letter in xs {
        fmt.Println(letter);
    }

    fmt.Println(&quot;Indexed for loop&quot;);
    for (index, letter) in xs.enumerate() {
        fmt.Println(index, letter);
    }

    let m = Map::new();
    m.insert(1, &quot;alice&quot;);
    m.insert(2, &quot;bob&quot;);

    fmt.Println(&quot;For loop over maps&quot;);
    for (key, value) in m {
        fmt.Println(key, value);
    }

    fmt.Println(&quot;Loop with no condition&quot;);
    loop {
        let n = rand.Float64();
        fmt.Println(&quot;looping...&quot;, n);

        if n &gt; 0.75 {
            break;
        }
    }

    fmt.Println(&quot;While loop&quot;);

    let mut count = 0;
    while (count &lt; 5) {
        fmt.Println(count);
        count = count + 1;
    }

    fmt.Println(&quot;using if statements as expressions&quot;);
    fmt.Println(if 5 &gt; 3 { &quot;ok&quot; } else { &quot;nope&quot; });

    let block_result = {
        let a = 1;
        let b = 2;
        a + b
    };

    fmt.Println(&quot;block result:&quot;, block_result);
}
</pre>
          </article>
                  <article data-slug="union-types-and-pattern-matching">
            <h2>
              Union types and pattern matching            </h2>

            <div>
              <p>Union types work pretty much like in Rust.</p>

<p>Pattern matches must be exhaustive, meaning the compiler will return an error
when a case is missing (try removing any case statement from the example and see
what happens!).</p>

<p>Check the
<a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">Rust book chapter on enums</a>
if you want to learn more.</p>

<blockquote class="hint"><p>For now, variants can only be defined as tuples and not as structs.</p>
</blockquote>            </div>

            <pre data-example="&quot;use fmt;\nuse strings;\n\nenum IpAddr {\n    V4(uint8, uint8, uint8, uint8),\n    V6(string),\n}\n\nfn is_private(ip: IpAddr) -&gt; bool {\n    match ip {\n        IpAddr::V4(a, b, _, _) =&gt; {\n            if a == 10 {\n                return true;\n            }\n\n            if a == 172 &amp;&amp; b &gt;= 16 &amp;&amp; b &lt;= 31 {\n                return true;\n            }\n\n            if a == 192 &amp;&amp; b == 168 {\n                return true;\n            }\n\n            false\n        }\n\n        IpAddr::V6(s) =&gt; strings.HasPrefix(s, \&quot;fc00::\&quot;),\n    }\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -&gt; int {\n    match coin {\n        Coin::Penny =&gt; 1,\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter =&gt; 25,\n    }\n}\n\nfn main() {\n    let home = IpAddr::V4(127, 0, 0, 1);\n    let loopback = IpAddr::V6(\&quot;::1\&quot;);\n    fmt.Println(\&quot;home ip is private: \&quot;, home, is_private(home));\n    fmt.Println(\&quot;loopback: \&quot;, loopback);\n\n    let cents = value_in_cents(Coin::Nickel);\n    fmt.Println(\&quot;cents:\&quot;, cents);\n}\n&quot;">use fmt;
use strings;

enum IpAddr {
    V4(uint8, uint8, uint8, uint8),
    V6(string),
}

fn is_private(ip: IpAddr) -&gt; bool {
    match ip {
        IpAddr::V4(a, b, _, _) =&gt; {
            if a == 10 {
                return true;
            }

            if a == 172 &amp;&amp; b &gt;= 16 &amp;&amp; b &lt;= 31 {
                return true;
            }

            if a == 192 &amp;&amp; b == 168 {
                return true;
            }

            false
        }

        IpAddr::V6(s) =&gt; strings.HasPrefix(s, &quot;fc00::&quot;),
    }
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; int {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}

fn main() {
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(&quot;::1&quot;);
    fmt.Println(&quot;home ip is private: &quot;, home, is_private(home));
    fmt.Println(&quot;loopback: &quot;, loopback);

    let cents = value_in_cents(Coin::Nickel);
    fmt.Println(&quot;cents:&quot;, cents);
}
</pre>
          </article>
                  <article data-slug="structs">
            <h2>
              Structs            </h2>

            <div>
              <p>Defining and instantiating structs is similar to Rust.</p>

<p>Fields in structs can be modified only if the variable is declared as mutable
(<code>let mut</code> keyword).</p>
            </div>

            <pre data-example="&quot;use fmt;\n\nstruct Person {\n    name: string,\n    hobbies: [Hobby],\n}\n\nenum Hobby {\n    SkyDiving,\n    StaringAtWall,\n    Other(string),\n}\n\nfn main() {\n    let mut p = Person {\n        name: \&quot;bob\&quot;,\n        hobbies: [Hobby::StaringAtWall, Hobby::Other(\&quot;sleep\&quot;)],\n    };\n\n    fmt.Println(\&quot;person:\&quot;, p);\n\n    p.hobbies = p.hobbies.append(Hobby::SkyDiving);\n    fmt.Println(\&quot;with more hobbies:\&quot;, p);\n}\n&quot;">use fmt;

struct Person {
    name: string,
    hobbies: [Hobby],
}

enum Hobby {
    SkyDiving,
    StaringAtWall,
    Other(string),
}

fn main() {
    let mut p = Person {
        name: &quot;bob&quot;,
        hobbies: [Hobby::StaringAtWall, Hobby::Other(&quot;sleep&quot;)],
    };

    fmt.Println(&quot;person:&quot;, p);

    p.hobbies = p.hobbies.append(Hobby::SkyDiving);
    fmt.Println(&quot;with more hobbies:&quot;, p);
}
</pre>
          </article>
                  <article data-slug="result-and-option">
            <h2>
              Result and Option            </h2>

            <div>
              <p>Sometimes it&#39;s helpful to deal with values that may or may not be there. This is
the idea behind the <code>Option&lt;T&gt;</code> type.</p>

<p>For example, to get an element out of a slice or a map, you can use the
<code>.get(index)</code> method that will force you to handle the case where the element
isn&#39;t there.</p>

<p>Other times you may want to return a value <em>or</em> an error. In those cases use
<code>Result&lt;T, E&gt;</code> to let the caller know that a function may return an error.</p>

<p>When you&#39;re sure that a value is <em>definitely</em> there, you can call <code>.unwrap()</code>.
Like in Rust, this is an unsafe operation and will panic.</p>

<p>A lot of methods are missing from both <code>Result</code> and <code>Option</code>, contributions to
the stdlib are welcome!</p>
            </div>

            <pre data-example="&quot;use fmt;\n\nstruct Person {\n    name: string,\n    age: int,\n}\n\nfn validate(name: string, age: int) -&gt; Result&lt;Person, string&gt; {\n    if (age &lt; 18) {\n        return Err(\&quot;too young\&quot;);\n    }\n\n    if (age &gt; 98) {\n        return Err(\&quot;too old\&quot;);\n    }\n\n    Ok(Person { name, age })\n}\n\nfn main() {\n    let xs = [\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;];\n    let element = xs.get(2); // Option&lt;string&gt;\n\n    match element {\n        Some(s) =&gt; fmt.Println(\&quot;ok, the element was found:\&quot;, s),\n        None =&gt; fmt.Println(\&quot;element not found\&quot;),\n    }\n\n    let result = validate(\&quot;alice\&quot;, 33); // Result&lt;Person, string&gt;\n\n    match result {\n        Ok(p) =&gt; fmt.Println(\&quot;got a person:\&quot;, p),\n        Err(e) =&gt; fmt.Println(\&quot;couldn&#39;t validate:\&quot;, e),\n    }\n}\n&quot;">use fmt;

struct Person {
    name: string,
    age: int,
}

fn validate(name: string, age: int) -&gt; Result&lt;Person, string&gt; {
    if (age &lt; 18) {
        return Err(&quot;too young&quot;);
    }

    if (age &gt; 98) {
        return Err(&quot;too old&quot;);
    }

    Ok(Person { name, age })
}

fn main() {
    let xs = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
    let element = xs.get(2); // Option&lt;string&gt;

    match element {
        Some(s) =&gt; fmt.Println(&quot;ok, the element was found:&quot;, s),
        None =&gt; fmt.Println(&quot;element not found&quot;),
    }

    let result = validate(&quot;alice&quot;, 33); // Result&lt;Person, string&gt;

    match result {
        Ok(p) =&gt; fmt.Println(&quot;got a person:&quot;, p),
        Err(e) =&gt; fmt.Println(&quot;couldn&#39;t validate:&quot;, e),
    }
}
</pre>
          </article>
                  <article data-slug="interoperability-with-go">
            <h2>
              Interoperability with Go            </h2>

            <div>
              <p>One ambitious goal of this project is to be fully compatible with the existing
Go ecosystem.</p>

<p>You&#39;ve already seen how the <code>fmt</code> package was used in previous examples, but how
do we deal with functions that return multiple values?</p>

<p>This is where our trusty <code>Option</code> and <code>Result</code> types come in! The compiler will
handle the conversion <em>automatically</em> for you :)</p>

<p>A good mental model is to think of return types in Go functions as:</p>

<pre><code>when return type is    (T, bool)
it becomes             Option&lt;T&gt;

when return type is    (T, error)
it becomes             Result&lt;T, E&gt;
</code></pre>

<p>Let&#39;s take the <a href="https://pkg.go.dev/os#LookupEnv">os.LookupEnv</a> function as an
example:</p>

<pre><code>Go definition:
  func LookupEnv(key string) (string, bool)

becomes:
  fn LookupEnv(key: string) -&gt; Option&lt;string&gt;
</code></pre>

<p>Or the <a href="https://pkg.go.dev/os#Stat">os.Stat</a> function from the same package:</p>

<pre><code>Go definition:
  func Stat(name string) (FileInfo, error)

becomes:
  fn Stat(name: string) -&gt; Result&lt;FileInfo&gt;
</code></pre>

<blockquote class="hint"><p><code>Result&lt;T&gt;</code> is short-hand for <code>Result&lt;T, error&gt;</code> where <code>error</code> is the standard
Go interface.</p>
</blockquote>
<p>With this simple convention, pretty much any Go package can be used in Borgo
code! All is needed is a package declaration, which is discussed in the next
section.</p>
            </div>

            <pre data-example="&quot;use fmt;\nuse io::fs; // TODO there should be no need of importing this\nuse os;\n\nfn main() {\n    let key = os.LookupEnv(\&quot;HOME\&quot;);\n\n    match key {\n        // Option&lt;T&gt;\n        Some(s) =&gt; fmt.Println(\&quot;home dir:\&quot;, s),\n        None =&gt; fmt.Println(\&quot;Not found in env\&quot;),\n    }\n\n    let info = os.Stat(\&quot;file-does-not-exist\&quot;);\n\n    match info {\n        // Result&lt;T, E&gt;\n        Ok(_) =&gt; fmt.Println(\&quot;The file exists\&quot;),\n        Err(err) =&gt; fmt.Println(\&quot;Got error reading file\&quot;, err),\n    }\n}\n&quot;">use fmt;
use io::fs; // TODO there should be no need of importing this
use os;

fn main() {
    let key = os.LookupEnv(&quot;HOME&quot;);

    match key {
        // Option&lt;T&gt;
        Some(s) =&gt; fmt.Println(&quot;home dir:&quot;, s),
        None =&gt; fmt.Println(&quot;Not found in env&quot;),
    }

    let info = os.Stat(&quot;file-does-not-exist&quot;);

    match info {
        // Result&lt;T, E&gt;
        Ok(_) =&gt; fmt.Println(&quot;The file exists&quot;),
        Err(err) =&gt; fmt.Println(&quot;Got error reading file&quot;, err),
    }
}
</pre>
          </article>
                  <article data-slug="package-definitions">
            <h2>
              Package definitions            </h2>

            <div>
              <p>In order to use existing Go packages, Borgo needs to know what types and
functions they contain. This is done in declaration files, which serve a similar
purpose to what you might see in Typescript with <code>d.ts</code> files.</p>

<p>Only a small part of the Go stdlib is currently available for use in Borgo --
check the <a href="https://github.com/borgo-lang/borgo/tree/main/std">std/</a> folder for
more information.</p>

<p>The example on the right uses the <code>regexp</code> package from the Go standard library.
The relevant bindings are defined in <code>std/regexp/regexp.brg</code> (here&#39;s a snippet):</p>

<pre><code>struct Regexp { }

fn Compile  (expr: string) -&gt; Result&lt;&amp;Regexp&gt; { EXT }

fn CompilePOSIX  (expr: string) -&gt; Result&lt;&amp;Regexp&gt; { EXT }

fn MustCompile  (str: string) -&gt; &amp;Regexp { EXT }

fn MustCompilePOSIX  (str: string) -&gt; &amp;Regexp { EXT }

fn Match  (pattern: string, b: [byte]) -&gt; Result&lt;bool&gt; { EXT }

// ... other stuff
</code></pre>

<p>Writing such declarations by hand is a pain! There&#39;s no reason why this process
couldn&#39;t be automated though. The compiler comes with an <code>importer</code> tool that
parses a Go package and generates corresponding bindings to be used in Borgo.</p>

<p>To run the importer on any package in the stdlib, you can use something like the
following:</p>

<pre><code>just run-importer -folder $(go env GOROOT)/src/regexp &gt; std/regexp/regexp.brg
</code></pre>

<p>All packages also need to be listed in
<a href="https://github.com/borgo-lang/borgo/tree/main/std/modules.json">std/modules.json</a>
for now.</p>
            </div>

            <pre data-example="&quot;use fmt;\nuse regexp;\n\nfn main() {\n    let validID = regexp.MustCompile(r\&quot;^[a-z]+\\[[0-9]+\\]$\&quot;);\n\n    fmt.Println(validID.MatchString(\&quot;adam[23]\&quot;));\n    fmt.Println(validID.MatchString(\&quot;eve[7]\&quot;));\n}\n&quot;">use fmt;
use regexp;

fn main() {
    let validID = regexp.MustCompile(r&quot;^[a-z]+\[[0-9]+\]$&quot;);

    fmt.Println(validID.MatchString(&quot;adam[23]&quot;));
    fmt.Println(validID.MatchString(&quot;eve[7]&quot;));
}
</pre>
          </article>
                  <article data-slug="pointers-and-references">
            <h2>
              Pointers and References            </h2>

            <div>
              <p><strong>NOTE</strong> Right now this is more wishful thinking than anything :D I plan to
implement an extra pass in the compiler pipeline that can check if references
are handed out correctly, but <strong>right now you can pass around references of any
type and not get an error</strong>.</p>

<p>Borgo dosn&#39;t have a borrow checker: all memory is managed by the Go runtime.
That&#39;s one of the main benefits of compiling to Go after all!</p>

<p>Despite that, when handing out a <em>reference</em> of a value to a function, it is
still useful to be explicit about whether the reference is <em>mutable</em> or
<em>immutable</em>.</p>

<p>Borgo distinguishes between:</p>

<ul>
<li><code>&amp;mut T</code> references, which allow modification of the underlying value</li>
<li><code>&amp;T</code> references, which are read-only and ensure no changes will occur</li>
</ul>

<p>So for example, a function that computes the sum of a slice of ints, has no need
to mutate it. It makes sense to accept a read-only reference.</p>

<pre><code>fn sum(xs: &amp;[int]) -&gt; int {
  // ...
}
</code></pre>

<p>Whereas if we wanted to add elements to it, then we&#39;d need a mutable reference.</p>

<pre><code>fn add_number(xs: &amp;mut [int], n: int) {
  // ...
}
</code></pre>

<p>When generating Go code, this makes no difference, it&#39;s all pointers under the
hood!</p>

<blockquote class="hint"><p>Because there&#39;s no borrow checker involved, it makes less sense to talk about
<em>exclusive</em> and <em>shared</em> references. It&#39;s perfectly valid to have multiple
mutable references live at the same point, something that would not be permitted
by Rust&#39;s ownership rules.</p>
</blockquote>            </div>

            <pre data-example="&quot;// example missing,\n\nfn main() {}\n&quot;">// example missing,

fn main() {}
</pre>
          </article>
                  <article data-slug="methods">
            <h2>
              Methods            </h2>

            <div>
              <p>To define methods on types, you can use <code>impl {}</code> blocks.</p>

<p>Methods need a <code>self</code> receiver, like in Rust. If the receiver is <code>&amp;mut self</code> or
<code>&amp;self</code> then the generated method will be a pointer receiver <code>(self *T)</code>.</p>

<p>It&#39;s also possible to declare static methods: they will compile to normal
functions namespaced with the type name (ie. <code>Person_new()</code>).</p>
            </div>

            <pre data-example="&quot;use fmt;\n\nstruct Person {\n    name: string,\n    hours_slept: int,\n}\n\nimpl Person {\n    fn new(name: string) -&gt; Person {\n        Person {\n            name,\n            hours_slept: 0,\n        }\n    }\n\n    // Needs mutable reference because modifies structure\n    fn sleep(&amp;mut self) {\n        self.hours_slept = self.hours_slept + 1;\n    }\n\n    // Ok with read-only reference\n    fn ready_for_work(&amp;self) -&gt; bool {\n        self.hours_slept &gt; 5\n    }\n\n    fn ready_to_party(&amp;self) -&gt; bool {\n        self.hours_slept &gt; 10\n    }\n}\n\nfn main() {\n    let mut p = Person::new(\&quot;alice\&quot;);\n\n    p.sleep();\n    p.sleep();\n\n    fmt.Println(\&quot;is ready:\&quot;, p.ready_for_work());\n}\n&quot;">use fmt;

struct Person {
    name: string,
    hours_slept: int,
}

impl Person {
    fn new(name: string) -&gt; Person {
        Person {
            name,
            hours_slept: 0,
        }
    }

    // Needs mutable reference because modifies structure
    fn sleep(&amp;mut self) {
        self.hours_slept = self.hours_slept + 1;
    }

    // Ok with read-only reference
    fn ready_for_work(&amp;self) -&gt; bool {
        self.hours_slept &gt; 5
    }

    fn ready_to_party(&amp;self) -&gt; bool {
        self.hours_slept &gt; 10
    }
}

fn main() {
    let mut p = Person::new(&quot;alice&quot;);

    p.sleep();
    p.sleep();

    fmt.Println(&quot;is ready:&quot;, p.ready_for_work());
}
</pre>
          </article>
                  <article data-slug="interfaces-traits">
            <h2>
              Interfaces (traits)            </h2>

            <div>
              <p>Interfaces in Borgo work the same as in Go, it&#39;s all duck typing.</p>

<p>If a type implements the methods declared by the interface, then the type is an
instance of that interface.</p>

<p>Embedded interfaces are also supported, just list out the other interfaces
<em>implied</em> by the one being defined. For example, the <code>ReadWriter</code> interface from
the <code>io</code> package can be defined as:</p>

<pre><code>trait ReadWriter: Reader + Writer {}
</code></pre>

<p>One possibly confusing detail is that Borgo uses the <code>trait</code> keyword to define
interfaces ^_^&#39;.</p>

<p>This is because the underlying parser is looking for Rust syntax. In the future
we&#39;ll have our own parser (or more realistically just a fork) and this will no
longer be a problem!</p>

<blockquote class="hint"><p>Borgo doesn&#39;t support <a href="https://go.dev/ref/spec#General_interfaces">type sets</a>,
you can only define methods in interfaces. Constraints still work, but they will
only be checked by the Go compiler.</p>
</blockquote>            </div>

            <pre data-example="&quot;use fmt;\nuse math;\n\ntrait geometry {\n    fn area() -&gt; float64;\n    fn perim() -&gt; float64;\n}\n\nstruct rect {\n    width: float64,\n    height: float64,\n}\n\nimpl rect {\n    fn area(self) -&gt; float64 {\n        self.width * self.height\n    }\n\n    fn perim(self) -&gt; float64 {\n        2 * self.width + 2 * self.height\n    }\n}\n\nstruct circle {\n    radius: float64,\n}\n\nimpl circle {\n    fn area(self) -&gt; float64 {\n        math.Pi * self.radius * self.radius\n    }\n\n    fn perim(self) -&gt; float64 {\n        2 * math.Pi * self.radius\n    }\n}\n\nfn measure(g: geometry) {\n    fmt.Println(g);\n    fmt.Println(g.area());\n    fmt.Println(g.perim());\n}\n\nfn main() {\n    let r = rect {\n        width: 3,\n        height: 4,\n    };\n    let c = circle { radius: 5 };\n\n    measure(r);\n    measure(c);\n}\n&quot;">use fmt;
use math;

trait geometry {
    fn area() -&gt; float64;
    fn perim() -&gt; float64;
}

struct rect {
    width: float64,
    height: float64,
}

impl rect {
    fn area(self) -&gt; float64 {
        self.width * self.height
    }

    fn perim(self) -&gt; float64 {
        2 * self.width + 2 * self.height
    }
}

struct circle {
    radius: float64,
}

impl circle {
    fn area(self) -&gt; float64 {
        math.Pi * self.radius * self.radius
    }

    fn perim(self) -&gt; float64 {
        2 * math.Pi * self.radius
    }
}

fn measure(g: geometry) {
    fmt.Println(g);
    fmt.Println(g.area());
    fmt.Println(g.perim());
}

fn main() {
    let r = rect {
        width: 3,
        height: 4,
    };
    let c = circle { radius: 5 };

    measure(r);
    measure(c);
}
</pre>
          </article>
                  <article data-slug="error-handling">
            <h2>
              Error handling            </h2>

            <div>
              <p>In functions that return a <code>Result</code>, it&#39;s possible to propagate errors with the
<code>?</code> operator.</p>

<p>This is similar to what happens in Rust, refer to the section on
<a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors">Propagating errors</a>
in the Rust book .</p>

<p>Currently the <code>?</code> operator only works with <code>Result</code>, but it will be extended to
also work with <code>Option</code>.</p>
            </div>

            <pre data-example="&quot;use fmt;\nuse io;\nuse os;\n\nfn copy_file(src: string, dst: string) -&gt; Result&lt;(), error&gt; {\n    let stat = os.Stat(src)?;\n\n    if !stat.Mode().IsRegular() {\n        return Err(fmt.Errorf(\&quot;%s is not a regular file\&quot;, src));\n    }\n\n    let source = os.Open(src)?;\n    defer!(source.Close());\n\n    let destination = os.Create(dst)?;\n    defer!(destination.Close());\n\n    // ignore number of bytes copied\n    let _ = io.Copy(destination, source)?;\n\n    Ok(())\n}\n\nfn main() {\n    match copy_file(\&quot;go.mod\&quot;, \&quot;asdf\&quot;) {\n        Ok(_) =&gt; fmt.Println(\&quot;file copied\&quot;),\n        Err(e) =&gt; fmt.Println(\&quot;error copying:\&quot;, e),\n    }\n}\n&quot;">use fmt;
use io;
use os;

fn copy_file(src: string, dst: string) -&gt; Result&lt;(), error&gt; {
    let stat = os.Stat(src)?;

    if !stat.Mode().IsRegular() {
        return Err(fmt.Errorf(&quot;%s is not a regular file&quot;, src));
    }

    let source = os.Open(src)?;
    defer!(source.Close());

    let destination = os.Create(dst)?;
    defer!(destination.Close());

    // ignore number of bytes copied
    let _ = io.Copy(destination, source)?;

    Ok(())
}

fn main() {
    match copy_file(&quot;go.mod&quot;, &quot;asdf&quot;) {
        Ok(_) =&gt; fmt.Println(&quot;file copied&quot;),
        Err(e) =&gt; fmt.Println(&quot;error copying:&quot;, e),
    }
}
</pre>
          </article>
            </section>

    <section class="editor-pane">
      <div class="actions">
        <button onclick="Borgo.compile()" title="Shift + Enter">Run</button>
      </div>

      <div id="editor">
        <div>
          Loading compiler &amp; stdlib...
        </div>

        <textarea style="display: none;">/// Start editing
    use fmt;
    fn main() {
      fmt.Println("Hello world");
    }</textarea>
      </div>

      <pre id="output"></pre>

      <pre id="errors"></pre>
    </section>
  </main>

  <footer>
    <p><a href="https://github.com/borgo-lang/borgo">Borgo on Github</a>
    </p>
  </footer>
  <script type="module">document.documentElement.classList.add("has-js");</script>
  <script src="/bundle.js"></script> 
  <script type="module">
    // Rust compiler
    import { default as initRust, compile_wasm } from "/pkg/wasm.js";

    initRust().then(() => window.Borgo.compiler_ready())

    window.Borgo.compile_wasm = compile_wasm

    window.Borgo.main()
  </script>
</body>
</html>
